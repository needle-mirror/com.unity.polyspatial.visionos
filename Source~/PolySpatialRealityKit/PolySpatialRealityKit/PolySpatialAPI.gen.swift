// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

@_implementationOnly import FlatBuffers

internal enum Unity_PolySpatial_PolySpatialMagicCookie: UInt64, Enum, Verifiable {
  internal typealias T = UInt64
  internal static var byteSize: Int { return MemoryLayout<UInt64>.size }
  internal var value: UInt64 { return self.rawValue }
  case value = 1746124864139345000

  internal static var max: Unity_PolySpatial_PolySpatialMagicCookie { return .value }
  internal static var min: Unity_PolySpatial_PolySpatialMagicCookie { return .value }
}


internal enum Unity_PolySpatial_Internals_PolySpatialProtocolVersion: UInt32, Enum, Verifiable {
  internal typealias T = UInt32
  internal static var byteSize: Int { return MemoryLayout<UInt32>.size }
  internal var value: UInt32 { return self.rawValue }
  case value = 4139

  internal static var max: Unity_PolySpatial_Internals_PolySpatialProtocolVersion { return .value }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialProtocolVersion { return .value }
}


///  Logging Categories. Used to designate what log level a specific log
///  operation is requesting. If that log level is enabled then the log
///  operation will succeed. Otherwise, the log action is ignored.
internal enum Unity_PolySpatial_Internals_PolySpatialLogCategory: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Debug log level messages.
  case debug = 0
  ///  Log messages from or about the PolySpatial Asset Manager.
  case assetManager = 1
  ///  Log messages from or about PolySpatial build.
  case build = 2
  ///  Log messages about the Camera.
  case camera = 3
  ///  Log messages from or about change handlers within PolySpatial.
  case changeHandlers = 4
  ///  General diagnostic log messages that are above Debug but fall into
  case diagnostics = 5
  ///  Log messages from or about game object lifecycle management.
  case gameObjectLifecycle = 6
  ///  Log messages from or about PolySpatial session state.
  case sessionState = 7
  ///  Log messages from or about general PolySpatial networking.
  case netConnection = 8
  ///  Log messages from or about sending network messages.
  case netSend = 9
  ///  Log messages from or about receiving network messages.
  case netReceive = 10
  ///  Log message about volume cameras
  case volumeCameras = 11
  ///  Log message about volume renderers
  case volumeRenderers = 12
  ///  Log messages from the platform
  case platform = 13
  ///  Log messages from XR events
  case xr = 14

  internal static var max: Unity_PolySpatial_Internals_PolySpatialLogCategory { return .xr }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialLogCategory { return .debug }
}


internal enum Unity_PolySpatial_Internals_PolySpatialLogLevel: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case exception = 0
  case assert = 1
  case error = 2
  case warning = 3
  case log = 4
  case debug = 5
  case debug1 = 6
  case debug2 = 7
  case debug3 = 8

  internal static var max: Unity_PolySpatial_Internals_PolySpatialLogLevel { return .debug3 }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialLogLevel { return .exception }
}


internal enum Unity_PolySpatial_Internals_LogMarkupType: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case instanceIdtoGameObject = 0

  internal static var max: Unity_PolySpatial_Internals_LogMarkupType { return .instanceIdtoGameObject }
  internal static var min: Unity_PolySpatial_Internals_LogMarkupType { return .instanceIdtoGameObject }
}


///  ErrorCodes are encoded as follows:
///      0x0V0ABBCC
///  0 - reserved hex digit
///  V - Version number, currently 0
///  A - Error Family
///  BB - Error Category: Should be non-zero.
///  CC - Error code: Errors are encoded in ascending order (must not be 0x00)
internal enum Unity_PolySpatial_Internals_ErrorCode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case none_ = 0
  case protocolCategory = 256
  case protocolMismatch = 257
  case magicCookieMismatch = 258
  case capabilityCategory = 512
  case remoteLacksCapability = 513
  case remoteRequiresCapability = 514
  case connectionCategory = 768
  case connectionLost = 769
  case connectionLostSessionStillRunning = 770
  case connectionLostHostBackgrounded = 771
  case connectionRejected = 772

  internal static var max: Unity_PolySpatial_Internals_ErrorCode { return .connectionRejected }
  internal static var min: Unity_PolySpatial_Internals_ErrorCode { return .none_ }
}


internal enum Unity_PolySpatial_Internals_ParticleReplicationMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case replicateProperties = 0
  case bakeToMesh = 1
  case bakeToTexture = 2

  internal static var max: Unity_PolySpatial_Internals_ParticleReplicationMode { return .bakeToTexture }
  internal static var min: Unity_PolySpatial_Internals_ParticleReplicationMode { return .replicateProperties }
}


///  Defines the motion vector generation mode.
internal enum Unity_PolySpatial_Internals_PolySpatialMotionVectorGenerationMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Use only camera movement to track motion.
  case camera = 0
  ///  Use a specific pass (if required) to track motion.
  case object = 1
  ///  Do not track motion. Motion vectors will be 0.
  case forceNoMotion = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialMotionVectorGenerationMode { return .forceNoMotion }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialMotionVectorGenerationMode { return .camera }
}


///  Defines the light probe usage for a GameObject.
internal enum Unity_PolySpatial_Internals_PolySpatialLightProbeUsage: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Use the default light probe usage.
  case off = 0
  ///  Use the light probes for lighting.
  case blendProbes = 1
  ///  Use the light probes for lighting and reflection probes for reflections.
  case useProxyVolume = 2
  ///  Use a custom provided light probe with SH properties via MaterialPropertyBlock.
  case customProvided = 4

  internal static var max: Unity_PolySpatial_Internals_PolySpatialLightProbeUsage { return .customProvided }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialLightProbeUsage { return .off }
}


///  PolySpatial tracking lifecycle flags. These are used to check and manage
///  the lifetime of all items that are being tracked withing the PolySpatial
///  system.
internal struct Unity_PolySpatial_Internals_PolySpatialTrackingFlags: OptionSet, Enum, Verifiable {
  internal typealias T = UInt32
  internal let rawValue: T

  internal init(rawValue: T) {
    self.rawValue = rawValue
  }

  internal static var byteSize: Int { return MemoryLayout<UInt32>.size }
  internal var value: UInt32 { return self.rawValue }
  ///  The tracked item has been created.
  internal static let created = Unity_PolySpatial_Internals_PolySpatialTrackingFlags(rawValue: 1)
  ///  The tracked item has transitioned to the Running state.
  internal static let running = Unity_PolySpatial_Internals_PolySpatialTrackingFlags(rawValue: 2)
  ///  The tracked item has been destroyed. And data pertaining to
  ///  this item should be cleaned up.
  internal static let destroyed = Unity_PolySpatial_Internals_PolySpatialTrackingFlags(rawValue: 4)
  ///  The tracked item and data have been cleaned up. The tracking data is no
  ///  longer valid in this state.
  internal static let deallocated = Unity_PolySpatial_Internals_PolySpatialTrackingFlags(rawValue: 8)
  ///  The tracked item data is dirty. This means that some change has occured
  ///  to the state of this tracked item. Any thing that depends on this data
  ///  must check the data for changes and update accordingly.
  internal static let dirty = Unity_PolySpatial_Internals_PolySpatialTrackingFlags(rawValue: 16)
  ///  The tracked item is disabled. The tracked data is still valid, but the item
  ///  is not enabled.
  internal static let disabled = Unity_PolySpatial_Internals_PolySpatialTrackingFlags(rawValue: 32)
  ///  The tracked item is attached to an inactive GameObject. The tracked data is still valid, but
  ///  the GameObject is not active.
  internal static let inactive = Unity_PolySpatial_Internals_PolySpatialTrackingFlags(rawValue: 64)

  internal static let none: Unity_PolySpatial_Internals_PolySpatialTrackingFlags = []
  internal static let all: Unity_PolySpatial_Internals_PolySpatialTrackingFlags = [.created, .running, .destroyed, .deallocated, .dirty, .disabled, .inactive]
}


///  Defines the sorting group that a PolySpatial entity belongs to.
///  All entities in the same sorting group are sorted together using
///  the sorting order defined for that group in it's data.
internal enum Unity_PolySpatial_Internals_PolySpatialSortGroup: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Default sorting group used to sort all other entities.
  case default_ = 0
  ///  Sprite sorting group used to sort all Sprites.
  case sprite = 1
  ///  Canvas sorting group used to sort all UGUI UI entities.
  case canvas = 2
  ///  Particle sorting group used to sort all BakeToMesh Particle Systems.
  case particleSystem = 3

  internal static var max: Unity_PolySpatial_Internals_PolySpatialSortGroup { return .particleSystem }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialSortGroup { return .default_ }
}


///  Describes the manner in which an entity casts shadows, if it does so.  Values match those in
///  UnityEngine.Rendering.ShadowCastingMode.
internal enum Unity_PolySpatial_Internals_PolySpatialShadowCastingMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  The entity does not cast shadows.
  case off = 0
  ///  The entity casts normal shadows.
  case on = 1
  ///  The entity is treated as two-sided for the purpose of shadow-casting.
  case twoSided = 2
  ///  The entity casts shadows, but is not otherwise rendered.
  case shadowsOnly = 3

  internal static var max: Unity_PolySpatial_Internals_PolySpatialShadowCastingMode { return .shadowsOnly }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialShadowCastingMode { return .off }
}


///  Some platform runtime configuration flags
internal struct Unity_PolySpatial_Internals_PolySpatialRuntimeFlags: OptionSet, Enum, Verifiable {
  internal typealias T = UInt32
  internal let rawValue: T

  internal init(rawValue: T) {
    self.rawValue = rawValue
  }

  internal static var byteSize: Int { return MemoryLayout<UInt32>.size }
  internal var value: UInt32 { return self.rawValue }
  internal static let debugOverlayEnabled = Unity_PolySpatial_Internals_PolySpatialRuntimeFlags(rawValue: 1)
  internal static let disableNativeTexture = Unity_PolySpatial_Internals_PolySpatialRuntimeFlags(rawValue: 8)
  internal static let dontAbortOnError = Unity_PolySpatial_Internals_PolySpatialRuntimeFlags(rawValue: 16)
  internal static let stopOnCoreException = Unity_PolySpatial_Internals_PolySpatialRuntimeFlags(rawValue: 32)
  internal static let uniqueInvalidMaterialColors = Unity_PolySpatial_Internals_PolySpatialRuntimeFlags(rawValue: 64)
  internal static let disableEnvironmentLighting = Unity_PolySpatial_Internals_PolySpatialRuntimeFlags(rawValue: 128)
  internal static let maximizeEnvironmentLighting = Unity_PolySpatial_Internals_PolySpatialRuntimeFlags(rawValue: 256)
  internal static let updateMeshesSynchronously = Unity_PolySpatial_Internals_PolySpatialRuntimeFlags(rawValue: 512)

  internal static let none: Unity_PolySpatial_Internals_PolySpatialRuntimeFlags = []
  internal static let all: Unity_PolySpatial_Internals_PolySpatialRuntimeFlags = [.debugOverlayEnabled, .disableNativeTexture, .dontAbortOnError, .stopOnCoreException, .uniqueInvalidMaterialColors, .disableEnvironmentLighting, .maximizeEnvironmentLighting, .updateMeshesSynchronously]
}


///  Values should match those of UnityEditor.BuildTarget.
internal enum Unity_PolySpatial_Internals_PolySpatialBuildTarget: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case unused = 0
  case standaloneOsx = 2
  case standaloneWindows = 5
  case iOs = 9
  case android = 13
  case standaloneWindows64 = 19
  case webGl = 20
  case wsaplayer = 21
  case standaloneLinux64 = 24
  case ps4 = 31
  case xboxOne = 33
  case tvOs = 37
  case switch_ = 38
  case linuxHeadlessSimulation = 41
  case ps5 = 44
  case visionOs = 47

  internal static var max: Unity_PolySpatial_Internals_PolySpatialBuildTarget { return .visionOs }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialBuildTarget { return .unused }
}


///  Types of asset caches available for networked applications
internal enum Unity_PolySpatial_Internals_PolySpatialAssetCacheType: UInt32, Enum, Verifiable {
  internal typealias T = UInt32
  internal static var byteSize: Int { return MemoryLayout<UInt32>.size }
  internal var value: UInt32 { return self.rawValue }
  ///  Assets stored in the backend, not currently in use by a session
  case notInUse = 0
  ///  Asset data stored in files on-disk
  case disk = 1

  internal static var max: Unity_PolySpatial_Internals_PolySpatialAssetCacheType { return .disk }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialAssetCacheType { return .notInUse }
}


internal struct Unity_PolySpatial_Internals_PolySpatialAssetCommandMetadataFlags: OptionSet, Enum, Verifiable {
  internal typealias T = UInt8
  internal let rawValue: T

  internal init(rawValue: T) {
    self.rawValue = rawValue
  }

  internal static var byteSize: Int { return MemoryLayout<UInt8>.size }
  internal var value: UInt8 { return self.rawValue }
  ///  The dataHash has been computed
  internal static let dataHashSet = Unity_PolySpatial_Internals_PolySpatialAssetCommandMetadataFlags(rawValue: 1)
  ///  The data for this asset is sent in multiple commands
  internal static let progressive = Unity_PolySpatial_Internals_PolySpatialAssetCommandMetadataFlags(rawValue: 2)
  ///  This command contains the final set of data for a progressive asset
  internal static let progressiveComplete = Unity_PolySpatial_Internals_PolySpatialAssetCommandMetadataFlags(rawValue: 4)

  internal static let none: Unity_PolySpatial_Internals_PolySpatialAssetCommandMetadataFlags = []
  internal static let all: Unity_PolySpatial_Internals_PolySpatialAssetCommandMetadataFlags = [.dataHashSet, .progressive, .progressiveComplete]
}


///  Describes the transform data for an entity in a transform delta buffer
internal struct Unity_PolySpatial_Internals_PolySpatialTransformDeltaFlags: OptionSet, Enum, Verifiable {
  internal typealias T = UInt8
  internal let rawValue: T

  internal init(rawValue: T) {
    self.rawValue = rawValue
  }

  internal static var byteSize: Int { return MemoryLayout<UInt8>.size }
  internal var value: UInt8 { return self.rawValue }
  ///  The entity did not have a transform update in the previous frame
  internal static let isNewEntry = Unity_PolySpatial_Internals_PolySpatialTransformDeltaFlags(rawValue: 1)
  ///  The entity did not have a transform update this frame
  internal static let isFinalEntry = Unity_PolySpatial_Internals_PolySpatialTransformDeltaFlags(rawValue: 2)
  ///  The index into the previous frame's transform delta that matches this entry
  internal static let hasPreviousIndex = Unity_PolySpatial_Internals_PolySpatialTransformDeltaFlags(rawValue: 4)
  ///  The entry contains a Vector3 position
  internal static let hasPosition = Unity_PolySpatial_Internals_PolySpatialTransformDeltaFlags(rawValue: 8)
  ///  The entry contains a Quaternion rotation
  internal static let hasRotation = Unity_PolySpatial_Internals_PolySpatialTransformDeltaFlags(rawValue: 16)
  ///  The entry contains a Vector3 scale
  internal static let hasScale = Unity_PolySpatial_Internals_PolySpatialTransformDeltaFlags(rawValue: 32)

  internal static let none: Unity_PolySpatial_Internals_PolySpatialTransformDeltaFlags = []
  internal static let all: Unity_PolySpatial_Internals_PolySpatialTransformDeltaFlags = [.isNewEntry, .isFinalEntry, .hasPreviousIndex, .hasPosition, .hasRotation, .hasScale]
}


///  Describes the weighted mode of the animation curve.
internal enum Unity_PolySpatial_Internals_PolySpatialAnimationCurveWeightedMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Exclude both inWeight or outWeight when calculating curve segments.
  case none_ = 0
  ///  Include inWeight when calculating the previous curve segment.
  case in_ = 1
  ///  Include outWeight when calculating the next curve segment.
  case out = 2
  ///  Include inWeight and outWeight when calculating curve segments.
  case both = 3

  internal static var max: Unity_PolySpatial_Internals_PolySpatialAnimationCurveWeightedMode { return .both }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialAnimationCurveWeightedMode { return .none_ }
}


///  Determines how time is treated outside of the keyframed range of an AnimationClip or AnimationCurve.
internal enum Unity_PolySpatial_Internals_PolySpatialAnimationCurveWrapMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Reads the default repeat mode set higher up.
  case default_ = 0
  ///  Clamps the animation to the beginning and end values of the animation curve.
  case clamp = 1
  ///  When time reaches the end of the animation clip, the clip will automatically stop playing and time will be reset to beginning of the clip.
  case once = 2
  ///  When time reaches the end of the animation clip, time will continue at the beginning.
  case loop = 3
  ///  When time reaches the end of the animation clip, time will ping pong back between beginning and end.
  case pingPong = 4
  ///  Plays back the animation. When it reaches the end, it will keep playing the last frame and never stop playing.
  case clampForever = 5

  internal static var max: Unity_PolySpatial_Internals_PolySpatialAnimationCurveWrapMode { return .clampForever }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialAnimationCurveWrapMode { return .default_ }
}


///  Describes the mode in which the gradient is evaluated.
internal enum Unity_PolySpatial_Internals_PolySpatialGradientMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Linearly interpolate between the gradient keys.
  case blend = 0
  ///  Use a constant color between the keys.
  case fixed = 1
  ///  Linearly interpolate between the gradient keys, using a perceptual color space for colors.
  case perceptualBlend = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialGradientMode { return .perceptualBlend }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialGradientMode { return .blend }
}


///  Describes the state in which the capability is supported by the remote(s).
internal enum Unity_PolySpatial_Internals_RemoteSupport: Int8, Enum, Verifiable {
  internal typealias T = Int8
  internal static var byteSize: Int { return MemoryLayout<Int8>.size }
  internal var value: Int8 { return self.rawValue }
  case noRemotesConnected = 0
  case noRemotesSupported = 1
  case someRemotesSupported = 2
  case allRemotesSupported = 3
  case remoteRequired = 4

  internal static var max: Unity_PolySpatial_Internals_RemoteSupport { return .remoteRequired }
  internal static var min: Unity_PolySpatial_Internals_RemoteSupport { return .noRemotesConnected }
}


///  Describes the local support for the capability.
internal enum Unity_PolySpatial_Internals_LocalSupport: Int8, Enum, Verifiable {
  internal typealias T = Int8
  internal static var byteSize: Int { return MemoryLayout<Int8>.size }
  internal var value: Int8 { return self.rawValue }
  case unsupported = 0
  case supported = 1
  case required_ = 2

  internal static var max: Unity_PolySpatial_Internals_LocalSupport { return .required_ }
  internal static var min: Unity_PolySpatial_Internals_LocalSupport { return .unsupported }
}


internal enum Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode: Int16, Enum, Verifiable {
  internal typealias T = Int16
  internal static var byteSize: Int { return MemoryLayout<Int16>.size }
  internal var value: Int16 { return self.rawValue }
  case invalid = -1
  case bounded = 0
  case unbounded = 1
  case metal = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode { return .metal }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode { return .invalid }
}


///  The direction a user is facing the volume from.
internal enum Unity_PolySpatial_Internals_PolySpatialVolumeViewpoint: Int16, Enum, Verifiable {
  internal typealias T = Int16
  internal static var byteSize: Int { return MemoryLayout<Int16>.size }
  internal var value: Int16 { return self.rawValue }
  case front = 0
  case back = 1
  case left_ = 2
  case right_ = 3

  internal static var max: Unity_PolySpatial_Internals_PolySpatialVolumeViewpoint { return .right_ }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialVolumeViewpoint { return .front }
}


internal enum Unity_PolySpatial_Internals_PolySpatialCameraRenderType: Int16, Enum, Verifiable {
  internal typealias T = Int16
  internal static var byteSize: Int { return MemoryLayout<Int16>.size }
  internal var value: Int16 { return self.rawValue }
  case base = 0
  case overlay = 1

  internal static var max: Unity_PolySpatial_Internals_PolySpatialCameraRenderType { return .overlay }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialCameraRenderType { return .base }
}


///  Defines the way the camera background is cleared.  Values match those of UnityEngine.CameraClearFlags.
internal enum Unity_PolySpatial_Internals_PolySpatialCameraClearFlags: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case unused = 0
  case skybox = 1
  case solidColor = 2
  case depth = 3
  case nothing = 4

  internal static var max: Unity_PolySpatial_Internals_PolySpatialCameraClearFlags { return .nothing }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialCameraClearFlags { return .unused }
}


///  What window event occured.
internal enum Unity_PolySpatial_Internals_WindowEvent: Int16, Enum, Verifiable {
  internal typealias T = Int16
  internal static var byteSize: Int { return MemoryLayout<Int16>.size }
  internal var value: Int16 { return self.rawValue }
  case opened = 0
  case resized = 1
  case focused = 2
  case backgrounded = 3
  case closed = 4

  internal static var max: Unity_PolySpatial_Internals_WindowEvent { return .closed }
  internal static var min: Unity_PolySpatial_Internals_WindowEvent { return .opened }
}


///  Enumeration describing the different mesh face topologies
///  that may be found in a Unity mesh.  Matches UnityEngine.MeshTopology.
internal enum Unity_PolySpatial_Internals_PolySpatialMeshTopology: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Triangle mesh topology.
  case triangles = 0
  ///  Quad mesh topology.
  case quads = 2
  ///  Line mesh topology.
  case lines = 3
  ///  Line strip mesh topology.
  case lineStrip = 4
  ///  Point only mesh topology.
  case points = 5

  internal static var max: Unity_PolySpatial_Internals_PolySpatialMeshTopology { return .points }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialMeshTopology { return .triangles }
}


///  Describes the format of indices in the index buffer; matches UnityEngine.Rendering.IndexFormat.
internal enum Unity_PolySpatial_Internals_PolySpatialIndexFormat: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case uint16 = 0
  case uint32 = 1

  internal static var max: Unity_PolySpatial_Internals_PolySpatialIndexFormat { return .uint32 }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialIndexFormat { return .uint16 }
}


///  Describes the semantics of a vertex attribute; matches UnityEngine.Rendering.VertexAttribute.
internal enum Unity_PolySpatial_Internals_PolySpatialVertexAttribute: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case position = 0
  case normal = 1
  case tangent = 2
  case color = 3
  case texCoord0 = 4
  case texCoord1 = 5
  case texCoord2 = 6
  case texCoord3 = 7
  case texCoord4 = 8
  case texCoord5 = 9
  case texCoord6 = 10
  case texCoord7 = 11
  case blendWeight = 12
  case blendIndices = 13

  internal static var max: Unity_PolySpatial_Internals_PolySpatialVertexAttribute { return .blendIndices }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialVertexAttribute { return .position }
}


///  Describes the format of a vertex attribute; matches UnityEngine.Rendering.VertexAttributeFormat.
internal enum Unity_PolySpatial_Internals_PolySpatialVertexAttributeFormat: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case float32 = 0
  case float16 = 1
  case unorm8 = 2
  case snorm8 = 3
  case unorm16 = 4
  case snorm16 = 5
  case uint8 = 6
  case sint8 = 7
  case uint16 = 8
  case sint16 = 9
  case uint32 = 10
  case sint32 = 11

  internal static var max: Unity_PolySpatial_Internals_PolySpatialVertexAttributeFormat { return .sint32 }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialVertexAttributeFormat { return .float32 }
}


internal enum Unity_PolySpatial_Internals_PolySpatialTextureFilterMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case point = 0
  case bilinear = 1
  case trilinear = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialTextureFilterMode { return .trilinear }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialTextureFilterMode { return .point }
}


internal enum Unity_PolySpatial_Internals_PolySpatialTextureWrapMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case repeat_ = 0
  case clamp = 1
  case mirror = 2
  case mirrorOnce = 3

  internal static var max: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode { return .mirrorOnce }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode { return .repeat_ }
}


internal enum Unity_PolySpatial_Internals_PolySpatialTextureShape: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case texture2D = 0
  case textureCube = 1
  case texture2Darray = 2
  case texture3D = 3
  case renderTexture = 4

  internal static var max: Unity_PolySpatial_Internals_PolySpatialTextureShape { return .renderTexture }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialTextureShape { return .texture2D }
}


internal enum Unity_PolySpatial_Internals_PolySpatialTextureFallbackMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case none_ = 0
  case singleMipLevel = 1
  case generateAllMips = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialTextureFallbackMode { return .generateAllMips }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialTextureFallbackMode { return .none_ }
}


///  Encoding format for a buffer asset.
internal enum Unity_PolySpatial_Internals_PolySpatialEncoding: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Buffer asset is a binary blob.
  case binary = 0
  ///  Buffer asset is a UTF8 text string.
  case utf8 = 1

  internal static var max: Unity_PolySpatial_Internals_PolySpatialEncoding { return .utf8 }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialEncoding { return .binary }
}


///  Enumeration describing the type of data that is in the buffer.
internal enum Unity_PolySpatial_Internals_PolySpatialBufferDescription: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  The buffer data describes a MaterialX shader.
  case materialX = 0
  ///  The buffer data describes a Unity shader.
  case unityShader = 1
  ///  The buffer data describes a material property map.
  case materialPropertyMap = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialBufferDescription { return .materialPropertyMap }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialBufferDescription { return .materialX }
}


///  Enumeration representing culling modes for face rendering.
internal enum Unity_PolySpatial_Internals_PolySpatialCullMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Denotes that no face culling should happen.
  case none_ = 0
  ///  Cull front faces from rendering.
  case front = 1
  ///  Cull back faces from rendering.
  case back = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialCullMode { return .back }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialCullMode { return .none_ }
}


///  Enumeration representing depth comparison functions (values match UnityEngine.Rendering.CompareFunction).
internal enum Unity_PolySpatial_Internals_PolySpatialCompareFunction: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Depth testing is disabled.
  case disabled = 0
  ///  Never pass depth test.
  case never = 1
  ///  Pass depth test when new value is less than current value.
  case less = 2
  ///  Pass depth test when values are equal.
  case equal = 3
  ///  Pass depth test when new value is less than or equal to current value (typical default for opaque objects).
  case lessEqual = 4
  ///  Pass depth test when new value is greater than current value.
  case greater = 5
  ///  Pass depth test when values are not equal.
  case notEqual = 6
  ///  Pass depth test when new value is greater than or equal to current value.
  case greaterEqual = 7
  ///  Always pass depth test.
  case always = 8

  internal static var max: Unity_PolySpatial_Internals_PolySpatialCompareFunction { return .always }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialCompareFunction { return .disabled }
}


///  Enumeration representing depth mask.
internal enum Unity_PolySpatial_Internals_PolySpatialZWriteControl: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Depth writes enabled or disabled automatically according to the surface type.
  case auto = 0
  ///  Force depth writes to be enabled.
  case forceEnabled = 1
  ///  Force depth writes to be disabled.
  case forceDisabled = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialZWriteControl { return .forceDisabled }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialZWriteControl { return .auto }
}


///  Denotes the blending mode for material textures.
internal enum Unity_PolySpatial_Internals_PolySpatialBlendingMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Use the alpha channel to determine how a pixel is blended.
  case alpha = 0
  ///  The texture color channels have alpha premutliplied already
  ///  so they can be blended directly.
  case premultiplied = 1
  ///  The colors channels of the source and target texture are added
  ///  to make the final color.
  case additive = 2
  ///  The color channels of the source and target texture are
  ///  multiplied to make the final color.
  case multiplicative = 3

  internal static var max: Unity_PolySpatial_Internals_PolySpatialBlendingMode { return .multiplicative }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialBlendingMode { return .alpha }
}


///  Denotes the coloring mode for particle materials, which controls how the albedo texture is combined
///  with particle color.
internal enum Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case multiply = 0
  case additive = 1
  case subtractive = 2
  case overlay = 3
  case color = 4
  case difference = 5

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode { return .difference }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode { return .multiply }
}


///  Detemines the workflow of the material, and thus
///  the specific surface rendering functionality.
internal enum Unity_PolySpatial_Internals_PolySpatialMaterialWorkflow: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Surface rendering uses a specular color to control the
  ///  the strength of specular reflections in the material.
  ///  This makes it possible to have a specular reflection of
  ///  a different color than the diffuse reflection.
  case polySpatialSpecularWorkflow = 0
  ///  States whether the material is metallic or not. In the case of a
  ///  metallic material, the Albedo color controls the color of the
  ///  specular reflection and most light reflects as specular reflections.
  ///  Non-metallic materials have specular reflections that are the same
  ///  color as the incoming light and barely reflect when looking at the surface face-on.
  case polySpatialMetallicWorkflow = 1

  internal static var max: Unity_PolySpatial_Internals_PolySpatialMaterialWorkflow { return .polySpatialMetallicWorkflow }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialMaterialWorkflow { return .polySpatialSpecularWorkflow }
}


///  Material type enum to tell the underlying rendering layer how this material should be defined.
internal enum Unity_PolySpatial_Internals_PolySpatialMaterialType: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  No material type at all.
  case none_ = 0
  ///  Simple unlit material with only one <see cref="LigheightColorMapData"/> definition.
  case unlit = 1
  ///  Rich, physically based lit material. More realistic at the cost of more resource allocation.
  case lit = 2
  ///  Lit Particle material type with unique particle properties.
  case litParticles = 3
  ///  Font material type used for text rendering.
  case text = 4
  ///  AR Occluding material
  case occlusion = 5
  ///  Unlit Particle material type with unique particle properties.
  case unlitParticles = 6
  ///  Material whose underlying shader can be defined by a shader.
  case shader = 7

  internal static var max: Unity_PolySpatial_Internals_PolySpatialMaterialType { return .shader }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialMaterialType { return .none_ }
}


///  Information about the features used by a shader.
internal struct Unity_PolySpatial_Internals_PolySpatialShaderFlags: OptionSet, Enum, Verifiable {
  internal typealias T = UInt32
  internal let rawValue: T

  internal init(rawValue: T) {
    self.rawValue = rawValue
  }

  internal static var byteSize: Int { return MemoryLayout<UInt32>.size }
  internal var value: UInt32 { return self.rawValue }
  internal static let usesLightProbes = Unity_PolySpatial_Internals_PolySpatialShaderFlags(rawValue: 1)
  internal static let usesReflectionProbes = Unity_PolySpatial_Internals_PolySpatialShaderFlags(rawValue: 2)

  internal static let none: Unity_PolySpatial_Internals_PolySpatialShaderFlags = []
  internal static let all: Unity_PolySpatial_Internals_PolySpatialShaderFlags = [.usesLightProbes, .usesReflectionProbes]
}


///  Defines the type of light that is to be created.
internal enum Unity_PolySpatial_Internals_PolySpatialLightType: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Light is a spot light. Light eminates at a specific
  ///  point in space, in a specific direction. The light
  ///  only covers a cone shaped volume and has a specific
  ///  drop off range.
  case spot = 0
  ///  Light is a directional, global light. Used to define things
  ///  like sunlight that are everywhere but coming from one direction.
  ///  Light intensity does not drop off at any point but will be the
  ///  same everywhere.
  case directional = 1
  ///  Light is a point light. Light emanates from a specific point in space
  ///  and falls off withing a specific range from the point.
  case point = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialLightType { return .point }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialLightType { return .spot }
}


///  Defines the type of shadows cast by a light.  Values match those of UnityEngine.LightShadows.
internal enum Unity_PolySpatial_Internals_PolySpatialLightShadows: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  The light does not cast shadows.
  case none_ = 0
  ///  The light casts hard shadows (no filtering).
  case hard = 1
  ///  The light casts soft shadows (filtering applied).
  case soft = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialLightShadows { return .soft }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialLightShadows { return .none_ }
}


///  Defines the type of light to use in visionOS.  Values match those of VisionOSLightSettings.LightMode.
internal enum Unity_PolySpatial_Internals_PolySpatialVisionOSLightMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Light is disabled on visionOS.
  case disabled = 0
  ///  Light is enabled on visionOS, but shadows are disabled.
  case enabledWithoutShadows = 1
  ///  Light and shadows (if any) are enabled on visionOS.
  case enabledWithShadows = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialVisionOSLightMode { return .enabledWithShadows }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialVisionOSLightMode { return .disabled }
}


///  Defines the type of lightmaps to use.  Values match those of UnityEngine.LightmapsMode.
internal enum Unity_PolySpatial_Internals_PolySpatialLightmapsMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case nonDirectional = 0
  case combinedDirectional = 1

  internal static var max: Unity_PolySpatial_Internals_PolySpatialLightmapsMode { return .combinedDirectional }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialLightmapsMode { return .nonDirectional }
}


///  Defines the horizontal justification settings for PolySpatial text
internal enum Unity_PolySpatial_Internals_PolySpatialHorizontalTextJustification: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case left_ = 0
  case center = 1
  case right_ = 2
  case justified = 3
  case none_ = 4

  internal static var max: Unity_PolySpatial_Internals_PolySpatialHorizontalTextJustification { return .none_ }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialHorizontalTextJustification { return .left_ }
}


///  Defines how a mask is to be applied when in use.
internal enum Unity_PolySpatial_Internals_PolySpatialMaskingOperation: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Tells the system to not apply the mask in any way.
  case none_ = 0
  ///  The sprite will be visible only in areas where a mask is present.
  case visibleInsideMask = 1
  ///  The sprite will be visible only in areas where no mask is present.
  case visibleOutsideMask = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialMaskingOperation { return .visibleOutsideMask }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialMaskingOperation { return .none_ }
}


internal enum Unity_PolySpatial_Internals_PolySpatialSortingDepthPass: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Draws depth of renderer after drawing all color.
  case postPass = 0
  ///  Draws depth of renderer before drawing any color.
  case prePass = 1
  ///  Draws depth and color at the same time.
  case unseparated = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialSortingDepthPass { return .unseparated }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialSortingDepthPass { return .postPass }
}


internal enum Unity_PolySpatial_Internals_PolySpatialInputType: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case pointer = 0
  case headPose = 1
  case character = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialInputType { return .character }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialInputType { return .pointer }
}


internal enum Unity_PolySpatial_Internals_PolySpatialPointerPhase: Int8, Enum, Verifiable {
  internal typealias T = Int8
  internal static var byteSize: Int { return MemoryLayout<Int8>.size }
  internal var value: Int8 { return self.rawValue }
  case none_ = 0
  case began = 1
  case moved = 2
  case ended = 3
  case cancelled = 4

  internal static var max: Unity_PolySpatial_Internals_PolySpatialPointerPhase { return .cancelled }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialPointerPhase { return .none_ }
}


internal enum Unity_PolySpatial_Internals_PolySpatialPointerKind: Int8, Enum, Verifiable {
  internal typealias T = Int8
  internal static var byteSize: Int { return MemoryLayout<Int8>.size }
  internal var value: Int8 { return self.rawValue }
  case directPinch = 0
  case indirectPinch = 1
  case touch = 2
  case pointer = 3
  case stylus = 4

  internal static var max: Unity_PolySpatial_Internals_PolySpatialPointerKind { return .stylus }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialPointerKind { return .directPinch }
}


internal struct Unity_PolySpatial_Internals_PolySpatialPointerModifierKeys: OptionSet, Enum, Verifiable {
  internal typealias T = UInt16
  internal let rawValue: T

  internal init(rawValue: T) {
    self.rawValue = rawValue
  }

  internal static var byteSize: Int { return MemoryLayout<UInt16>.size }
  internal var value: UInt16 { return self.rawValue }
  internal static let capsLock = Unity_PolySpatial_Internals_PolySpatialPointerModifierKeys(rawValue: 1)
  internal static let control = Unity_PolySpatial_Internals_PolySpatialPointerModifierKeys(rawValue: 2)
  internal static let alt = Unity_PolySpatial_Internals_PolySpatialPointerModifierKeys(rawValue: 4)
  internal static let command = Unity_PolySpatial_Internals_PolySpatialPointerModifierKeys(rawValue: 8)
  internal static let option = Unity_PolySpatial_Internals_PolySpatialPointerModifierKeys(rawValue: 16)
  internal static let shift = Unity_PolySpatial_Internals_PolySpatialPointerModifierKeys(rawValue: 32)
  internal static let numericPad = Unity_PolySpatial_Internals_PolySpatialPointerModifierKeys(rawValue: 64)

  internal static let none: Unity_PolySpatial_Internals_PolySpatialPointerModifierKeys = []
  internal static let all: Unity_PolySpatial_Internals_PolySpatialPointerModifierKeys = [.capsLock, .control, .alt, .command, .option, .shift, .numericPad]
}


internal enum Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceStatus: Int8, Enum, Verifiable {
  internal typealias T = Int8
  internal static var byteSize: Int { return MemoryLayout<Int8>.size }
  internal var value: Int8 { return self.rawValue }
  case added = 0
  case enabled = 1
  case reconnected = 2
  case disabled = 3
  case disconnected = 4
  case removed = 5

  internal static var max: Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceStatus { return .removed }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceStatus { return .added }
}


internal enum Unity_PolySpatial_Internals_PolySpatialColliderShape: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case box = 0
  case sphere = 1
  case capsule = 2
  case mesh = 3

  internal static var max: Unity_PolySpatial_Internals_PolySpatialColliderShape { return .mesh }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialColliderShape { return .box }
}


internal struct Unity_PolySpatial_Internals_PolySpatialColliderOptions: OptionSet, Enum, Verifiable {
  internal typealias T = UInt32
  internal let rawValue: T

  internal init(rawValue: T) {
    self.rawValue = rawValue
  }

  internal static var byteSize: Int { return MemoryLayout<UInt32>.size }
  internal var value: UInt32 { return self.rawValue }
  internal static let convex = Unity_PolySpatial_Internals_PolySpatialColliderOptions(rawValue: 1)
  internal static let isTrigger = Unity_PolySpatial_Internals_PolySpatialColliderOptions(rawValue: 2)
  internal static let cookForFasterSimulation = Unity_PolySpatial_Internals_PolySpatialColliderOptions(rawValue: 4)
  internal static let enableMeshCleaning = Unity_PolySpatial_Internals_PolySpatialColliderOptions(rawValue: 8)
  internal static let weldColocatedVertices = Unity_PolySpatial_Internals_PolySpatialColliderOptions(rawValue: 16)
  internal static let useFastMidphase = Unity_PolySpatial_Internals_PolySpatialColliderOptions(rawValue: 32)

  internal static let none: Unity_PolySpatial_Internals_PolySpatialColliderOptions = []
  internal static let all: Unity_PolySpatial_Internals_PolySpatialColliderOptions = [.convex, .isTrigger, .cookForFasterSimulation, .enableMeshCleaning, .weldColocatedVertices, .useFastMidphase]
}


///  Defines the ambient lighting mode.  Values match those of UnityEngine.Rendering.AmbientMode.
internal enum Unity_PolySpatial_Internals_PolySpatialAmbientMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case skybox = 0
  case trilight = 1
  case flat = 3
  case custom = 4

  internal static var max: Unity_PolySpatial_Internals_PolySpatialAmbientMode { return .custom }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialAmbientMode { return .skybox }
}


///  Defines the default reflection mode.  Values match those of UnityEngine.Rendering.DefaultReflectionMode.
internal enum Unity_PolySpatial_Internals_PolySpatialDefaultReflectionMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case skybox = 0
  case custom = 1

  internal static var max: Unity_PolySpatial_Internals_PolySpatialDefaultReflectionMode { return .custom }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialDefaultReflectionMode { return .skybox }
}


///  Defines the fog mode.  Values match those of UnityEngine.FogMode.
internal enum Unity_PolySpatial_Internals_PolySpatialFogMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case unused = 0
  case linear = 1
  case exponential = 2
  case exponentialSquared = 3

  internal static var max: Unity_PolySpatial_Internals_PolySpatialFogMode { return .exponentialSquared }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialFogMode { return .unused }
}


///  Input mode for a minmax curve.
internal enum Unity_PolySpatial_Internals_PolySpatialParticleCurveMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case constant = 0
  case curve = 1
  case randomBetweenTwoConstants = 2
  case randomBetweenTwoCurves = 3

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleCurveMode { return .randomBetweenTwoCurves }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleCurveMode { return .constant }
}


///  Mode that determines how the weights are used when calculating curve segments. These pertain to the inWeight/outWeight variables in the curve key.
internal enum Unity_PolySpatial_Internals_PolySpatialParticleCurveWeightedMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case none_ = 0
  case in_ = 1
  case out = 2
  case both = 3

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleCurveWeightedMode { return .both }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleCurveWeightedMode { return .none_ }
}


internal enum Unity_PolySpatial_Internals_PolySpatialParticlePlayState: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case playing = 0
  case paused = 1
  case stoppedEmitting = 2
  case stoppedAndClearedEmission = 3

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticlePlayState { return .stoppedAndClearedEmission }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticlePlayState { return .playing }
}


///  Input mode for colors. Some properties also have support for
///  random between two colors and two gradients, but that's not currently supported.
///  TODO: LXR-1521 add support for random between 2 colors or 2 gradients.
internal enum Unity_PolySpatial_Internals_PolySpatialParticleColorMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case color = 0
  case gradient = 1
  case randomColor = 2
  case randomBetweenTwoColors = 3
  case randomBetweenTwoGradients = 4

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleColorMode { return .randomBetweenTwoGradients }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleColorMode { return .color }
}


///  Gradient mode, determines how the colors blend from start to end.
internal enum Unity_PolySpatial_Internals_PolySpatialParticleGradientMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case perceptualBlend = 0
  case classicBlend = 1
  case fixed = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleGradientMode { return .fixed }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleGradientMode { return .perceptualBlend }
}


internal enum Unity_PolySpatial_Internals_PolySpatialParticleGravityMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case physics3D = 0
  case physics2D = 1

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleGravityMode { return .physics2D }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleGravityMode { return .physics3D }
}


///  TODO LXR-1239: add comments to these structs/classes.
internal enum Unity_PolySpatial_Internals_PolySpatialParticleEmitterGeometry: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case sphere = 0
  case hemisphere = 1
  case cone = 2
  case coneVolume = 3
  case donut = 4
  case box = 5
  case boxEdge = 6
  case boxShell = 7
  case circle = 8
  case singleSidedEdge = 9
  case rectangle = 10
  case customMesh = 11
  case customMeshRenderer = 12
  case customSprite = 13
  case customSpriteRenderer = 14

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleEmitterGeometry { return .customSpriteRenderer }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleEmitterGeometry { return .sphere }
}


internal enum Unity_PolySpatial_Internals_PolySpatialParticleMultiMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case random = 0
  case loop = 1
  case pingPong = 2
  case burstSpread = 3

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleMultiMode { return .burstSpread }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleMultiMode { return .random }
}


internal enum Unity_PolySpatial_Internals_PolySpatialParticleScalingMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case hierarchy = 0
  case local = 1
  case shape = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleScalingMode { return .shape }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleScalingMode { return .hierarchy }
}


internal enum Unity_PolySpatial_Internals_PolySpatialParticleBirthLocation: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case edge = 0
  case triangle = 1
  case vertex = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleBirthLocation { return .vertex }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleBirthLocation { return .edge }
}


internal enum Unity_PolySpatial_Internals_PolySpatialParticleSubEmitterType: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case birth = 0
  case collision = 1
  case death = 2
  case trigger = 3
  case manual = 4

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleSubEmitterType { return .manual }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleSubEmitterType { return .birth }
}


///  The values listed in this property are lifted from the ParticleSystemSubEmitterProperties and should match that enum.
internal enum Unity_PolySpatial_Internals_PolySpatialParticleSubEmitterInherit: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case nothing = 0
  case color = 1
  case size = 2
  case rotation = 4
  case lifetime = 8
  case duration = 16
  case everything = 31

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleSubEmitterInherit { return .everything }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleSubEmitterInherit { return .nothing }
}


internal enum Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case local = 0
  case world = 1
  case custom = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace { return .custom }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace { return .local }
}


internal enum Unity_PolySpatial_Internals_PolySpatialParticleCollisionType: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case planes = 0
  case world = 1

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleCollisionType { return .world }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleCollisionType { return .planes }
}


internal enum Unity_PolySpatial_Internals_PolySpatialParticleRenderMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case billboard = 0
  case stretchedBillboard = 1
  case horizontalBillboard = 2
  case verticalBillboard = 3
  case mesh = 4
  case none_ = 5

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleRenderMode { return .none_ }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleRenderMode { return .billboard }
}


internal enum Unity_PolySpatial_Internals_PolySpatialParticleSortMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case none_ = 0
  case byDistance = 1
  case byDepth = 2
  case oldestInFront = 3
  case youngestInFront = 4

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleSortMode { return .youngestInFront }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleSortMode { return .none_ }
}


internal enum Unity_PolySpatial_Internals_PolySpatialParticleAnimationType: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case wholeSheet = 0
  case singleRow = 1

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleAnimationType { return .singleRow }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleAnimationType { return .wholeSheet }
}


internal enum Unity_PolySpatial_Internals_PolySpatialParticleTimeMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case lifetime = 0
  case speed = 1
  case fps = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialParticleTimeMode { return .fps }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialParticleTimeMode { return .lifetime }
}


internal enum Unity_PolySpatial_Internals_PolySpatialVideoPlayerState: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case isPlaying = 0
  case isStopped = 1
  case isPaused = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialVideoPlayerState { return .isPaused }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialVideoPlayerState { return .isPlaying }
}


internal enum Unity_PolySpatial_Internals_PolySpatialVideoAssetStatus: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case notFound = 0
  case prerolled = 1
  case failedToPreroll = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialVideoAssetStatus { return .failedToPreroll }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialVideoAssetStatus { return .notFound }
}


internal enum Unity_PolySpatial_Internals_PolySpatialVideoSource: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  case videoClip = 0
  case url = 1

  internal static var max: Unity_PolySpatial_Internals_PolySpatialVideoSource { return .url }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialVideoSource { return .videoClip }
}


///  PolySpatial command enumeration.
///  Command values are encoded as follows:
///      0x0V0ABBCC
///  0 - reserved hex digit
///  V - Version number, currently 0
///  0 - reserved hex digit
///  A - Command Family, currently either 0x0 = client, 0x1=host, others reserved for future use
///  BB - Command Category: Should be non-zero. Categories are shared across between App and Host - for example:
///          PolySpatialCommand.SystemCommandCategory = 0x00000100
///          PolySpatialHostCommand.SystemCommandCategory = 0x00010100
///  CC - Command: Commands are encoded in ascending order (must not be 0x00).
/// 
///  Note that any changes to this layout here will also have to be applied to functions such as HostPlaybackHandler::IsHostCommand(), which relies
///  heavily on this layout.
/// 
///  WHEN ADDING A NEW COMMAND CATEGORY:
///  Also update the unit tests in PolySpatialTypeTests. These tests verify
///  that the Command names and values for the category match between PolySpatialCommand and PolySpatialHostCommand,
///  and that the Family and Command hex digit values are valid.
internal enum Unity_PolySpatial_Internals_PolySpatialCommand: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  /// --- Category for system commands sent from app to host ---
  case systemCommandCategory = 256
  ///  Send an async response to a host command; args are guid, the original command, and response data.
  case asyncResponse = 257
  ///  Pass the instance of the PolySpatial API to a platform.
  case setSimulationHostApi = 258
  ///  Send some configuration bits to the platform (see PolySpatialRuntimeFlags enum)
  case setRuntimeFlags = 259
  ///  Sent as a response to a host requesting to sync time - the app will send
  ///  its current time stamp, as well as the time stamp when the host first requested a time sync.
  case pingEcho = 260
  case echoConsoleLogMessage = 261
  ///  Requests to verify the host state.
  case verifyState = 262
  ///  Notify a host that it should end all sessions and connections. Intended to be sent from a temporary connection
  ///  that will then close. Allows for editor menu actions to force a host back into a Ready state.
  case endAllSessionsAndConnections = 263
  /// --- Category for app system commands ---
  case lifecycleCommandCategory = 512
  ///  Sent when a network connection is first formed. The host will ack this
  ///  with BeginHostconnection
  case beginConnection = 513
  ///  Sent when a network connection is closed - either intentionally or as
  ///  the result of an error. The host will ack this with EndHostConnection
  case endConnection = 514
  ///  Sent when a session is started (whether locally or via connection). The
  ///  host will ack this with BeginHostSession
  case beginSession = 515
  ///  Sent when a session ends (whether locally or via connection). The host
  ///  will ack this with EndHostSession
  ///  EndConnection should always be preceded by an EndSession, even in the
  ///  case of network errors.
  case endSession = 516
  ///  Sent when the simulation/app begins a frame of change processing. The
  ///  host will ack this with BeginHostFrame
  case beginAppFrame = 517
  ///  Sent when the simulation/app finishes a frame of change processing. The
  ///  host will ack this with EndHostFrame
  case endAppFrame = 518
  ///  Any project level data we will need to remap on the other side, like 
  ///  sorting layers for example.
  case sendProjectSettings = 519
  /// --- Category for asset commands sent from app to host ---
  case assetCommandCategory = 768
  ///  delete a given resource matching
  ///  an specific PolySpatialAssetID.
  case deleteAsset = 769
  ///  Asks the platform to create or update a mesh resources
  ///  given data provided by a PolySpatialMesh instance.
  case createOrUpdateMeshAsset = 770
  ///  Create or update a mesh resource based on native resource pointers.
  case createOrUpdateNativeMeshAsset = 771
  ///  Create or update a texture resource
  ///  based on data from a Unity Texture asset directly.
  case createOrUpdateTextureAsset = 772
  ///  Create or update a texture resource based on a native resource pointer.
  case createOrUpdateNativeTextureAsset = 773
  ///  Create or update a resource based on data
  ///  in a PolySpatialBufferData instance.
  case createOrUpdateBufferAsset = 774
  ///  Create or update a font material
  ///  resource based on data in a PolySpatialUnlitMaterial instance.
  case createOrUpdateFontMaterialAsset = 775
  ///  Create or update a material
  ///  resource based on data in a PolySpatialUnlitMaterial instance.
  case createOrUpdateUnlitMaterialAsset = 776
  ///  Create or update a material
  ///  resource based on data in a PolySpatialPBRMaterial instance.
  case createOrUpdatePbrmaterialAsset = 777
  ///  Create or update a shader material
  ///  resource based on data in a PolySpatialShaderMaterial instance.
  case createOrUpdateShaderMaterialAsset = 778
  ///  Create or update a occlusion material
  ///  resource based on data in a PolySpatialOcclusionMaterial instance.
  case createOrUpdateOcclusionMaterialAsset = 779
  ///  Create or update an unlit particle material
  ///  resource based on data in a PolySpatialParticleMaterial instance.
  case createOrUpdateLitParticleMaterialAsset = 780
  ///  Create or update an unlit particle material
  ///  resource based on data in a PolySpatialParticleMaterial instance.
  case createOrUpdateUnlitParticleMaterialAsset = 781
  ///  Create or update a shader asset
  case createShaderAsset = 782
  ///  Async create or update a shader asset
  case createShaderAssetAsync = 783
  ///  Create or update a shader property map
  ///  for a shader resource.
  case createShaderPropertyMap = 784
  ///  Create or update a TMP font asset
  ///  for platformst that support TMP.
  case createOrUpdateTmpFontAsset = 785
  ///  Create or update a binary font asset
  ///  for platforms that support TT/OT fonts
  ///  and not TMP fonts.
  case createOrUpdateFontAsset = 786
  ///  Create or update a volume profile resource (for post-processing effects).
  case createOrUpdateRenderingVolumeProfileAsset = 787
  ///  Notify a Host's asset cache that an asset is now in use, meaning it cannot be a candidate for cleanup
  case markAssetInUse = 788
  ///  Notify a Host's asset cache that an asset is no longer in use, meaning it is now a candidate for cleanup
  case markAssetNotInUse = 789
  ///  Confirmation from the App to Host that asset cache entries can be removed
  case removeAssetCacheEntries = 790
  case createOrUpdateGenericAsset = 791
  /// --- Category for entity commands sent from app to host ---
  case entityCommandCategory = 1024
  ///  set or update the transform information for an entity.
  case setEntityTransforms = 1025
  ///  add an array of entities
  case addEntities = 1026
  ///  delete an array of entities
  case deleteEntities = 1027
  ///  set the state of an array of entities. first arg is length,
  ///  second arg is an array of IDs, third is a singular state (only 1 bit, "enabled")
  case setEntitiesState = 1028
  ///  set the parent entity of a given entity.
  case setEntityParents = 1029
  case setEntityDebugInfo = 1030
  case addEntitiesWithTransforms = 1031
  ///  Update the transform information for an entity based on previously received delta information
  case setEntityTransformDeltas = 1032
  ///  Update the transform information for an entity with interpolated values
  case setEntityInterpolatedTransformDeltas = 1033
  /// --- Category for component commands sent from app to host ---
  case componentCommandCategory = 1280
  ///  Call deletion on selected components in backend. Used to cleanup
  ///  components on backend outside of the normal deletion routine (like on disconnects).
  case deleteComponent = 1281
  ///  Create/update/destroy a renderable mesh
  case createOrUpdateMeshRenderer = 1282
  case destroyMeshRenderer = 1283
  ///  Create/update/destroy a skinned mesh
  case createOrUpdateSkinnedMeshRenderer = 1284
  case destroySkinnedMeshRenderer = 1285
  ///  update a skinned mesh's blend shape weights.
  case setSkinnedMeshBlendShapeData = 1286
  ///  Create/update/destroy a light
  case createOrUpdateLight = 1287
  case destroyLight = 1288
  ///  Create/update/destroy a particle system
  case createOrUpdateParticleSystem = 1289
  case destroyParticleSystem = 1290
  ///  Create/update/destroy a line renderer.
  case createOrUpdateLineRenderer = 1291
  case destroyLineRenderer = 1292
  ///  Create/update/destroy a trail renderer.
  case createOrUpdateTrailRenderer = 1293
  case destroyTrailRenderer = 1294
  ///  Create/update/destroy a sprite item.
  case createOrUpdateSpriteRenderer = 1295
  case destroySpriteRenderer = 1296
  ///  Create/update/destroy the mask information for a sprite mask.
  case createOrUpdateSpriteMask = 1297
  case destroySpriteMask = 1298
  case createOrUpdateVisionOssortingGroup = 1299
  case destroyVisionOssortingGroup = 1300
  ///  Create/update/destroy a video player component
  case createOrUpdateVideoPlayer = 1301
  case destroyVideoPlayer = 1302
  ///  Create/update/destroy a collider component
  case createOrUpdateCollider = 1303
  case destroyCollider = 1304
  ///  Create/update/destroy a VisionOSNativeText component.
  case createOrUpdateVisionOsnativeText = 1305
  case destroyVisionOsnativeText = 1306
  ///  set or update data for stereo renderer component
  case setStereoRendererComponentData = 1307
  case createOrUpdateVisionOsimageBasedLight = 1308
  case destroyVisionOsimageBasedLight = 1309
  case createOrUpdateVisionOsimageBasedLightReceiver = 1310
  case destroyVisionOsimageBasedLightReceiver = 1311
  ///  Create/update/destroy an environment lighting configuration component.
  case createOrUpdateVisionOsenvironmentLightingConfiguration = 1312
  case destroyVisionOsenvironmentLightingConfiguration = 1313
  ///  Create/update/destroy a renderable canvas
  case createOrUpdateCanvasRenderer = 1314
  case destroyCanvasRenderer = 1315
  ///  Create a RuntimeReferenceImageLibrary for an XRImageTrackingSubsystem
  case createOrUpdateReferenceImageLibrary = 1316
  ///  Sends one image to add into an XRImageTrackingSubsystem using ScheduleAddImageJob
  case addTrackedImage = 1317
  ///  Create/update/destroy an alignment marker.
  case createOrUpdateAlignmentMarker = 1318
  case destroyAlignmentMarker = 1319
  ///  Create/update/destroy a rendering volume component.
  case createOrUpdateRenderingVolume = 1320
  case destroyRenderingVolume = 1321
  ///  Create/update/destroy a serialized generic component.
  case createOrUpdateGenericComponent = 1322
  ///  Synchronize generic component persistent data allocations.
  case createOrUpdateGenericComponentData = 1323
  case destroyGenericComponent = 1324
  ///  Create/update/destroy a halo component
  case createOrUpdateHalo = 1325
  case destroyHalo = 1326
  /// --- Category for camera commands sent from app to host ---
  case cameraCommandCategory = 1536
  ///  Request the current camera pose from a platform.
  case getCameraPose = 1537
  ///  Create/update/destroy a camera.
  case createOrUpdateCamera = 1538
  case destroyCamera = 1539
  ///  Create/update/destroy a volume camera.
  case createOrUpdateVolumeCamera = 1540
  case destroyVolumeCamera = 1541
  ///  OBSOLETE - take a screenshot and save it to disk.
  case takeScreenshot = 1542
  ///  take a screenshot with given camera params and return PNG bytes via ScreenshotResult
  case screenshot = 1543
  ///  set data for stereo renderer framebuffer
  case setStereoRendererFramebuffer = 1544
  /// --- Category for general graphics commands sent from app to host ---
  case graphicsCommandCategory = 1792
  ///  Create/update/destroy a UI graphic
  case createOrUpdateUigraphic = 1793
  case destroyUigraphic = 1794
  ///  Create/update/destroy a HoverEffect component.
  case createOrUpdateVisionOshoverEffect = 1795
  case destroyVisionOshoverEffect = 1796
  ///  Sets the names of the shader global properties.
  case setShaderGlobalPropertyMap = 1797
  ///  Sets the values of the shader global properties.
  case setShaderGlobalPropertyValues = 1798
  ///  Sets the values of the render settings properties.
  case setRenderSettings = 1799
  ///  Sets the values of the graphics settings properties.
  case setGraphicsSettings = 1800
  ///  Sets the global lightmap settings.
  case setLightmapSettings = 1801
  ///  Create/update/destroy a GroundingShadow component.
  case createOrUpdateVisionOsgroundingShadow = 1802
  case destroyVisionOsgroundingShadow = 1803
  ///  Create/update/destroy a Billboard component.
  case createOrUpdateVisionOsbillboard = 1804
  case destroyVisionOsbillboard = 1805
  /// --- Placeholder Category for input to keep app/host categories in sync ---
  case inputCommandCategory = 2048
  ///  Reports the connection state of a device back to a host.
  ///  This is a host specific event and should not be broadcast
  ///  to all clients.
  case inputSystemDeviceConnectedEvent = 2049
  /// --- Placeholder Category for XR commands to keep app/host categories in sync ---
  case xrcommandCategory = 2304
  /// --- Category for general audio commands sent from app to host ---
  case audioCommandCategory = 4096
  ///  Streams audio from app to host. Each UpdateAudioStream command is accompanied by a variable length
  ///  float array packet that represents PCM audio data.
  case updateAudioStream = 4097

  internal static var max: Unity_PolySpatial_Internals_PolySpatialCommand { return .updateAudioStream }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialCommand { return .systemCommandCategory }
}


///  The command type the platform may send to the hosting environment.
internal enum Unity_PolySpatial_Internals_PolySpatialHostCommand: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  /// --- Category for system commands sent from host to app ---
  case systemCommandCategory = 65792
  ///  Send an async response to a command; args are guid, the original command, and response data
  ///  Must be command 01! (must be equal to PolySpatialCommand.AsyncResponse)
  case asyncResponse = 65793
  ///  Asks the host to log a message.
  case logMessage = 65794
  ///  Asks the host to log a message, and decorate it with information the client doesn't have access to.
  case logMessageWithMarkup = 65795
  ///  First sent when a host receives BeginConnection command. Sends a request to
  ///  app to sync time.
  case ping = 65796
  case setConsoleLogMessageEnabled = 65797
  ///  Responds to a state verification request.
  case stateVerificationResult = 65798
  /// --- Category for lifecycle commands sent from host to app ---
  case lifecycleCommandCategory = 66048
  ///  Acknowledge a BeginConnection command and send back connection data
  case beginHostConnection = 66049
  ///  Acknowledge an EndConnection command
  case endHostConnection = 66050
  ///  Acknowledge a BeginSession command and send back session data
  case beginHostSession = 66051
  ///  Acknowledge an EndSession command
  case endHostSession = 66052
  ///  Acknowledge and echo back frame info received via a BeginAppFrame command
  case beginHostFrame = 66053
  ///  Acknowledge and echo back frame info received via a endAppFrame command
  case endHostFrame = 66054
  /// --- Category for asset commands sent from host to app ---
  case assetCommandCategory = 66304
  ///  Host command -- sends back information about whether a native texture upload succeeded or not
  case textureUploadResult = 66305
  ///  Sent when a connection is created, contains the keys of the Host's asset cache
  case syncAssetCacheKeys = 66306
  ///  Sent when a Host wants to remove entries from its asset cache. Entries must be removed on the app-side
  ///  first to avoid synchronization issues. App is expected to reply with RemoveAssetCacheEntries
  ///  containing all entries that can be safely removed.
  case requestRemoveAssetCacheEntries = 66307
  /// --- Placeholder Category for entity commands to host/app subcategories in sync ---
  case entityCommandCategory = 66560
  /// --- Placeholder Category for component commands to host/app subcategories in sync ---
  case componentCommandCategory = 66816
  ///  Indicates state of video asset. This isn't included under the typical assets section since
  ///  it's the status of the host-side asset as the host attempts to process the video asset.
  case updateVideoAssetStatus = 66817
  /// --- Category for camera commands sent from host to app ---
  case cameraCommandCategory = 67072
  ///  Receive a screenshot result
  case screenshotResult = 67073
  ///  Provide the state of a window for a volume camera. Argument is a PolySpatialWindowState
  case updateWindowState = 67074
  ///  Provide the immersion amount for ImmersiveSpace when its ImmersionStyle is Progressive
  ///  Argument is a Double representing the immersion amount as a percentage in the range [0 - 1]
  case updateImmersionAmount = 67075
  ///  Provide the viewpoint that a user is viewing a volume from.
  case updateVolumeViewpoint = 67076
  /// --- Placeholder Category to keep host/app subcategories in sync ---
  case graphicsCommandCategory = 67328
  /// --- Category for input commands sent from host to app ---
  case inputCommandCategory = 67584
  ///  Report an input event to the host.
  case inputEvent = 67585
  ///  Report a Unity Input System Event
  case rawInputEvent = 67586
  ///  Sent on initial connect to inform the app the screen information for
  ///  this host.
  case configureHostDisplay = 67587
  ///  Input System device event
  case inputDeviceEvent = 67588
  ///  Input data in the format used for Unity Remote.
  case remoteInputData = 67589
  /// --- Category for XR commands sent from host to app ---
  case xrcommandCategory = 67840
  ///  Host sending the current set of all ARPlanes to a Client and signaling to turn on the ARPlane system
  case initializeArplanes = 67841
  ///  Host will use this event to send ARPlane Add/Update/Remove delta events to the Client.
  case updateArplanes = 67842
  ///  Host will use this event to send ARTrackedImage Add/Update/Remove delta events to the Client.
  case updateArtrackedImage = 67843
  ///  Host will use this to send hand tracking events to the Client
  case onXrhandTrackingEvent = 67844
  ///  Host will use this to send current Joint Pose and position info to the Client of each tracked hand
  case setXrhandData = 67845
  ///  Updates the layout of hand joints form the host XRHandSubsystem provider
  case updateHandLayout = 67846
  ///  Send an ARMesh with MeshIDs
  case sendXrmeshData = 67847
  /// --- Category for audio commands sent from host to app ---
  case audioCommandCategory = 69632

  internal static var max: Unity_PolySpatial_Internals_PolySpatialHostCommand { return .audioCommandCategory }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialHostCommand { return .systemCommandCategory }
}


///  Please keep values in line with UnityEngine.XR.ARSubsystems.PlaneAlignment
internal enum Unity_PolySpatial_Internals_PlaneAlignment: UInt16, Enum, Verifiable {
  internal typealias T = UInt16
  internal static var byteSize: Int { return MemoryLayout<UInt16>.size }
  internal var value: UInt16 { return self.rawValue }
  ///  <summary>
  ///  No alignment.
  ///  </summary>
  case none_ = 0
  ///  <summary>
  ///  The plane is horizontal with an upward facing normal (for example, a floor).
  ///  </summary>
  case horizontalUp = 100
  ///  <summary>
  ///  The plane is horizontal with a downward facing normal (for example, a ceiling).
  ///  </summary>
  case horizontalDown = 101
  ///  <summary>
  ///  The plane is vertical (for example, a wall).
  ///  </summary>
  case vertical = 200
  ///  <summary>
  ///  The plane is not aligned with any axis.
  ///  </summary>
  case notAxisAligned = 300

  internal static var max: Unity_PolySpatial_Internals_PlaneAlignment { return .notAxisAligned }
  internal static var min: Unity_PolySpatial_Internals_PlaneAlignment { return .none_ }
}


///  Represents the action the ARPlane is taking
internal enum Unity_PolySpatial_Internals_ARPlaneOperation: UInt8, Enum, Verifiable {
  internal typealias T = UInt8
  internal static var byteSize: Int { return MemoryLayout<UInt8>.size }
  internal var value: UInt8 { return self.rawValue }
  ///  <summary>
  ///  ARPlane created
  ///  </summary>
  case created = 0
  ///  <summary>
  ///  ARPlane updated
  ///  </summary>
  case updated = 1
  ///  <summary>
  ///  ARPlane removed
  ///  </summary>
  case removed = 2

  internal static var max: Unity_PolySpatial_Internals_ARPlaneOperation { return .removed }
  internal static var min: Unity_PolySpatial_Internals_ARPlaneOperation { return .created }
}


///  Please keep values in line with UnityEngine.XR.ARSubsystems.TrackingState
internal enum Unity_PolySpatial_Internals_ARTrackingState: UInt8, Enum, Verifiable {
  internal typealias T = UInt8
  internal static var byteSize: Int { return MemoryLayout<UInt8>.size }
  internal var value: UInt8 { return self.rawValue }
  ///  <summary>
  ///  Not tracking.
  ///  </summary>
  case none_ = 0
  ///  <summary>
  ///  Some tracking information is available, but it is limited or of poor quality.
  ///  </summary>
  case limited = 1
  ///  <summary>
  ///  Tracking is working normally.
  ///  </summary>
  case tracking = 2

  internal static var max: Unity_PolySpatial_Internals_ARTrackingState { return .tracking }
  internal static var min: Unity_PolySpatial_Internals_ARTrackingState { return .none_ }
}


///  The types of hover effects available for use.  The values correspond to the ones in VisionOSHoverEffect.EffectType.
internal enum Unity_PolySpatial_Internals_PolySpatialHoverEffectType: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  A hover effect that shows a spotlight around the hovered position.
  case spotlight = 0
  ///  A hover effect that shows a spotlight plus a uniform highlight.
  case highlight = 1
  ///  A hover effect driven by a shader.
  case shader = 2

  internal static var max: Unity_PolySpatial_Internals_PolySpatialHoverEffectType { return .shader }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialHoverEffectType { return .spotlight }
}


internal enum Unity_PolySpatial_Internals_PolySpatialXRHandTrackingEvent: UInt8, Enum, Verifiable {
  internal typealias T = UInt8
  internal static var byteSize: Int { return MemoryLayout<UInt8>.size }
  internal var value: UInt8 { return self.rawValue }
  ///  <summary>
  ///  LostHandTracking
  ///  </summary>
  case lost = 0
  ///  <summary>
  ///  Just Acquired hand tracking
  ///  </summary>
  case acquired = 1

  internal static var max: Unity_PolySpatial_Internals_PolySpatialXRHandTrackingEvent { return .acquired }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialXRHandTrackingEvent { return .lost }
}


internal enum Unity_PolySpatial_Internals_PolySpatialHandID: UInt8, Enum, Verifiable {
  internal typealias T = UInt8
  internal static var byteSize: Int { return MemoryLayout<UInt8>.size }
  internal var value: UInt8 { return self.rawValue }
  ///  <summary>
  ///  Left hand
  ///  </summary>
  case left_ = 0
  ///  <summary>
  ///  Right hand
  ///  </summary>
  case right_ = 1

  internal static var max: Unity_PolySpatial_Internals_PolySpatialHandID { return .right_ }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialHandID { return .left_ }
}


internal enum Unity_PolySpatial_Internals_PolySpatialJointTrackingState: UInt8, Enum, Verifiable {
  internal typealias T = UInt8
  internal static var byteSize: Int { return MemoryLayout<UInt8>.size }
  internal var value: UInt8 { return self.rawValue }
  ///  <summary>
  ///  No data is currently being tracked for a joint.
  ///  </summary>
  case none_ = 0
  ///  <summary>
  ///  Radius of current joint.
  ///  </summary>
  case radius = 1
  ///  <summary>
  ///  Pose of current joint, relative to the [XROrigin](xref:Unity.XR.CoreUtils.XROrigin).
  ///  </summary>
  case pose = 2
  ///  <summary>
  ///  Linear velocity of current joint, relative to the [XROrigin](xref:Unity.XR.CoreUtils.XROrigin).
  ///  </summary>
  case linearVelocity = 4
  ///  <summary>
  ///  Angular velocity of current joint, relative to the [XROrigin](xref:Unity.XR.CoreUtils.XROrigin).
  ///  </summary>
  case angularVelocity = 8
  ///  <summary>
  ///  Joint was marked as not being part of the hand layout for the current provider.
  ///  </summary>
  case willNeverBeValid = 16

  internal static var max: Unity_PolySpatial_Internals_PolySpatialJointTrackingState { return .willNeverBeValid }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialJointTrackingState { return .none_ }
}


///  Represents the action the ARMesh is taking
internal enum Unity_PolySpatial_Internals_PolySpatialMeshChangeState: UInt8, Enum, Verifiable {
  internal typealias T = UInt8
  internal static var byteSize: Int { return MemoryLayout<UInt8>.size }
  internal var value: UInt8 { return self.rawValue }
  ///  <summary>
  ///  The mesh has been added since the last call to XRMeshSubsystem.TryGetMeshInfos.
  ///  </summary>
  case added = 0
  ///  <summary>
  ///  The mesh has been updated since the last call to XRMeshSubsystem.TryGetMeshInfos.
  ///  </summary>
  case updated = 1

  internal static var max: Unity_PolySpatial_Internals_PolySpatialMeshChangeState { return .updated }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialMeshChangeState { return .added }
}


///  Represents the action the ARTrackedImage is taking
internal enum Unity_PolySpatial_Internals_ARTrackedImageOperation: UInt8, Enum, Verifiable {
  internal typealias T = UInt8
  internal static var byteSize: Int { return MemoryLayout<UInt8>.size }
  internal var value: UInt8 { return self.rawValue }
  ///  <summary>
  ///  ARTrackedImage created
  ///  </summary>
  case created = 0
  ///  <summary>
  ///  ARTrackedImage updated
  ///  </summary>
  case updated = 1
  ///  <summary>
  ///  ARTrackedImage removed
  ///  </summary>
  case removed = 2

  internal static var max: Unity_PolySpatial_Internals_ARTrackedImageOperation { return .removed }
  internal static var min: Unity_PolySpatial_Internals_ARTrackedImageOperation { return .created }
}


///  Please keep values in line with UnityEngine.XR.ARSubsystems.TrackingState
internal enum Unity_PolySpatial_Internals_ARImageTrackingState: UInt8, Enum, Verifiable {
  internal typealias T = UInt8
  internal static var byteSize: Int { return MemoryLayout<UInt8>.size }
  internal var value: UInt8 { return self.rawValue }
  ///  <summary>
  ///  Not tracking.
  ///  </summary>
  case none_ = 0
  ///  <summary>
  ///  Some tracking information is available, but it is limited or of poor quality.
  ///  </summary>
  case limited = 1
  ///  <summary>
  ///  Tracking is working normally.
  ///  </summary>
  case tracking = 2

  internal static var max: Unity_PolySpatial_Internals_ARImageTrackingState { return .tracking }
  internal static var min: Unity_PolySpatial_Internals_ARImageTrackingState { return .none_ }
}


///  Describes the alignment mode of the line renderer.
internal enum Unity_PolySpatial_Internals_PolySpatialLineRendererAlignment: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Mode where lines face the camera.
  case view = 0
  ///  Mode where lines face the Z axis of the Transform Component.
  case transformZ = 1

  internal static var max: Unity_PolySpatial_Internals_PolySpatialLineRendererAlignment { return .transformZ }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialLineRendererAlignment { return .view }
}


///  Describes the texture mode of the line renderer.
internal enum Unity_PolySpatial_Internals_PolySpatialLineRendererTextureMode: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  Map the texture once along the entire length of the line.
  case stretch = 0
  ///  Repeat the texture along the line, based on its length in world units. To set the tiling rate, use Material.SetTextureScale.
  case tile = 1
  ///  Map the texture once along the entire length of the line, assuming all vertices are evenly spaced.
  case distributePerSegment = 2
  ///  Repeat the texture along the line, repeating at a rate of once per line segment. To adjust the tiling rate, use Material.SetTextureScale.
  case repeatPerSegment = 3
  ///  Trails do not change the texture coordinates of existing points when they add or remove points.
  case static_ = 4

  internal static var max: Unity_PolySpatial_Internals_PolySpatialLineRendererTextureMode { return .static_ }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialLineRendererTextureMode { return .stretch }
}


internal enum Unity_PolySpatial_Internals_PolySpatialHostDisplayOrientation: Int32, Enum, Verifiable {
  internal typealias T = Int32
  internal static var byteSize: Int { return MemoryLayout<Int32>.size }
  internal var value: Int32 { return self.rawValue }
  ///  DO NOT USE THIS VALUE.
  ///  This is here only to facilitate direct casting to/from Unity
  ///  ScreenOrientation values.
  case invalid = 0
  ///  The screen is in portrait orientation.
  case portrait = 1
  ///  The screen is in portrait upside-down orientation.
  case portraitUpsideDown = 2
  ///  The screen is in landscape left orientation.
  case landscapeLeft = 3
  ///  The screen is in landscape right orientation.
  case landscapeRight = 4
  ///  Screen will auto rotate based on the device's orientation.
  case autoRotation = 5

  internal static var max: Unity_PolySpatial_Internals_PolySpatialHostDisplayOrientation { return .autoRotation }
  internal static var min: Unity_PolySpatial_Internals_PolySpatialHostDisplayOrientation { return .invalid }
}


internal struct UnityEngine_Vector2: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _x: Float32
  private var _y: Float32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _x = _accessor.readBuffer(of: Float32.self, at: 0)
    _y = _accessor.readBuffer(of: Float32.self, at: 4)
  }

  internal init(x: Float32, y: Float32) {
    _x = x
    _y = y
  }

  internal init() {
    _x = 0.0
    _y = 0.0
  }

  internal var x: Float32 { _x }
  internal var y: Float32 { _y }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: UnityEngine_Vector2.self)
  }
}

internal struct UnityEngine_Vector2_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var x: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  internal var y: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
}

internal struct UnityEngine_Vector3: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _x: Float32
  private var _y: Float32
  private var _z: Float32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _x = _accessor.readBuffer(of: Float32.self, at: 0)
    _y = _accessor.readBuffer(of: Float32.self, at: 4)
    _z = _accessor.readBuffer(of: Float32.self, at: 8)
  }

  internal init(x: Float32, y: Float32, z: Float32) {
    _x = x
    _y = y
    _z = z
  }

  internal init() {
    _x = 0.0
    _y = 0.0
    _z = 0.0
  }

  internal var x: Float32 { _x }
  internal var y: Float32 { _y }
  internal var z: Float32 { _z }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: UnityEngine_Vector3.self)
  }
}

internal struct UnityEngine_Vector3_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var x: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  internal var y: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
  internal var z: Float32 { return _accessor.readBuffer(of: Float32.self, at: 8) }
}

internal struct UnityEngine_Vector4: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _x: Float32
  private var _y: Float32
  private var _z: Float32
  private var _w: Float32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _x = _accessor.readBuffer(of: Float32.self, at: 0)
    _y = _accessor.readBuffer(of: Float32.self, at: 4)
    _z = _accessor.readBuffer(of: Float32.self, at: 8)
    _w = _accessor.readBuffer(of: Float32.self, at: 12)
  }

  internal init(x: Float32, y: Float32, z: Float32, w: Float32) {
    _x = x
    _y = y
    _z = z
    _w = w
  }

  internal init() {
    _x = 0.0
    _y = 0.0
    _z = 0.0
    _w = 0.0
  }

  internal var x: Float32 { _x }
  internal var y: Float32 { _y }
  internal var z: Float32 { _z }
  internal var w: Float32 { _w }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: UnityEngine_Vector4.self)
  }
}

internal struct UnityEngine_Vector4_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var x: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  internal var y: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
  internal var z: Float32 { return _accessor.readBuffer(of: Float32.self, at: 8) }
  internal var w: Float32 { return _accessor.readBuffer(of: Float32.self, at: 12) }
}

internal struct UnityEngine_Quaternion: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _x: Float32
  private var _y: Float32
  private var _z: Float32
  private var _w: Float32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _x = _accessor.readBuffer(of: Float32.self, at: 0)
    _y = _accessor.readBuffer(of: Float32.self, at: 4)
    _z = _accessor.readBuffer(of: Float32.self, at: 8)
    _w = _accessor.readBuffer(of: Float32.self, at: 12)
  }

  internal init(x: Float32, y: Float32, z: Float32, w: Float32) {
    _x = x
    _y = y
    _z = z
    _w = w
  }

  internal init() {
    _x = 0.0
    _y = 0.0
    _z = 0.0
    _w = 0.0
  }

  internal var x: Float32 { _x }
  internal var y: Float32 { _y }
  internal var z: Float32 { _z }
  internal var w: Float32 { _w }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: UnityEngine_Quaternion.self)
  }
}

internal struct UnityEngine_Quaternion_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var x: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  internal var y: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
  internal var z: Float32 { return _accessor.readBuffer(of: Float32.self, at: 8) }
  internal var w: Float32 { return _accessor.readBuffer(of: Float32.self, at: 12) }
}

internal struct UnityEngine_Color32: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _r: UInt8
  private var _g: UInt8
  private var _b: UInt8
  private var _a: UInt8

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _r = _accessor.readBuffer(of: UInt8.self, at: 0)
    _g = _accessor.readBuffer(of: UInt8.self, at: 1)
    _b = _accessor.readBuffer(of: UInt8.self, at: 2)
    _a = _accessor.readBuffer(of: UInt8.self, at: 3)
  }

  internal init(r: UInt8, g: UInt8, b: UInt8, a: UInt8) {
    _r = r
    _g = g
    _b = b
    _a = a
  }

  internal init() {
    _r = 0
    _g = 0
    _b = 0
    _a = 0
  }

  internal var r: UInt8 { _r }
  internal var g: UInt8 { _g }
  internal var b: UInt8 { _b }
  internal var a: UInt8 { _a }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: UnityEngine_Color32.self)
  }
}

internal struct UnityEngine_Color32_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var r: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 0) }
  internal var g: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 1) }
  internal var b: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 2) }
  internal var a: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 3) }
}

internal struct UnityEngine_Color: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _r: Float32
  private var _g: Float32
  private var _b: Float32
  private var _a: Float32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _r = _accessor.readBuffer(of: Float32.self, at: 0)
    _g = _accessor.readBuffer(of: Float32.self, at: 4)
    _b = _accessor.readBuffer(of: Float32.self, at: 8)
    _a = _accessor.readBuffer(of: Float32.self, at: 12)
  }

  internal init(r: Float32, g: Float32, b: Float32, a: Float32) {
    _r = r
    _g = g
    _b = b
    _a = a
  }

  internal init() {
    _r = 0.0
    _g = 0.0
    _b = 0.0
    _a = 0.0
  }

  internal var r: Float32 { _r }
  internal var g: Float32 { _g }
  internal var b: Float32 { _b }
  internal var a: Float32 { _a }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: UnityEngine_Color.self)
  }
}

internal struct UnityEngine_Color_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var r: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  internal var g: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
  internal var b: Float32 { return _accessor.readBuffer(of: Float32.self, at: 8) }
  internal var a: Float32 { return _accessor.readBuffer(of: Float32.self, at: 12) }
}

internal struct UnityEngine_Matrix4x4: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _m00: Float32
  private var _m10: Float32
  private var _m20: Float32
  private var _m30: Float32
  private var _m01: Float32
  private var _m11: Float32
  private var _m21: Float32
  private var _m31: Float32
  private var _m02: Float32
  private var _m12: Float32
  private var _m22: Float32
  private var _m32: Float32
  private var _m03: Float32
  private var _m13: Float32
  private var _m23: Float32
  private var _m33: Float32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _m00 = _accessor.readBuffer(of: Float32.self, at: 0)
    _m10 = _accessor.readBuffer(of: Float32.self, at: 4)
    _m20 = _accessor.readBuffer(of: Float32.self, at: 8)
    _m30 = _accessor.readBuffer(of: Float32.self, at: 12)
    _m01 = _accessor.readBuffer(of: Float32.self, at: 16)
    _m11 = _accessor.readBuffer(of: Float32.self, at: 20)
    _m21 = _accessor.readBuffer(of: Float32.self, at: 24)
    _m31 = _accessor.readBuffer(of: Float32.self, at: 28)
    _m02 = _accessor.readBuffer(of: Float32.self, at: 32)
    _m12 = _accessor.readBuffer(of: Float32.self, at: 36)
    _m22 = _accessor.readBuffer(of: Float32.self, at: 40)
    _m32 = _accessor.readBuffer(of: Float32.self, at: 44)
    _m03 = _accessor.readBuffer(of: Float32.self, at: 48)
    _m13 = _accessor.readBuffer(of: Float32.self, at: 52)
    _m23 = _accessor.readBuffer(of: Float32.self, at: 56)
    _m33 = _accessor.readBuffer(of: Float32.self, at: 60)
  }

  internal init(m00: Float32, m10: Float32, m20: Float32, m30: Float32, m01: Float32, m11: Float32, m21: Float32, m31: Float32, m02: Float32, m12: Float32, m22: Float32, m32: Float32, m03: Float32, m13: Float32, m23: Float32, m33: Float32) {
    _m00 = m00
    _m10 = m10
    _m20 = m20
    _m30 = m30
    _m01 = m01
    _m11 = m11
    _m21 = m21
    _m31 = m31
    _m02 = m02
    _m12 = m12
    _m22 = m22
    _m32 = m32
    _m03 = m03
    _m13 = m13
    _m23 = m23
    _m33 = m33
  }

  internal init() {
    _m00 = 0.0
    _m10 = 0.0
    _m20 = 0.0
    _m30 = 0.0
    _m01 = 0.0
    _m11 = 0.0
    _m21 = 0.0
    _m31 = 0.0
    _m02 = 0.0
    _m12 = 0.0
    _m22 = 0.0
    _m32 = 0.0
    _m03 = 0.0
    _m13 = 0.0
    _m23 = 0.0
    _m33 = 0.0
  }

  internal var m00: Float32 { _m00 }
  internal var m10: Float32 { _m10 }
  internal var m20: Float32 { _m20 }
  internal var m30: Float32 { _m30 }
  internal var m01: Float32 { _m01 }
  internal var m11: Float32 { _m11 }
  internal var m21: Float32 { _m21 }
  internal var m31: Float32 { _m31 }
  internal var m02: Float32 { _m02 }
  internal var m12: Float32 { _m12 }
  internal var m22: Float32 { _m22 }
  internal var m32: Float32 { _m32 }
  internal var m03: Float32 { _m03 }
  internal var m13: Float32 { _m13 }
  internal var m23: Float32 { _m23 }
  internal var m33: Float32 { _m33 }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: UnityEngine_Matrix4x4.self)
  }
}

internal struct UnityEngine_Matrix4x4_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var m00: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  internal var m10: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
  internal var m20: Float32 { return _accessor.readBuffer(of: Float32.self, at: 8) }
  internal var m30: Float32 { return _accessor.readBuffer(of: Float32.self, at: 12) }
  internal var m01: Float32 { return _accessor.readBuffer(of: Float32.self, at: 16) }
  internal var m11: Float32 { return _accessor.readBuffer(of: Float32.self, at: 20) }
  internal var m21: Float32 { return _accessor.readBuffer(of: Float32.self, at: 24) }
  internal var m31: Float32 { return _accessor.readBuffer(of: Float32.self, at: 28) }
  internal var m02: Float32 { return _accessor.readBuffer(of: Float32.self, at: 32) }
  internal var m12: Float32 { return _accessor.readBuffer(of: Float32.self, at: 36) }
  internal var m22: Float32 { return _accessor.readBuffer(of: Float32.self, at: 40) }
  internal var m32: Float32 { return _accessor.readBuffer(of: Float32.self, at: 44) }
  internal var m03: Float32 { return _accessor.readBuffer(of: Float32.self, at: 48) }
  internal var m13: Float32 { return _accessor.readBuffer(of: Float32.self, at: 52) }
  internal var m23: Float32 { return _accessor.readBuffer(of: Float32.self, at: 56) }
  internal var m33: Float32 { return _accessor.readBuffer(of: Float32.self, at: 60) }
}

internal struct UnityEngine_Pose: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _position: UnityEngine_Vector3
  private var _rotation: UnityEngine_Quaternion

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _position = UnityEngine_Vector3(_accessor.bb, o: _accessor.postion + 0)
    _rotation = UnityEngine_Quaternion(_accessor.bb, o: _accessor.postion + 12)
  }

  internal init(position: UnityEngine_Vector3, rotation: UnityEngine_Quaternion) {
    _position = position
    _rotation = rotation
  }

  internal init() {
    _position = UnityEngine_Vector3()
    _rotation = UnityEngine_Quaternion()
  }

  internal var position: UnityEngine_Vector3 { _position }
  internal var rotation: UnityEngine_Quaternion { _rotation }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: UnityEngine_Pose.self)
  }
}

internal struct UnityEngine_Pose_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var position: UnityEngine_Vector3_Mutable { return UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var rotation: UnityEngine_Quaternion_Mutable { return UnityEngine_Quaternion_Mutable(_accessor.bb, o: _accessor.postion + 12) }
}

internal struct UnityEngine_Rect: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _x: Float32
  private var _y: Float32
  private var _width: Float32
  private var _height: Float32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _x = _accessor.readBuffer(of: Float32.self, at: 0)
    _y = _accessor.readBuffer(of: Float32.self, at: 4)
    _width = _accessor.readBuffer(of: Float32.self, at: 8)
    _height = _accessor.readBuffer(of: Float32.self, at: 12)
  }

  internal init(x: Float32, y: Float32, width: Float32, height: Float32) {
    _x = x
    _y = y
    _width = width
    _height = height
  }

  internal init() {
    _x = 0.0
    _y = 0.0
    _width = 0.0
    _height = 0.0
  }

  internal var x: Float32 { _x }
  internal var y: Float32 { _y }
  internal var width: Float32 { _width }
  internal var height: Float32 { _height }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: UnityEngine_Rect.self)
  }
}

internal struct UnityEngine_Rect_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var x: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  internal var y: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
  internal var width: Float32 { return _accessor.readBuffer(of: Float32.self, at: 8) }
  internal var height: Float32 { return _accessor.readBuffer(of: Float32.self, at: 12) }
}

internal struct UnityEngine_Bounds: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _center: UnityEngine_Vector3
  private var _extents: UnityEngine_Vector3

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _center = UnityEngine_Vector3(_accessor.bb, o: _accessor.postion + 0)
    _extents = UnityEngine_Vector3(_accessor.bb, o: _accessor.postion + 12)
  }

  internal init(center: UnityEngine_Vector3, extents: UnityEngine_Vector3) {
    _center = center
    _extents = extents
  }

  internal init() {
    _center = UnityEngine_Vector3()
    _extents = UnityEngine_Vector3()
  }

  internal var center: UnityEngine_Vector3 { _center }
  internal var extents: UnityEngine_Vector3 { _extents }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: UnityEngine_Bounds.self)
  }
}

internal struct UnityEngine_Bounds_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var center: UnityEngine_Vector3_Mutable { return UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var extents: UnityEngine_Vector3_Mutable { return UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.postion + 12) }
}

///  Type used to identify hosts (both local and remote)
internal struct Unity_PolySpatial_Internals_PolySpatialHostID: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  For identifying commands and instances that originated outside of the local simulation.
  /// 
  ///  For outbound connections (such as a sim connecting to a host),
  ///  the ephemeral port value of the connection can be used since it will be unique to the process.
  /// 
  ///  For inbound connections (such as a host accepting a connection),
  ///  an alternative method of generating a unique connectionId must be used,
  ///  since each connection will use the same local port value.
  /// 
  ///  A connectionId of 0 is reserved for the local simulation.
  private var _connectionId: UInt16
  ///  Currently unused, but there may be future cases where we need to differentiate
  ///  instances from the same host.
  private var _reserved: UInt16

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _connectionId = _accessor.readBuffer(of: UInt16.self, at: 0)
    _reserved = _accessor.readBuffer(of: UInt16.self, at: 2)
  }

  internal init(connectionId: UInt16, reserved: UInt16) {
    _connectionId = connectionId
    _reserved = reserved
  }

  internal init() {
    _connectionId = 0
    _reserved = 0
  }

  ///  For identifying commands and instances that originated outside of the local simulation.
  /// 
  ///  For outbound connections (such as a sim connecting to a host),
  ///  the ephemeral port value of the connection can be used since it will be unique to the process.
  /// 
  ///  For inbound connections (such as a host accepting a connection),
  ///  an alternative method of generating a unique connectionId must be used,
  ///  since each connection will use the same local port value.
  /// 
  ///  A connectionId of 0 is reserved for the local simulation.
  internal var connectionId: UInt16 { _connectionId }
  ///  Currently unused, but there may be future cases where we need to differentiate
  ///  instances from the same host.
  internal var reserved: UInt16 { _reserved }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialHostID.self)
  }
}

///  Type used to identify hosts (both local and remote)
internal struct Unity_PolySpatial_Internals_PolySpatialHostID_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var connectionId: UInt16 { return _accessor.readBuffer(of: UInt16.self, at: 0) }
  internal var reserved: UInt16 { return _accessor.readBuffer(of: UInt16.self, at: 2) }
}

///  Type used to identify instances of Unity objects within PolySpatial
internal struct Unity_PolySpatial_Internals_PolySpatialInstanceID: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  Unique ID, usually the Unity Instance ID.
  ///  Unity Instance IDs are currently 32-bit but possibly 64-bit in the future.
  private var _id: Int64
  ///  For identifying the host of the simulation that this instance was created by.
  ///  ConnectionID value of 0 indicates that this instance was created locally.
  private var _hostId: Unity_PolySpatial_Internals_PolySpatialHostID
  ///  A backend may choose to support multiple volumes by instancing an entity into
  ///  each volume. In that case the hostVolumeIndex allows each instance to have a unique
  ///  PSIID. It also allows for looking up the volume of instance.
  ///  NOTE: Not intended to be used by simulations. Backends (or backend command handlers)
  ///  will manage the creation of volume indices and remap PSIIDs accordingly.
  private var _hostVolumeIndex: UInt8
  ///  Reserved for future use.
  private var __Padding0: UInt8
  private var __Padding1: UInt16

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _id = _accessor.readBuffer(of: Int64.self, at: 0)
    _hostId = Unity_PolySpatial_Internals_PolySpatialHostID(_accessor.bb, o: _accessor.postion + 8)
    _hostVolumeIndex = _accessor.readBuffer(of: UInt8.self, at: 12)
    __Padding0 = _accessor.readBuffer(of: UInt8.self, at: 13)
    __Padding1 = _accessor.readBuffer(of: UInt16.self, at: 14)
  }

  internal init(id: Int64, hostId: Unity_PolySpatial_Internals_PolySpatialHostID, hostVolumeIndex: UInt8, _Padding0: UInt8, _Padding1: UInt16) {
    _id = id
    _hostId = hostId
    _hostVolumeIndex = hostVolumeIndex
    __Padding0 = _Padding0
    __Padding1 = _Padding1
  }

  internal init() {
    _id = 0
    _hostId = Unity_PolySpatial_Internals_PolySpatialHostID()
    _hostVolumeIndex = 0
    __Padding0 = 0
    __Padding1 = 0
  }

  ///  Unique ID, usually the Unity Instance ID.
  ///  Unity Instance IDs are currently 32-bit but possibly 64-bit in the future.
  internal var id: Int64 { _id }
  ///  For identifying the host of the simulation that this instance was created by.
  ///  ConnectionID value of 0 indicates that this instance was created locally.
  internal var hostId: Unity_PolySpatial_Internals_PolySpatialHostID { _hostId }
  ///  A backend may choose to support multiple volumes by instancing an entity into
  ///  each volume. In that case the hostVolumeIndex allows each instance to have a unique
  ///  PSIID. It also allows for looking up the volume of instance.
  ///  NOTE: Not intended to be used by simulations. Backends (or backend command handlers)
  ///  will manage the creation of volume indices and remap PSIIDs accordingly.
  internal var hostVolumeIndex: UInt8 { _hostVolumeIndex }
  ///  Reserved for future use.
  internal var _Padding0: UInt8 { __Padding0 }
  internal var _Padding1: UInt16 { __Padding1 }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialInstanceID.self)
  }
}

///  Type used to identify instances of Unity objects within PolySpatial
internal struct Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var id: Int64 { return _accessor.readBuffer(of: Int64.self, at: 0) }
  internal var hostId: Unity_PolySpatial_Internals_PolySpatialHostID_Mutable { return Unity_PolySpatial_Internals_PolySpatialHostID_Mutable(_accessor.bb, o: _accessor.postion + 8) }
  internal var hostVolumeIndex: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 12) }
  internal var _Padding0: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 13) }
  internal var _Padding1: UInt16 { return _accessor.readBuffer(of: UInt16.self, at: 14) }
}

///  The Header for a PolySpatialInstanceIDList, which is a list of Instance IDs that share the same host and volumeIndex.
internal struct Unity_PolySpatial_Internals_PolySpatialInstanceIDListHeader: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _hostId: Unity_PolySpatial_Internals_PolySpatialHostID
  private var _hostVolumeIndex: UInt8
  ///  Reserved for future use.
  private var __Padding0: UInt8
  private var __Padding1: UInt16

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _hostId = Unity_PolySpatial_Internals_PolySpatialHostID(_accessor.bb, o: _accessor.postion + 0)
    _hostVolumeIndex = _accessor.readBuffer(of: UInt8.self, at: 4)
    __Padding0 = _accessor.readBuffer(of: UInt8.self, at: 5)
    __Padding1 = _accessor.readBuffer(of: UInt16.self, at: 6)
  }

  internal init(hostId: Unity_PolySpatial_Internals_PolySpatialHostID, hostVolumeIndex: UInt8, _Padding0: UInt8, _Padding1: UInt16) {
    _hostId = hostId
    _hostVolumeIndex = hostVolumeIndex
    __Padding0 = _Padding0
    __Padding1 = _Padding1
  }

  internal init() {
    _hostId = Unity_PolySpatial_Internals_PolySpatialHostID()
    _hostVolumeIndex = 0
    __Padding0 = 0
    __Padding1 = 0
  }

  internal var hostId: Unity_PolySpatial_Internals_PolySpatialHostID { _hostId }
  internal var hostVolumeIndex: UInt8 { _hostVolumeIndex }
  ///  Reserved for future use.
  internal var _Padding0: UInt8 { __Padding0 }
  internal var _Padding1: UInt16 { __Padding1 }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialInstanceIDListHeader.self)
  }
}

///  The Header for a PolySpatialInstanceIDList, which is a list of Instance IDs that share the same host and volumeIndex.
internal struct Unity_PolySpatial_Internals_PolySpatialInstanceIDListHeader_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var hostId: Unity_PolySpatial_Internals_PolySpatialHostID_Mutable { return Unity_PolySpatial_Internals_PolySpatialHostID_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var hostVolumeIndex: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 4) }
  internal var _Padding0: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 5) }
  internal var _Padding1: UInt16 { return _accessor.readBuffer(of: UInt16.self, at: 6) }
}

///  Identifies a component associated with an entity.  This contains the Unity instance ID of the
///  component, but not the extra data contained in PolySpatialInstanceID (because the host/volume
///  can be determined from the owning entity).
internal struct Unity_PolySpatial_Internals_PolySpatialComponentID: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _id: Int64

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _id = _accessor.readBuffer(of: Int64.self, at: 0)
  }

  internal init(id: Int64) {
    _id = id
  }

  internal init() {
    _id = 0
  }

  internal var id: Int64 { _id }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialComponentID.self)
  }
}

///  Identifies a component associated with an entity.  This contains the Unity instance ID of the
///  component, but not the extra data contained in PolySpatialInstanceID (because the host/volume
///  can be determined from the owning entity).
internal struct Unity_PolySpatial_Internals_PolySpatialComponentID_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var id: Int64 { return _accessor.readBuffer(of: Int64.self, at: 0) }
}

///  This type denotes a unique, 128 bit identifier for an asset that is being
///  tracked within the PolySpatial system.
internal struct Unity_PolySpatial_Internals_PolySpatialAssetID: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  First 4 bytes of ID
  private var _id0: Int32
  ///  Second 4 bytes of ID
  private var _id1: Int32
  ///  Third 4 bytes of ID
  private var _id2: Int32
  ///  Fourth 4 bytes of ID
  private var _id3: Int32
  ///  localFileId when available, otherwise 0
  private var _localFileId: Int64

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _id0 = _accessor.readBuffer(of: Int32.self, at: 0)
    _id1 = _accessor.readBuffer(of: Int32.self, at: 4)
    _id2 = _accessor.readBuffer(of: Int32.self, at: 8)
    _id3 = _accessor.readBuffer(of: Int32.self, at: 12)
    _localFileId = _accessor.readBuffer(of: Int64.self, at: 16)
  }

  internal init(id0: Int32, id1: Int32, id2: Int32, id3: Int32, localFileId: Int64) {
    _id0 = id0
    _id1 = id1
    _id2 = id2
    _id3 = id3
    _localFileId = localFileId
  }

  internal init() {
    _id0 = 0
    _id1 = 0
    _id2 = 0
    _id3 = 0
    _localFileId = 0
  }

  ///  First 4 bytes of ID
  internal var id0: Int32 { _id0 }
  ///  Second 4 bytes of ID
  internal var id1: Int32 { _id1 }
  ///  Third 4 bytes of ID
  internal var id2: Int32 { _id2 }
  ///  Fourth 4 bytes of ID
  internal var id3: Int32 { _id3 }
  ///  localFileId when available, otherwise 0
  internal var localFileId: Int64 { _localFileId }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialAssetID.self)
  }
}

///  This type denotes a unique, 128 bit identifier for an asset that is being
///  tracked within the PolySpatial system.
internal struct Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var id0: Int32 { return _accessor.readBuffer(of: Int32.self, at: 0) }
  internal var id1: Int32 { return _accessor.readBuffer(of: Int32.self, at: 4) }
  internal var id2: Int32 { return _accessor.readBuffer(of: Int32.self, at: 8) }
  internal var id3: Int32 { return _accessor.readBuffer(of: Int32.self, at: 12) }
  internal var localFileId: Int64 { return _accessor.readBuffer(of: Int64.self, at: 16) }
}

///  Defines a game object to be backed by PolySpatial
internal struct Unity_PolySpatial_Internals_PolySpatialGameObjectData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The layer for this GameObject
  private var _layer: Int32
  ///  Is this GameObject active (matches GameObject.selfActive)?
  private var _active: Bool
  ///  required for C# size to match swift size
  private var _padding0: UInt8
  private var _padding1: UInt16

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _layer = _accessor.readBuffer(of: Int32.self, at: 0)
    _active = _accessor.readBuffer(of: Bool.self, at: 4)
    _padding0 = _accessor.readBuffer(of: UInt8.self, at: 5)
    _padding1 = _accessor.readBuffer(of: UInt16.self, at: 6)
  }

  internal init(layer: Int32, active: Bool, padding0: UInt8, padding1: UInt16) {
    _layer = layer
    _active = active
    _padding0 = padding0
    _padding1 = padding1
  }

  internal init() {
    _layer = 0
    _active = false
    _padding0 = 0
    _padding1 = 0
  }

  ///  The layer for this GameObject
  internal var layer: Int32 { _layer }
  ///  Is this GameObject active (matches GameObject.selfActive)?
  internal var active: Bool { _active }
  ///  required for C# size to match swift size
  internal var padding0: UInt8 { _padding0 }
  internal var padding1: UInt16 { _padding1 }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialGameObjectData.self)
  }
}

///  Defines a game object to be backed by PolySpatial
internal struct Unity_PolySpatial_Internals_PolySpatialGameObjectData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var layer: Int32 { return _accessor.readBuffer(of: Int32.self, at: 0) }
  internal var active: Bool { return _accessor.readBuffer(of: Bool.self, at: 4) }
  internal var padding0: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 5) }
  internal var padding1: UInt16 { return _accessor.readBuffer(of: UInt16.self, at: 6) }
}

///  Struct containing the data common to any entity change
internal struct Unity_PolySpatial_Internals_PolySpatialChangeListEntityData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The object's polyspatial instance id.
  private var _instanceId: Unity_PolySpatial_Internals_PolySpatialInstanceID
  ///  Current tracking flags signifying the status of the object.
  private var _trackingFlags: Int32
  ///  Padding is needed to get C# and Swift structs to match in size
  private var _padding: UInt32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _instanceId = Unity_PolySpatial_Internals_PolySpatialInstanceID(_accessor.bb, o: _accessor.postion + 0)
    _trackingFlags = _accessor.readBuffer(of: Int32.self, at: 16)
    _padding = _accessor.readBuffer(of: UInt32.self, at: 20)
  }

  internal init(instanceId: Unity_PolySpatial_Internals_PolySpatialInstanceID, trackingFlags: Int32, padding: UInt32) {
    _instanceId = instanceId
    _trackingFlags = trackingFlags
    _padding = padding
  }

  internal init() {
    _instanceId = Unity_PolySpatial_Internals_PolySpatialInstanceID()
    _trackingFlags = 0
    _padding = 0
  }

  ///  The object's polyspatial instance id.
  internal var instanceId: Unity_PolySpatial_Internals_PolySpatialInstanceID { _instanceId }
  ///  Current tracking flags signifying the status of the object.
  internal var trackingFlags: Int32 { _trackingFlags }
  ///  Padding is needed to get C# and Swift structs to match in size
  internal var padding: UInt32 { _padding }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialChangeListEntityData.self)
  }
}

///  Struct containing the data common to any entity change
internal struct Unity_PolySpatial_Internals_PolySpatialChangeListEntityData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var instanceId: Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable { return Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var trackingFlags: Int32 { return _accessor.readBuffer(of: Int32.self, at: 16) }
  internal var padding: UInt32 { return _accessor.readBuffer(of: UInt32.self, at: 20) }
}

///  The Key used for caching asset data. The HostAssetCacheHandler contains the actual caches, while the
///  AppAssetCacheHandler has a synchronized copy of the keys.
internal struct Unity_PolySpatial_Internals_PolySpatialAssetCacheKey: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _assetId: Unity_PolySpatial_Internals_PolySpatialAssetID
  private var _dataHash: UInt64

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _assetId = Unity_PolySpatial_Internals_PolySpatialAssetID(_accessor.bb, o: _accessor.postion + 0)
    _dataHash = _accessor.readBuffer(of: UInt64.self, at: 24)
  }

  internal init(assetId: Unity_PolySpatial_Internals_PolySpatialAssetID, dataHash: UInt64) {
    _assetId = assetId
    _dataHash = dataHash
  }

  internal init() {
    _assetId = Unity_PolySpatial_Internals_PolySpatialAssetID()
    _dataHash = 0
  }

  internal var assetId: Unity_PolySpatial_Internals_PolySpatialAssetID { _assetId }
  internal var dataHash: UInt64 { _dataHash }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialAssetCacheKey.self)
  }
}

///  The Key used for caching asset data. The HostAssetCacheHandler contains the actual caches, while the
///  AppAssetCacheHandler has a synchronized copy of the keys.
internal struct Unity_PolySpatial_Internals_PolySpatialAssetCacheKey_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var assetId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable { return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var dataHash: UInt64 { return _accessor.readBuffer(of: UInt64.self, at: 24) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialAssetCommandMetadata: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  64-bit hash of the fields of an AssetData table (before serialization).
  private var _dataHash: UInt64
  ///  Status of the data in the corresponding asset command
  private var _flags: UInt8
  private var __Padding0: UInt8
  private var __Padding1: UInt16
  private var __Padding2: UInt32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _dataHash = _accessor.readBuffer(of: UInt64.self, at: 0)
    _flags = _accessor.readBuffer(of: UInt8.self, at: 8)
    __Padding0 = _accessor.readBuffer(of: UInt8.self, at: 9)
    __Padding1 = _accessor.readBuffer(of: UInt16.self, at: 10)
    __Padding2 = _accessor.readBuffer(of: UInt32.self, at: 12)
  }

  internal init(dataHash: UInt64, flags: Unity_PolySpatial_Internals_PolySpatialAssetCommandMetadataFlags, _Padding0: UInt8, _Padding1: UInt16, _Padding2: UInt32) {
    _dataHash = dataHash
    _flags = flags.value
    __Padding0 = _Padding0
    __Padding1 = _Padding1
    __Padding2 = _Padding2
  }

  internal init() {
    _dataHash = 0
    _flags = 0
    __Padding0 = 0
    __Padding1 = 0
    __Padding2 = 0
  }

  ///  64-bit hash of the fields of an AssetData table (before serialization).
  internal var dataHash: UInt64 { _dataHash }
  ///  Status of the data in the corresponding asset command
  internal var flags: Unity_PolySpatial_Internals_PolySpatialAssetCommandMetadataFlags { Unity_PolySpatial_Internals_PolySpatialAssetCommandMetadataFlags(rawValue: _flags) }
  internal var _Padding0: UInt8 { __Padding0 }
  internal var _Padding1: UInt16 { __Padding1 }
  internal var _Padding2: UInt32 { __Padding2 }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialAssetCommandMetadata.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialAssetCommandMetadata_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var dataHash: UInt64 { return _accessor.readBuffer(of: UInt64.self, at: 0) }
  internal var flags: Unity_PolySpatial_Internals_PolySpatialAssetCommandMetadataFlags { return Unity_PolySpatial_Internals_PolySpatialAssetCommandMetadataFlags(rawValue: _accessor.readBuffer(of: UInt8.self, at: 8))  }
  internal var _Padding0: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 9) }
  internal var _Padding1: UInt16 { return _accessor.readBuffer(of: UInt16.self, at: 10) }
  internal var _Padding2: UInt32 { return _accessor.readBuffer(of: UInt32.self, at: 12) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialDestroyComponentData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _instanceId: Unity_PolySpatial_Internals_PolySpatialInstanceID
  private var _componentId: Unity_PolySpatial_Internals_PolySpatialComponentID

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _instanceId = Unity_PolySpatial_Internals_PolySpatialInstanceID(_accessor.bb, o: _accessor.postion + 0)
    _componentId = Unity_PolySpatial_Internals_PolySpatialComponentID(_accessor.bb, o: _accessor.postion + 16)
  }

  internal init(instanceId: Unity_PolySpatial_Internals_PolySpatialInstanceID, componentId: Unity_PolySpatial_Internals_PolySpatialComponentID) {
    _instanceId = instanceId
    _componentId = componentId
  }

  internal init() {
    _instanceId = Unity_PolySpatial_Internals_PolySpatialInstanceID()
    _componentId = Unity_PolySpatial_Internals_PolySpatialComponentID()
  }

  internal var instanceId: Unity_PolySpatial_Internals_PolySpatialInstanceID { _instanceId }
  internal var componentId: Unity_PolySpatial_Internals_PolySpatialComponentID { _componentId }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialDestroyComponentData.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialDestroyComponentData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var instanceId: Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable { return Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var componentId: Unity_PolySpatial_Internals_PolySpatialComponentID_Mutable { return Unity_PolySpatial_Internals_PolySpatialComponentID_Mutable(_accessor.bb, o: _accessor.postion + 16) }
}

///  Struct to represent an animation curve key.
internal struct Unity_PolySpatial_Internals_PolySpatialAnimationCurveKey: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The incoming tangent for this key. The incoming tangent affects the slope of the curve from the previous key to this key.
  private var _inTangent: Float32
  ///  The incoming weight for this key. The incoming weight affects the slope of the curve from the previous key to this key.
  private var _inWeight: Float32
  ///  The outgoing tangent for this key. The outgoing tangent affects the slope of the curve from this key to the next key.
  private var _outTangent: Float32
  ///  The outgoing weight for this key. The outgoing weight affects the slope of the curve from this key to the next key.
  private var _outWeight: Float32
  ///  The value of the curve at keyframe.
  private var _value: Float32
  ///  The time of the keyframe.
  private var _time: Float32
  ///  The weighted mode for the keyframe.
  private var _weightedMode: Int32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _inTangent = _accessor.readBuffer(of: Float32.self, at: 0)
    _inWeight = _accessor.readBuffer(of: Float32.self, at: 4)
    _outTangent = _accessor.readBuffer(of: Float32.self, at: 8)
    _outWeight = _accessor.readBuffer(of: Float32.self, at: 12)
    _value = _accessor.readBuffer(of: Float32.self, at: 16)
    _time = _accessor.readBuffer(of: Float32.self, at: 20)
    _weightedMode = _accessor.readBuffer(of: Int32.self, at: 24)
  }

  internal init(inTangent: Float32, inWeight: Float32, outTangent: Float32, outWeight: Float32, value: Float32, time: Float32, weightedMode: Unity_PolySpatial_Internals_PolySpatialAnimationCurveWeightedMode) {
    _inTangent = inTangent
    _inWeight = inWeight
    _outTangent = outTangent
    _outWeight = outWeight
    _value = value
    _time = time
    _weightedMode = weightedMode.value
  }

  internal init() {
    _inTangent = 0.0
    _inWeight = 0.0
    _outTangent = 0.0
    _outWeight = 0.0
    _value = 0.0
    _time = 0.0
    _weightedMode = 0
  }

  ///  The incoming tangent for this key. The incoming tangent affects the slope of the curve from the previous key to this key.
  internal var inTangent: Float32 { _inTangent }
  ///  The incoming weight for this key. The incoming weight affects the slope of the curve from the previous key to this key.
  internal var inWeight: Float32 { _inWeight }
  ///  The outgoing tangent for this key. The outgoing tangent affects the slope of the curve from this key to the next key.
  internal var outTangent: Float32 { _outTangent }
  ///  The outgoing weight for this key. The outgoing weight affects the slope of the curve from this key to the next key.
  internal var outWeight: Float32 { _outWeight }
  ///  The value of the curve at keyframe.
  internal var value: Float32 { _value }
  ///  The time of the keyframe.
  internal var time: Float32 { _time }
  ///  The weighted mode for the keyframe.
  internal var weightedMode: Unity_PolySpatial_Internals_PolySpatialAnimationCurveWeightedMode { Unity_PolySpatial_Internals_PolySpatialAnimationCurveWeightedMode(rawValue: _weightedMode)! }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialAnimationCurveKey.self)
  }
}

///  Struct to represent an animation curve key.
internal struct Unity_PolySpatial_Internals_PolySpatialAnimationCurveKey_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var inTangent: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  internal var inWeight: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
  internal var outTangent: Float32 { return _accessor.readBuffer(of: Float32.self, at: 8) }
  internal var outWeight: Float32 { return _accessor.readBuffer(of: Float32.self, at: 12) }
  internal var value: Float32 { return _accessor.readBuffer(of: Float32.self, at: 16) }
  internal var time: Float32 { return _accessor.readBuffer(of: Float32.self, at: 20) }
  internal var weightedMode: Unity_PolySpatial_Internals_PolySpatialAnimationCurveWeightedMode { return Unity_PolySpatial_Internals_PolySpatialAnimationCurveWeightedMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 24)) ?? .none_ }
}

///  Struct to describe an alpha key for a gradient.
internal struct Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The alpha for the gradient key.
  private var _alpha: Float32
  ///  The time in which the alpha value occurs in the gradient.
  private var _time: Float32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _alpha = _accessor.readBuffer(of: Float32.self, at: 0)
    _time = _accessor.readBuffer(of: Float32.self, at: 4)
  }

  internal init(alpha: Float32, time: Float32) {
    _alpha = alpha
    _time = time
  }

  internal init() {
    _alpha = 0.0
    _time = 0.0
  }

  ///  The alpha for the gradient key.
  internal var alpha: Float32 { _alpha }
  ///  The time in which the alpha value occurs in the gradient.
  internal var time: Float32 { _time }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey.self)
  }
}

///  Struct to describe an alpha key for a gradient.
internal struct Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var alpha: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  internal var time: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
}

///  Struct to describe a color key for a gradient.
internal struct Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The color for the gradient key.
  private var _color: UnityEngine_Color32
  ///  The time in which the color occurs in the gradient.
  private var _time: Float32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _color = UnityEngine_Color32(_accessor.bb, o: _accessor.postion + 0)
    _time = _accessor.readBuffer(of: Float32.self, at: 4)
  }

  internal init(color: UnityEngine_Color32, time: Float32) {
    _color = color
    _time = time
  }

  internal init() {
    _color = UnityEngine_Color32()
    _time = 0.0
  }

  ///  The color for the gradient key.
  internal var color: UnityEngine_Color32 { _color }
  ///  The time in which the color occurs in the gradient.
  internal var time: Float32 { _time }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey.self)
  }
}

///  Struct to describe a color key for a gradient.
internal struct Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var color: UnityEngine_Color32_Mutable { return UnityEngine_Color32_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var time: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
}

///  Struct for syncing time between host and app.
internal struct Unity_PolySpatial_Internals_PolySpatialPingData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  For time syncing purposes - the timestamp of the host.
  private var _hostSecondsSinceStartup: Double
  ///  For time syncing purposes - timestamp of the app.
  private var _simSecondsSinceStartup: Double

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _hostSecondsSinceStartup = _accessor.readBuffer(of: Double.self, at: 0)
    _simSecondsSinceStartup = _accessor.readBuffer(of: Double.self, at: 8)
  }

  internal init(hostSecondsSinceStartup: Double, simSecondsSinceStartup: Double) {
    _hostSecondsSinceStartup = hostSecondsSinceStartup
    _simSecondsSinceStartup = simSecondsSinceStartup
  }

  internal init() {
    _hostSecondsSinceStartup = 0.0
    _simSecondsSinceStartup = 0.0
  }

  ///  For time syncing purposes - the timestamp of the host.
  internal var hostSecondsSinceStartup: Double { _hostSecondsSinceStartup }
  ///  For time syncing purposes - timestamp of the app.
  internal var simSecondsSinceStartup: Double { _simSecondsSinceStartup }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialPingData.self)
  }
}

///  Struct for syncing time between host and app.
internal struct Unity_PolySpatial_Internals_PolySpatialPingData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var hostSecondsSinceStartup: Double { return _accessor.readBuffer(of: Double.self, at: 0) }
  internal var simSecondsSinceStartup: Double { return _accessor.readBuffer(of: Double.self, at: 8) }
}

///  Struct containing the data common start of frame data
internal struct Unity_PolySpatial_Internals_PolySpatialFrameData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The index of the current frame
  private var _frameNumber: Int32
  private let padding0__: UInt32 = 0
  ///  Wall clock time in seconds at which polyspatial started processing the frame
  private var _frameStartTime: Double
  ///  Wall clock time in seconds at which this event was created and sent
  private var _eventTime: Double
  ///  The simulation frame's deltaTime (can be variable)
  private var _deltaTime: Float32
  ///  A hint to the host that more frames will be sent as part of the current batch.  The host can use this
  ///  information to delay expensive processing until all information is received.
  private var _morePendingFramesBatched: Bool
  ///  required for C# size to match swift size
  ///  TODO: re-arrange members to avoid need for this padding.
  private var _padding0: Int8
  private var _padding1: Int8
  private var _padding2: Int8

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _frameNumber = _accessor.readBuffer(of: Int32.self, at: 0)
    _frameStartTime = _accessor.readBuffer(of: Double.self, at: 8)
    _eventTime = _accessor.readBuffer(of: Double.self, at: 16)
    _deltaTime = _accessor.readBuffer(of: Float32.self, at: 24)
    _morePendingFramesBatched = _accessor.readBuffer(of: Bool.self, at: 28)
    _padding0 = _accessor.readBuffer(of: Int8.self, at: 29)
    _padding1 = _accessor.readBuffer(of: Int8.self, at: 30)
    _padding2 = _accessor.readBuffer(of: Int8.self, at: 31)
  }

  internal init(frameNumber: Int32, frameStartTime: Double, eventTime: Double, deltaTime: Float32, morePendingFramesBatched: Bool, padding0: Int8, padding1: Int8, padding2: Int8) {
    _frameNumber = frameNumber
    _frameStartTime = frameStartTime
    _eventTime = eventTime
    _deltaTime = deltaTime
    _morePendingFramesBatched = morePendingFramesBatched
    _padding0 = padding0
    _padding1 = padding1
    _padding2 = padding2
  }

  internal init() {
    _frameNumber = 0
    _frameStartTime = 0.0
    _eventTime = 0.0
    _deltaTime = 0.0
    _morePendingFramesBatched = false
    _padding0 = 0
    _padding1 = 0
    _padding2 = 0
  }

  ///  The index of the current frame
  internal var frameNumber: Int32 { _frameNumber }
  ///  Wall clock time in seconds at which polyspatial started processing the frame
  internal var frameStartTime: Double { _frameStartTime }
  ///  Wall clock time in seconds at which this event was created and sent
  internal var eventTime: Double { _eventTime }
  ///  The simulation frame's deltaTime (can be variable)
  internal var deltaTime: Float32 { _deltaTime }
  ///  A hint to the host that more frames will be sent as part of the current batch.  The host can use this
  ///  information to delay expensive processing until all information is received.
  internal var morePendingFramesBatched: Bool { _morePendingFramesBatched }
  ///  required for C# size to match swift size
  ///  TODO: re-arrange members to avoid need for this padding.
  internal var padding0: Int8 { _padding0 }
  internal var padding1: Int8 { _padding1 }
  internal var padding2: Int8 { _padding2 }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialFrameData.self)
  }
}

///  Struct containing the data common start of frame data
internal struct Unity_PolySpatial_Internals_PolySpatialFrameData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var frameNumber: Int32 { return _accessor.readBuffer(of: Int32.self, at: 0) }
  internal var frameStartTime: Double { return _accessor.readBuffer(of: Double.self, at: 8) }
  internal var eventTime: Double { return _accessor.readBuffer(of: Double.self, at: 16) }
  internal var deltaTime: Float32 { return _accessor.readBuffer(of: Float32.self, at: 24) }
  internal var morePendingFramesBatched: Bool { return _accessor.readBuffer(of: Bool.self, at: 28) }
  internal var padding0: Int8 { return _accessor.readBuffer(of: Int8.self, at: 29) }
  internal var padding1: Int8 { return _accessor.readBuffer(of: Int8.self, at: 30) }
  internal var padding2: Int8 { return _accessor.readBuffer(of: Int8.self, at: 31) }
}

///  Define a structure to encapsulate both local and remote support for a capability.
internal struct Unity_PolySpatial_Internals_CapabilityStatus: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _localStatus: Int8
  private var _remoteStatus: Int8

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _localStatus = _accessor.readBuffer(of: Int8.self, at: 0)
    _remoteStatus = _accessor.readBuffer(of: Int8.self, at: 1)
  }

  internal init(localStatus: Unity_PolySpatial_Internals_LocalSupport, remoteStatus: Unity_PolySpatial_Internals_RemoteSupport) {
    _localStatus = localStatus.value
    _remoteStatus = remoteStatus.value
  }

  internal init() {
    _localStatus = 0
    _remoteStatus = 0
  }

  internal var localStatus: Unity_PolySpatial_Internals_LocalSupport { Unity_PolySpatial_Internals_LocalSupport(rawValue: _localStatus)! }
  internal var remoteStatus: Unity_PolySpatial_Internals_RemoteSupport { Unity_PolySpatial_Internals_RemoteSupport(rawValue: _remoteStatus)! }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_CapabilityStatus.self)
  }
}

///  Define a structure to encapsulate both local and remote support for a capability.
internal struct Unity_PolySpatial_Internals_CapabilityStatus_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var localStatus: Unity_PolySpatial_Internals_LocalSupport { return Unity_PolySpatial_Internals_LocalSupport(rawValue: _accessor.readBuffer(of: Int8.self, at: 0)) ?? .unsupported }
  internal var remoteStatus: Unity_PolySpatial_Internals_RemoteSupport { return Unity_PolySpatial_Internals_RemoteSupport(rawValue: _accessor.readBuffer(of: Int8.self, at: 1)) ?? .noRemotesConnected }
}

internal struct Unity_PolySpatial_Internals_PolySpatialInputCapabilities: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _keyboard: Unity_PolySpatial_Internals_CapabilityStatus
  private var _mouse: Unity_PolySpatial_Internals_CapabilityStatus
  private var _untrackedControllers: Unity_PolySpatial_Internals_CapabilityStatus
  private var _trackedControllers: Unity_PolySpatial_Internals_CapabilityStatus
  private var _touchScreen: Unity_PolySpatial_Internals_CapabilityStatus
  private var _touchSpace: Unity_PolySpatial_Internals_CapabilityStatus
  private var _handTracking: Unity_PolySpatial_Internals_CapabilityStatus
  private var _gaze: Unity_PolySpatial_Internals_CapabilityStatus

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _keyboard = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 0)
    _mouse = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 2)
    _untrackedControllers = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 4)
    _trackedControllers = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 6)
    _touchScreen = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 8)
    _touchSpace = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 10)
    _handTracking = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 12)
    _gaze = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 14)
  }

  internal init(keyboard: Unity_PolySpatial_Internals_CapabilityStatus, mouse: Unity_PolySpatial_Internals_CapabilityStatus, untrackedControllers: Unity_PolySpatial_Internals_CapabilityStatus, trackedControllers: Unity_PolySpatial_Internals_CapabilityStatus, touchScreen: Unity_PolySpatial_Internals_CapabilityStatus, touchSpace: Unity_PolySpatial_Internals_CapabilityStatus, handTracking: Unity_PolySpatial_Internals_CapabilityStatus, gaze: Unity_PolySpatial_Internals_CapabilityStatus) {
    _keyboard = keyboard
    _mouse = mouse
    _untrackedControllers = untrackedControllers
    _trackedControllers = trackedControllers
    _touchScreen = touchScreen
    _touchSpace = touchSpace
    _handTracking = handTracking
    _gaze = gaze
  }

  internal init() {
    _keyboard = Unity_PolySpatial_Internals_CapabilityStatus()
    _mouse = Unity_PolySpatial_Internals_CapabilityStatus()
    _untrackedControllers = Unity_PolySpatial_Internals_CapabilityStatus()
    _trackedControllers = Unity_PolySpatial_Internals_CapabilityStatus()
    _touchScreen = Unity_PolySpatial_Internals_CapabilityStatus()
    _touchSpace = Unity_PolySpatial_Internals_CapabilityStatus()
    _handTracking = Unity_PolySpatial_Internals_CapabilityStatus()
    _gaze = Unity_PolySpatial_Internals_CapabilityStatus()
  }

  internal var keyboard: Unity_PolySpatial_Internals_CapabilityStatus { _keyboard }
  internal var mouse: Unity_PolySpatial_Internals_CapabilityStatus { _mouse }
  internal var untrackedControllers: Unity_PolySpatial_Internals_CapabilityStatus { _untrackedControllers }
  internal var trackedControllers: Unity_PolySpatial_Internals_CapabilityStatus { _trackedControllers }
  internal var touchScreen: Unity_PolySpatial_Internals_CapabilityStatus { _touchScreen }
  internal var touchSpace: Unity_PolySpatial_Internals_CapabilityStatus { _touchSpace }
  internal var handTracking: Unity_PolySpatial_Internals_CapabilityStatus { _handTracking }
  internal var gaze: Unity_PolySpatial_Internals_CapabilityStatus { _gaze }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialInputCapabilities.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialInputCapabilities_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var keyboard: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var mouse: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 2) }
  internal var untrackedControllers: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 4) }
  internal var trackedControllers: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 6) }
  internal var touchScreen: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 8) }
  internal var touchSpace: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 10) }
  internal var handTracking: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 12) }
  internal var gaze: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 14) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialOutputCapabilities: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _audio: Unity_PolySpatial_Internals_CapabilityStatus
  private var _video: Unity_PolySpatial_Internals_CapabilityStatus
  private var _graphics2D: Unity_PolySpatial_Internals_CapabilityStatus
  private var _graphics3D: Unity_PolySpatial_Internals_CapabilityStatus
  private var _skinnedAnimation: Unity_PolySpatial_Internals_CapabilityStatus
  private var _particleEffects: Unity_PolySpatial_Internals_CapabilityStatus
  private var _pointLights: Unity_PolySpatial_Internals_CapabilityStatus
  private var _imageBasedLighting: Unity_PolySpatial_Internals_CapabilityStatus
  private var _renderTargets: Unity_PolySpatial_Internals_CapabilityStatus
  private var _localRenderTextures: Unity_PolySpatial_Internals_CapabilityStatus
  private var _hardwareShaders: Unity_PolySpatial_Internals_CapabilityStatus
  private var _materialXshaders: Unity_PolySpatial_Internals_CapabilityStatus
  private var _nativeTextures: Unity_PolySpatial_Internals_CapabilityStatus
  private var _lineRendererSerializeProperties: Unity_PolySpatial_Internals_CapabilityStatus
  private var _lineRendererBakeToMesh: Unity_PolySpatial_Internals_CapabilityStatus
  private var _trailRenderers: Unity_PolySpatial_Internals_CapabilityStatus
  private var _renderSettings: Unity_PolySpatial_Internals_CapabilityStatus
  private var _graphicsSettings: Unity_PolySpatial_Internals_CapabilityStatus
  private var _halo: Unity_PolySpatial_Internals_CapabilityStatus
  private var _renderingVolumes: Unity_PolySpatial_Internals_CapabilityStatus
  private var _spriteRendering: Unity_PolySpatial_Internals_CapabilityStatus
  private var _spriteMasking: Unity_PolySpatial_Internals_CapabilityStatus

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _audio = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 0)
    _video = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 2)
    _graphics2D = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 4)
    _graphics3D = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 6)
    _skinnedAnimation = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 8)
    _particleEffects = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 10)
    _pointLights = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 12)
    _imageBasedLighting = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 14)
    _renderTargets = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 16)
    _localRenderTextures = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 18)
    _hardwareShaders = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 20)
    _materialXshaders = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 22)
    _nativeTextures = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 24)
    _lineRendererSerializeProperties = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 26)
    _lineRendererBakeToMesh = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 28)
    _trailRenderers = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 30)
    _renderSettings = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 32)
    _graphicsSettings = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 34)
    _halo = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 36)
    _renderingVolumes = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 38)
    _spriteRendering = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 40)
    _spriteMasking = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 42)
  }

  internal init(audio: Unity_PolySpatial_Internals_CapabilityStatus, video: Unity_PolySpatial_Internals_CapabilityStatus, graphics2D: Unity_PolySpatial_Internals_CapabilityStatus, graphics3D: Unity_PolySpatial_Internals_CapabilityStatus, skinnedAnimation: Unity_PolySpatial_Internals_CapabilityStatus, particleEffects: Unity_PolySpatial_Internals_CapabilityStatus, pointLights: Unity_PolySpatial_Internals_CapabilityStatus, imageBasedLighting: Unity_PolySpatial_Internals_CapabilityStatus, renderTargets: Unity_PolySpatial_Internals_CapabilityStatus, localRenderTextures: Unity_PolySpatial_Internals_CapabilityStatus, hardwareShaders: Unity_PolySpatial_Internals_CapabilityStatus, materialXshaders: Unity_PolySpatial_Internals_CapabilityStatus, nativeTextures: Unity_PolySpatial_Internals_CapabilityStatus, lineRendererSerializeProperties: Unity_PolySpatial_Internals_CapabilityStatus, lineRendererBakeToMesh: Unity_PolySpatial_Internals_CapabilityStatus, trailRenderers: Unity_PolySpatial_Internals_CapabilityStatus, renderSettings: Unity_PolySpatial_Internals_CapabilityStatus, graphicsSettings: Unity_PolySpatial_Internals_CapabilityStatus, halo: Unity_PolySpatial_Internals_CapabilityStatus, renderingVolumes: Unity_PolySpatial_Internals_CapabilityStatus, spriteRendering: Unity_PolySpatial_Internals_CapabilityStatus, spriteMasking: Unity_PolySpatial_Internals_CapabilityStatus) {
    _audio = audio
    _video = video
    _graphics2D = graphics2D
    _graphics3D = graphics3D
    _skinnedAnimation = skinnedAnimation
    _particleEffects = particleEffects
    _pointLights = pointLights
    _imageBasedLighting = imageBasedLighting
    _renderTargets = renderTargets
    _localRenderTextures = localRenderTextures
    _hardwareShaders = hardwareShaders
    _materialXshaders = materialXshaders
    _nativeTextures = nativeTextures
    _lineRendererSerializeProperties = lineRendererSerializeProperties
    _lineRendererBakeToMesh = lineRendererBakeToMesh
    _trailRenderers = trailRenderers
    _renderSettings = renderSettings
    _graphicsSettings = graphicsSettings
    _halo = halo
    _renderingVolumes = renderingVolumes
    _spriteRendering = spriteRendering
    _spriteMasking = spriteMasking
  }

  internal init() {
    _audio = Unity_PolySpatial_Internals_CapabilityStatus()
    _video = Unity_PolySpatial_Internals_CapabilityStatus()
    _graphics2D = Unity_PolySpatial_Internals_CapabilityStatus()
    _graphics3D = Unity_PolySpatial_Internals_CapabilityStatus()
    _skinnedAnimation = Unity_PolySpatial_Internals_CapabilityStatus()
    _particleEffects = Unity_PolySpatial_Internals_CapabilityStatus()
    _pointLights = Unity_PolySpatial_Internals_CapabilityStatus()
    _imageBasedLighting = Unity_PolySpatial_Internals_CapabilityStatus()
    _renderTargets = Unity_PolySpatial_Internals_CapabilityStatus()
    _localRenderTextures = Unity_PolySpatial_Internals_CapabilityStatus()
    _hardwareShaders = Unity_PolySpatial_Internals_CapabilityStatus()
    _materialXshaders = Unity_PolySpatial_Internals_CapabilityStatus()
    _nativeTextures = Unity_PolySpatial_Internals_CapabilityStatus()
    _lineRendererSerializeProperties = Unity_PolySpatial_Internals_CapabilityStatus()
    _lineRendererBakeToMesh = Unity_PolySpatial_Internals_CapabilityStatus()
    _trailRenderers = Unity_PolySpatial_Internals_CapabilityStatus()
    _renderSettings = Unity_PolySpatial_Internals_CapabilityStatus()
    _graphicsSettings = Unity_PolySpatial_Internals_CapabilityStatus()
    _halo = Unity_PolySpatial_Internals_CapabilityStatus()
    _renderingVolumes = Unity_PolySpatial_Internals_CapabilityStatus()
    _spriteRendering = Unity_PolySpatial_Internals_CapabilityStatus()
    _spriteMasking = Unity_PolySpatial_Internals_CapabilityStatus()
  }

  internal var audio: Unity_PolySpatial_Internals_CapabilityStatus { _audio }
  internal var video: Unity_PolySpatial_Internals_CapabilityStatus { _video }
  internal var graphics2D: Unity_PolySpatial_Internals_CapabilityStatus { _graphics2D }
  internal var graphics3D: Unity_PolySpatial_Internals_CapabilityStatus { _graphics3D }
  internal var skinnedAnimation: Unity_PolySpatial_Internals_CapabilityStatus { _skinnedAnimation }
  internal var particleEffects: Unity_PolySpatial_Internals_CapabilityStatus { _particleEffects }
  internal var pointLights: Unity_PolySpatial_Internals_CapabilityStatus { _pointLights }
  internal var imageBasedLighting: Unity_PolySpatial_Internals_CapabilityStatus { _imageBasedLighting }
  internal var renderTargets: Unity_PolySpatial_Internals_CapabilityStatus { _renderTargets }
  internal var localRenderTextures: Unity_PolySpatial_Internals_CapabilityStatus { _localRenderTextures }
  internal var hardwareShaders: Unity_PolySpatial_Internals_CapabilityStatus { _hardwareShaders }
  internal var materialXshaders: Unity_PolySpatial_Internals_CapabilityStatus { _materialXshaders }
  internal var nativeTextures: Unity_PolySpatial_Internals_CapabilityStatus { _nativeTextures }
  internal var lineRendererSerializeProperties: Unity_PolySpatial_Internals_CapabilityStatus { _lineRendererSerializeProperties }
  internal var lineRendererBakeToMesh: Unity_PolySpatial_Internals_CapabilityStatus { _lineRendererBakeToMesh }
  internal var trailRenderers: Unity_PolySpatial_Internals_CapabilityStatus { _trailRenderers }
  internal var renderSettings: Unity_PolySpatial_Internals_CapabilityStatus { _renderSettings }
  internal var graphicsSettings: Unity_PolySpatial_Internals_CapabilityStatus { _graphicsSettings }
  internal var halo: Unity_PolySpatial_Internals_CapabilityStatus { _halo }
  internal var renderingVolumes: Unity_PolySpatial_Internals_CapabilityStatus { _renderingVolumes }
  internal var spriteRendering: Unity_PolySpatial_Internals_CapabilityStatus { _spriteRendering }
  internal var spriteMasking: Unity_PolySpatial_Internals_CapabilityStatus { _spriteMasking }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialOutputCapabilities.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialOutputCapabilities_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var audio: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var video: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 2) }
  internal var graphics2D: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 4) }
  internal var graphics3D: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 6) }
  internal var skinnedAnimation: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 8) }
  internal var particleEffects: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 10) }
  internal var pointLights: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 12) }
  internal var imageBasedLighting: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 14) }
  internal var renderTargets: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 16) }
  internal var localRenderTextures: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 18) }
  internal var hardwareShaders: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 20) }
  internal var materialXshaders: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 22) }
  internal var nativeTextures: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 24) }
  internal var lineRendererSerializeProperties: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 26) }
  internal var lineRendererBakeToMesh: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 28) }
  internal var trailRenderers: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 30) }
  internal var renderSettings: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 32) }
  internal var graphicsSettings: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 34) }
  internal var halo: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 36) }
  internal var renderingVolumes: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 38) }
  internal var spriteRendering: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 40) }
  internal var spriteMasking: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 42) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialARCapabilities: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _deviceTracking: Unity_PolySpatial_Internals_CapabilityStatus
  private var _planeDetection: Unity_PolySpatial_Internals_CapabilityStatus
  private var _lightEstimation: Unity_PolySpatial_Internals_CapabilityStatus
  private var _imageTracking: Unity_PolySpatial_Internals_CapabilityStatus
  private var _objectTracking: Unity_PolySpatial_Internals_CapabilityStatus
  private var _faceTracking: Unity_PolySpatial_Internals_CapabilityStatus
  private var _bodyTracking: Unity_PolySpatial_Internals_CapabilityStatus
  private var _anchors: Unity_PolySpatial_Internals_CapabilityStatus
  private var _meshing: Unity_PolySpatial_Internals_CapabilityStatus

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _deviceTracking = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 0)
    _planeDetection = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 2)
    _lightEstimation = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 4)
    _imageTracking = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 6)
    _objectTracking = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 8)
    _faceTracking = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 10)
    _bodyTracking = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 12)
    _anchors = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 14)
    _meshing = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 16)
  }

  internal init(deviceTracking: Unity_PolySpatial_Internals_CapabilityStatus, planeDetection: Unity_PolySpatial_Internals_CapabilityStatus, lightEstimation: Unity_PolySpatial_Internals_CapabilityStatus, imageTracking: Unity_PolySpatial_Internals_CapabilityStatus, objectTracking: Unity_PolySpatial_Internals_CapabilityStatus, faceTracking: Unity_PolySpatial_Internals_CapabilityStatus, bodyTracking: Unity_PolySpatial_Internals_CapabilityStatus, anchors: Unity_PolySpatial_Internals_CapabilityStatus, meshing: Unity_PolySpatial_Internals_CapabilityStatus) {
    _deviceTracking = deviceTracking
    _planeDetection = planeDetection
    _lightEstimation = lightEstimation
    _imageTracking = imageTracking
    _objectTracking = objectTracking
    _faceTracking = faceTracking
    _bodyTracking = bodyTracking
    _anchors = anchors
    _meshing = meshing
  }

  internal init() {
    _deviceTracking = Unity_PolySpatial_Internals_CapabilityStatus()
    _planeDetection = Unity_PolySpatial_Internals_CapabilityStatus()
    _lightEstimation = Unity_PolySpatial_Internals_CapabilityStatus()
    _imageTracking = Unity_PolySpatial_Internals_CapabilityStatus()
    _objectTracking = Unity_PolySpatial_Internals_CapabilityStatus()
    _faceTracking = Unity_PolySpatial_Internals_CapabilityStatus()
    _bodyTracking = Unity_PolySpatial_Internals_CapabilityStatus()
    _anchors = Unity_PolySpatial_Internals_CapabilityStatus()
    _meshing = Unity_PolySpatial_Internals_CapabilityStatus()
  }

  internal var deviceTracking: Unity_PolySpatial_Internals_CapabilityStatus { _deviceTracking }
  internal var planeDetection: Unity_PolySpatial_Internals_CapabilityStatus { _planeDetection }
  internal var lightEstimation: Unity_PolySpatial_Internals_CapabilityStatus { _lightEstimation }
  internal var imageTracking: Unity_PolySpatial_Internals_CapabilityStatus { _imageTracking }
  internal var objectTracking: Unity_PolySpatial_Internals_CapabilityStatus { _objectTracking }
  internal var faceTracking: Unity_PolySpatial_Internals_CapabilityStatus { _faceTracking }
  internal var bodyTracking: Unity_PolySpatial_Internals_CapabilityStatus { _bodyTracking }
  internal var anchors: Unity_PolySpatial_Internals_CapabilityStatus { _anchors }
  internal var meshing: Unity_PolySpatial_Internals_CapabilityStatus { _meshing }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialARCapabilities.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialARCapabilities_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var deviceTracking: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var planeDetection: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 2) }
  internal var lightEstimation: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 4) }
  internal var imageTracking: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 6) }
  internal var objectTracking: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 8) }
  internal var faceTracking: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 10) }
  internal var bodyTracking: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 12) }
  internal var anchors: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 14) }
  internal var meshing: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 16) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialEnvironmentCapabilities: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _unboundedVolumes: Unity_PolySpatial_Internals_CapabilityStatus
  private var _boundedVolumes: Unity_PolySpatial_Internals_CapabilityStatus
  private var _mixedVolumes: Unity_PolySpatial_Internals_CapabilityStatus
  private var _multipleVolumes: Unity_PolySpatial_Internals_CapabilityStatus
  private var _passThrough: Unity_PolySpatial_Internals_CapabilityStatus

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _unboundedVolumes = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 0)
    _boundedVolumes = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 2)
    _mixedVolumes = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 4)
    _multipleVolumes = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 6)
    _passThrough = Unity_PolySpatial_Internals_CapabilityStatus(_accessor.bb, o: _accessor.postion + 8)
  }

  internal init(unboundedVolumes: Unity_PolySpatial_Internals_CapabilityStatus, boundedVolumes: Unity_PolySpatial_Internals_CapabilityStatus, mixedVolumes: Unity_PolySpatial_Internals_CapabilityStatus, multipleVolumes: Unity_PolySpatial_Internals_CapabilityStatus, passThrough: Unity_PolySpatial_Internals_CapabilityStatus) {
    _unboundedVolumes = unboundedVolumes
    _boundedVolumes = boundedVolumes
    _mixedVolumes = mixedVolumes
    _multipleVolumes = multipleVolumes
    _passThrough = passThrough
  }

  internal init() {
    _unboundedVolumes = Unity_PolySpatial_Internals_CapabilityStatus()
    _boundedVolumes = Unity_PolySpatial_Internals_CapabilityStatus()
    _mixedVolumes = Unity_PolySpatial_Internals_CapabilityStatus()
    _multipleVolumes = Unity_PolySpatial_Internals_CapabilityStatus()
    _passThrough = Unity_PolySpatial_Internals_CapabilityStatus()
  }

  internal var unboundedVolumes: Unity_PolySpatial_Internals_CapabilityStatus { _unboundedVolumes }
  internal var boundedVolumes: Unity_PolySpatial_Internals_CapabilityStatus { _boundedVolumes }
  internal var mixedVolumes: Unity_PolySpatial_Internals_CapabilityStatus { _mixedVolumes }
  internal var multipleVolumes: Unity_PolySpatial_Internals_CapabilityStatus { _multipleVolumes }
  internal var passThrough: Unity_PolySpatial_Internals_CapabilityStatus { _passThrough }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialEnvironmentCapabilities.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialEnvironmentCapabilities_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var unboundedVolumes: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var boundedVolumes: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 2) }
  internal var mixedVolumes: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 4) }
  internal var multipleVolumes: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 6) }
  internal var passThrough: Unity_PolySpatial_Internals_CapabilityStatus_Mutable { return Unity_PolySpatial_Internals_CapabilityStatus_Mutable(_accessor.bb, o: _accessor.postion + 8) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialPlatformCapabilities: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _inputCapabilities: Unity_PolySpatial_Internals_PolySpatialInputCapabilities
  private var _outputCapabilities: Unity_PolySpatial_Internals_PolySpatialOutputCapabilities
  private var _environmentCapabilities: Unity_PolySpatial_Internals_PolySpatialEnvironmentCapabilities
  private var _arCapabilities: Unity_PolySpatial_Internals_PolySpatialARCapabilities

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _inputCapabilities = Unity_PolySpatial_Internals_PolySpatialInputCapabilities(_accessor.bb, o: _accessor.postion + 0)
    _outputCapabilities = Unity_PolySpatial_Internals_PolySpatialOutputCapabilities(_accessor.bb, o: _accessor.postion + 16)
    _environmentCapabilities = Unity_PolySpatial_Internals_PolySpatialEnvironmentCapabilities(_accessor.bb, o: _accessor.postion + 60)
    _arCapabilities = Unity_PolySpatial_Internals_PolySpatialARCapabilities(_accessor.bb, o: _accessor.postion + 70)
  }

  internal init(inputCapabilities: Unity_PolySpatial_Internals_PolySpatialInputCapabilities, outputCapabilities: Unity_PolySpatial_Internals_PolySpatialOutputCapabilities, environmentCapabilities: Unity_PolySpatial_Internals_PolySpatialEnvironmentCapabilities, arCapabilities: Unity_PolySpatial_Internals_PolySpatialARCapabilities) {
    _inputCapabilities = inputCapabilities
    _outputCapabilities = outputCapabilities
    _environmentCapabilities = environmentCapabilities
    _arCapabilities = arCapabilities
  }

  internal init() {
    _inputCapabilities = Unity_PolySpatial_Internals_PolySpatialInputCapabilities()
    _outputCapabilities = Unity_PolySpatial_Internals_PolySpatialOutputCapabilities()
    _environmentCapabilities = Unity_PolySpatial_Internals_PolySpatialEnvironmentCapabilities()
    _arCapabilities = Unity_PolySpatial_Internals_PolySpatialARCapabilities()
  }

  internal var inputCapabilities: Unity_PolySpatial_Internals_PolySpatialInputCapabilities { _inputCapabilities }
  internal var outputCapabilities: Unity_PolySpatial_Internals_PolySpatialOutputCapabilities { _outputCapabilities }
  internal var environmentCapabilities: Unity_PolySpatial_Internals_PolySpatialEnvironmentCapabilities { _environmentCapabilities }
  internal var arCapabilities: Unity_PolySpatial_Internals_PolySpatialARCapabilities { _arCapabilities }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialPlatformCapabilities.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialPlatformCapabilities_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var inputCapabilities: Unity_PolySpatial_Internals_PolySpatialInputCapabilities_Mutable { return Unity_PolySpatial_Internals_PolySpatialInputCapabilities_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var outputCapabilities: Unity_PolySpatial_Internals_PolySpatialOutputCapabilities_Mutable { return Unity_PolySpatial_Internals_PolySpatialOutputCapabilities_Mutable(_accessor.bb, o: _accessor.postion + 16) }
  internal var environmentCapabilities: Unity_PolySpatial_Internals_PolySpatialEnvironmentCapabilities_Mutable { return Unity_PolySpatial_Internals_PolySpatialEnvironmentCapabilities_Mutable(_accessor.bb, o: _accessor.postion + 60) }
  internal var arCapabilities: Unity_PolySpatial_Internals_PolySpatialARCapabilities_Mutable { return Unity_PolySpatial_Internals_PolySpatialARCapabilities_Mutable(_accessor.bb, o: _accessor.postion + 70) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialVolumeCameraData_v1: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _position: UnityEngine_Vector3
  private var _rotation: UnityEngine_Quaternion
  private var _scale: UnityEngine_Vector3
  private var _dimensions: UnityEngine_Vector3
  private var _outputMode: Int16
  private let padding0__: UInt16 = 0
  private var _outputDimensions: UnityEngine_Vector3
  private var _scaleWithWindow: Bool
  private var _windowOpen: Bool
  private let padding1__: UInt16 = 0
  private var _cullingMask: Int32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _position = UnityEngine_Vector3(_accessor.bb, o: _accessor.postion + 0)
    _rotation = UnityEngine_Quaternion(_accessor.bb, o: _accessor.postion + 12)
    _scale = UnityEngine_Vector3(_accessor.bb, o: _accessor.postion + 28)
    _dimensions = UnityEngine_Vector3(_accessor.bb, o: _accessor.postion + 40)
    _outputMode = _accessor.readBuffer(of: Int16.self, at: 52)
    _outputDimensions = UnityEngine_Vector3(_accessor.bb, o: _accessor.postion + 56)
    _scaleWithWindow = _accessor.readBuffer(of: Bool.self, at: 68)
    _windowOpen = _accessor.readBuffer(of: Bool.self, at: 69)
    _cullingMask = _accessor.readBuffer(of: Int32.self, at: 72)
  }

  internal init(position: UnityEngine_Vector3, rotation: UnityEngine_Quaternion, scale: UnityEngine_Vector3, dimensions: UnityEngine_Vector3, outputMode: Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode, outputDimensions: UnityEngine_Vector3, scaleWithWindow: Bool, windowOpen: Bool, cullingMask: Int32) {
    _position = position
    _rotation = rotation
    _scale = scale
    _dimensions = dimensions
    _outputMode = outputMode.value
    _outputDimensions = outputDimensions
    _scaleWithWindow = scaleWithWindow
    _windowOpen = windowOpen
    _cullingMask = cullingMask
  }

  internal init() {
    _position = UnityEngine_Vector3()
    _rotation = UnityEngine_Quaternion()
    _scale = UnityEngine_Vector3()
    _dimensions = UnityEngine_Vector3()
    _outputMode = 0
    _outputDimensions = UnityEngine_Vector3()
    _scaleWithWindow = false
    _windowOpen = false
    _cullingMask = 0
  }

  internal var position: UnityEngine_Vector3 { _position }
  internal var rotation: UnityEngine_Quaternion { _rotation }
  internal var scale: UnityEngine_Vector3 { _scale }
  internal var dimensions: UnityEngine_Vector3 { _dimensions }
  internal var outputMode: Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode { Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode(rawValue: _outputMode)! }
  internal var outputDimensions: UnityEngine_Vector3 { _outputDimensions }
  internal var scaleWithWindow: Bool { _scaleWithWindow }
  internal var windowOpen: Bool { _windowOpen }
  internal var cullingMask: Int32 { _cullingMask }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialVolumeCameraData_v1.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialVolumeCameraData_v1_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var position: UnityEngine_Vector3_Mutable { return UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var rotation: UnityEngine_Quaternion_Mutable { return UnityEngine_Quaternion_Mutable(_accessor.bb, o: _accessor.postion + 12) }
  internal var scale: UnityEngine_Vector3_Mutable { return UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.postion + 28) }
  internal var dimensions: UnityEngine_Vector3_Mutable { return UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.postion + 40) }
  internal var outputMode: Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode { return Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode(rawValue: _accessor.readBuffer(of: Int16.self, at: 52)) ?? .bounded }
  internal var outputDimensions: UnityEngine_Vector3_Mutable { return UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.postion + 56) }
  internal var scaleWithWindow: Bool { return _accessor.readBuffer(of: Bool.self, at: 68) }
  internal var windowOpen: Bool { return _accessor.readBuffer(of: Bool.self, at: 69) }
  internal var cullingMask: Int32 { return _accessor.readBuffer(of: Int32.self, at: 72) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialWindowState: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _iid: Unity_PolySpatial_Internals_PolySpatialInstanceID
  private var _outputDimensions: UnityEngine_Vector3
  private var _contentDimensions: UnityEngine_Vector3
  private var _outputMode: Int16
  private var _windowEvent: Int16
  private var _isFocused: Bool
  private var __Padding0: UInt8
  private var __Padding1: UInt16

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _iid = Unity_PolySpatial_Internals_PolySpatialInstanceID(_accessor.bb, o: _accessor.postion + 0)
    _outputDimensions = UnityEngine_Vector3(_accessor.bb, o: _accessor.postion + 16)
    _contentDimensions = UnityEngine_Vector3(_accessor.bb, o: _accessor.postion + 28)
    _outputMode = _accessor.readBuffer(of: Int16.self, at: 40)
    _windowEvent = _accessor.readBuffer(of: Int16.self, at: 42)
    _isFocused = _accessor.readBuffer(of: Bool.self, at: 44)
    __Padding0 = _accessor.readBuffer(of: UInt8.self, at: 45)
    __Padding1 = _accessor.readBuffer(of: UInt16.self, at: 46)
  }

  internal init(iid: Unity_PolySpatial_Internals_PolySpatialInstanceID, outputDimensions: UnityEngine_Vector3, contentDimensions: UnityEngine_Vector3, outputMode: Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode, windowEvent: Unity_PolySpatial_Internals_WindowEvent, isFocused: Bool, _Padding0: UInt8, _Padding1: UInt16) {
    _iid = iid
    _outputDimensions = outputDimensions
    _contentDimensions = contentDimensions
    _outputMode = outputMode.value
    _windowEvent = windowEvent.value
    _isFocused = isFocused
    __Padding0 = _Padding0
    __Padding1 = _Padding1
  }

  internal init() {
    _iid = Unity_PolySpatial_Internals_PolySpatialInstanceID()
    _outputDimensions = UnityEngine_Vector3()
    _contentDimensions = UnityEngine_Vector3()
    _outputMode = 0
    _windowEvent = 0
    _isFocused = false
    __Padding0 = 0
    __Padding1 = 0
  }

  internal var iid: Unity_PolySpatial_Internals_PolySpatialInstanceID { _iid }
  internal var outputDimensions: UnityEngine_Vector3 { _outputDimensions }
  internal var contentDimensions: UnityEngine_Vector3 { _contentDimensions }
  internal var outputMode: Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode { Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode(rawValue: _outputMode)! }
  internal var windowEvent: Unity_PolySpatial_Internals_WindowEvent { Unity_PolySpatial_Internals_WindowEvent(rawValue: _windowEvent)! }
  internal var isFocused: Bool { _isFocused }
  internal var _Padding0: UInt8 { __Padding0 }
  internal var _Padding1: UInt16 { __Padding1 }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialWindowState.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialWindowState_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var iid: Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable { return Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var outputDimensions: UnityEngine_Vector3_Mutable { return UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.postion + 16) }
  internal var contentDimensions: UnityEngine_Vector3_Mutable { return UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.postion + 28) }
  internal var outputMode: Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode { return Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode(rawValue: _accessor.readBuffer(of: Int16.self, at: 40)) ?? .bounded }
  internal var windowEvent: Unity_PolySpatial_Internals_WindowEvent { return Unity_PolySpatial_Internals_WindowEvent(rawValue: _accessor.readBuffer(of: Int16.self, at: 42)) ?? .opened }
  internal var isFocused: Bool { return _accessor.readBuffer(of: Bool.self, at: 44) }
  internal var _Padding0: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 45) }
  internal var _Padding1: UInt16 { return _accessor.readBuffer(of: UInt16.self, at: 46) }
}

///  Data for an Immersion state change
internal struct Unity_PolySpatial_Internals_PolySpatialImmersionData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _oldAmount: Double
  private var _newAmount: Double
  private var _oldHasValue: Bool
  private var _newHasValue: Bool
  private var __Padding0: UInt16
  private var __Padding1: UInt32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _oldAmount = _accessor.readBuffer(of: Double.self, at: 0)
    _newAmount = _accessor.readBuffer(of: Double.self, at: 8)
    _oldHasValue = _accessor.readBuffer(of: Bool.self, at: 16)
    _newHasValue = _accessor.readBuffer(of: Bool.self, at: 17)
    __Padding0 = _accessor.readBuffer(of: UInt16.self, at: 18)
    __Padding1 = _accessor.readBuffer(of: UInt32.self, at: 20)
  }

  internal init(oldAmount: Double, newAmount: Double, oldHasValue: Bool, newHasValue: Bool, _Padding0: UInt16, _Padding1: UInt32) {
    _oldAmount = oldAmount
    _newAmount = newAmount
    _oldHasValue = oldHasValue
    _newHasValue = newHasValue
    __Padding0 = _Padding0
    __Padding1 = _Padding1
  }

  internal init() {
    _oldAmount = 0.0
    _newAmount = 0.0
    _oldHasValue = false
    _newHasValue = false
    __Padding0 = 0
    __Padding1 = 0
  }

  internal var oldAmount: Double { _oldAmount }
  internal var newAmount: Double { _newAmount }
  internal var oldHasValue: Bool { _oldHasValue }
  internal var newHasValue: Bool { _newHasValue }
  internal var _Padding0: UInt16 { __Padding0 }
  internal var _Padding1: UInt32 { __Padding1 }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialImmersionData.self)
  }
}

///  Data for an Immersion state change
internal struct Unity_PolySpatial_Internals_PolySpatialImmersionData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var oldAmount: Double { return _accessor.readBuffer(of: Double.self, at: 0) }
  internal var newAmount: Double { return _accessor.readBuffer(of: Double.self, at: 8) }
  internal var oldHasValue: Bool { return _accessor.readBuffer(of: Bool.self, at: 16) }
  internal var newHasValue: Bool { return _accessor.readBuffer(of: Bool.self, at: 17) }
  internal var _Padding0: UInt16 { return _accessor.readBuffer(of: UInt16.self, at: 18) }
  internal var _Padding1: UInt32 { return _accessor.readBuffer(of: UInt32.self, at: 20) }
}

///  Defines the weight associated with a given bone in
///  a mesh.
internal struct Unity_PolySpatial_Internals_PolySpatialBoneWeight: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The weight assigned to the bone.
  private var _weight: Float32
  ///  The index of the bone that the weight is to be applied to.
  private var _boneIndex: Int32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _weight = _accessor.readBuffer(of: Float32.self, at: 0)
    _boneIndex = _accessor.readBuffer(of: Int32.self, at: 4)
  }

  internal init(weight: Float32, boneIndex: Int32) {
    _weight = weight
    _boneIndex = boneIndex
  }

  internal init() {
    _weight = 0.0
    _boneIndex = 0
  }

  ///  The weight assigned to the bone.
  internal var weight: Float32 { _weight }
  ///  The index of the bone that the weight is to be applied to.
  internal var boneIndex: Int32 { _boneIndex }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialBoneWeight.self)
  }
}

///  Defines the weight associated with a given bone in
///  a mesh.
internal struct Unity_PolySpatial_Internals_PolySpatialBoneWeight_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var weight: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  internal var boneIndex: Int32 { return _accessor.readBuffer(of: Int32.self, at: 4) }
}

///  Information concerning a specific sub mesh of a larger
///  mesh resource.
internal struct Unity_PolySpatial_Internals_PolySpatialSubMesh: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The offset to add to each index value.
  private var _baseVertexIndex: Int32
  ///  The local bounds of the submesh.
  private var _bounds: UnityEngine_Bounds
  ///  The index of the first vertex used by the sub mesh.
  private var _firstVertex: Int32
  ///  The count of indices used for this sub mesh.
  private var _indexCount: Int32
  ///  The start location in the mesh indices buffer where
  ///  the triangle descriptions start.
  private var _indexStart: Int32
  ///  The topology of this submesh.
  private var _topology: Int32
  ///  The total number of vertices used by the sub mesh.
  private var _vertexCount: Int32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _baseVertexIndex = _accessor.readBuffer(of: Int32.self, at: 0)
    _bounds = UnityEngine_Bounds(_accessor.bb, o: _accessor.postion + 4)
    _firstVertex = _accessor.readBuffer(of: Int32.self, at: 28)
    _indexCount = _accessor.readBuffer(of: Int32.self, at: 32)
    _indexStart = _accessor.readBuffer(of: Int32.self, at: 36)
    _topology = _accessor.readBuffer(of: Int32.self, at: 40)
    _vertexCount = _accessor.readBuffer(of: Int32.self, at: 44)
  }

  internal init(baseVertexIndex: Int32, bounds: UnityEngine_Bounds, firstVertex: Int32, indexCount: Int32, indexStart: Int32, topology: Unity_PolySpatial_Internals_PolySpatialMeshTopology, vertexCount: Int32) {
    _baseVertexIndex = baseVertexIndex
    _bounds = bounds
    _firstVertex = firstVertex
    _indexCount = indexCount
    _indexStart = indexStart
    _topology = topology.value
    _vertexCount = vertexCount
  }

  internal init() {
    _baseVertexIndex = 0
    _bounds = UnityEngine_Bounds()
    _firstVertex = 0
    _indexCount = 0
    _indexStart = 0
    _topology = 0
    _vertexCount = 0
  }

  ///  The offset to add to each index value.
  internal var baseVertexIndex: Int32 { _baseVertexIndex }
  ///  The local bounds of the submesh.
  internal var bounds: UnityEngine_Bounds { _bounds }
  ///  The index of the first vertex used by the sub mesh.
  internal var firstVertex: Int32 { _firstVertex }
  ///  The count of indices used for this sub mesh.
  internal var indexCount: Int32 { _indexCount }
  ///  The start location in the mesh indices buffer where
  ///  the triangle descriptions start.
  internal var indexStart: Int32 { _indexStart }
  ///  The topology of this submesh.
  internal var topology: Unity_PolySpatial_Internals_PolySpatialMeshTopology { Unity_PolySpatial_Internals_PolySpatialMeshTopology(rawValue: _topology)! }
  ///  The total number of vertices used by the sub mesh.
  internal var vertexCount: Int32 { _vertexCount }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialSubMesh.self)
  }
}

///  Information concerning a specific sub mesh of a larger
///  mesh resource.
internal struct Unity_PolySpatial_Internals_PolySpatialSubMesh_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var baseVertexIndex: Int32 { return _accessor.readBuffer(of: Int32.self, at: 0) }
  internal var bounds: UnityEngine_Bounds_Mutable { return UnityEngine_Bounds_Mutable(_accessor.bb, o: _accessor.postion + 4) }
  internal var firstVertex: Int32 { return _accessor.readBuffer(of: Int32.self, at: 28) }
  internal var indexCount: Int32 { return _accessor.readBuffer(of: Int32.self, at: 32) }
  internal var indexStart: Int32 { return _accessor.readBuffer(of: Int32.self, at: 36) }
  internal var topology: Unity_PolySpatial_Internals_PolySpatialMeshTopology { return Unity_PolySpatial_Internals_PolySpatialMeshTopology(rawValue: _accessor.readBuffer(of: Int32.self, at: 40)) ?? .triangles }
  internal var vertexCount: Int32 { return _accessor.readBuffer(of: Int32.self, at: 44) }
}

///  Describes the location and format of a single vertex attribute within a mesh.
internal struct Unity_PolySpatial_Internals_PolySpatialVertexAttributeDescriptor: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The kind of vertex attribute (position, normal, etc.)
  private var _attribute: Int32
  ///  The attribute dimension (1 - 4).
  private var _dimension: Int32
  ///  The attribute format (Float32, Float16, etc.)
  private var _format: Int32
  ///  The stream index.
  private var _stream: Int32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _attribute = _accessor.readBuffer(of: Int32.self, at: 0)
    _dimension = _accessor.readBuffer(of: Int32.self, at: 4)
    _format = _accessor.readBuffer(of: Int32.self, at: 8)
    _stream = _accessor.readBuffer(of: Int32.self, at: 12)
  }

  internal init(attribute: Unity_PolySpatial_Internals_PolySpatialVertexAttribute, dimension: Int32, format: Unity_PolySpatial_Internals_PolySpatialVertexAttributeFormat, stream: Int32) {
    _attribute = attribute.value
    _dimension = dimension
    _format = format.value
    _stream = stream
  }

  internal init() {
    _attribute = 0
    _dimension = 0
    _format = 0
    _stream = 0
  }

  ///  The kind of vertex attribute (position, normal, etc.)
  internal var attribute: Unity_PolySpatial_Internals_PolySpatialVertexAttribute { Unity_PolySpatial_Internals_PolySpatialVertexAttribute(rawValue: _attribute)! }
  ///  The attribute dimension (1 - 4).
  internal var dimension: Int32 { _dimension }
  ///  The attribute format (Float32, Float16, etc.)
  internal var format: Unity_PolySpatial_Internals_PolySpatialVertexAttributeFormat { Unity_PolySpatial_Internals_PolySpatialVertexAttributeFormat(rawValue: _format)! }
  ///  The stream index.
  internal var stream: Int32 { _stream }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialVertexAttributeDescriptor.self)
  }
}

///  Describes the location and format of a single vertex attribute within a mesh.
internal struct Unity_PolySpatial_Internals_PolySpatialVertexAttributeDescriptor_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var attribute: Unity_PolySpatial_Internals_PolySpatialVertexAttribute { return Unity_PolySpatial_Internals_PolySpatialVertexAttribute(rawValue: _accessor.readBuffer(of: Int32.self, at: 0)) ?? .position }
  internal var dimension: Int32 { return _accessor.readBuffer(of: Int32.self, at: 4) }
  internal var format: Unity_PolySpatial_Internals_PolySpatialVertexAttributeFormat { return Unity_PolySpatial_Internals_PolySpatialVertexAttributeFormat(rawValue: _accessor.readBuffer(of: Int32.self, at: 8)) ?? .float32 }
  internal var stream: Int32 { return _accessor.readBuffer(of: Int32.self, at: 12) }
}

///  Mip-map data for a texture that has mip-map representations.
internal struct Unity_PolySpatial_Internals_PolySpatialTextureMipData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  index of the mipmap used to send singular mips
  private var _index: Int32
  ///  Width of the mipmap
  private var _width: Int32
  ///  Height of the mipmap
  private var _height: Int32
  ///  Describes the byte layout state for the mipmap.
  ///  Bytes in a row of pixels for uncompressed formats; bytes in a row of blocks for compressed
  private var _bytesPerRow: Int32
  ///  Bytes in a 2D plane of pixels (for 3D textures).
  private var _bytesPerImage: Int32
  ///  The actual size of the mipmap data.
  private var _dataSize: UInt32
  ///  Offset into base nativeDataPtr
  private var _dataOffset: UInt64

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _index = _accessor.readBuffer(of: Int32.self, at: 0)
    _width = _accessor.readBuffer(of: Int32.self, at: 4)
    _height = _accessor.readBuffer(of: Int32.self, at: 8)
    _bytesPerRow = _accessor.readBuffer(of: Int32.self, at: 12)
    _bytesPerImage = _accessor.readBuffer(of: Int32.self, at: 16)
    _dataSize = _accessor.readBuffer(of: UInt32.self, at: 20)
    _dataOffset = _accessor.readBuffer(of: UInt64.self, at: 24)
  }

  internal init(index: Int32, width: Int32, height: Int32, bytesPerRow: Int32, bytesPerImage: Int32, dataSize: UInt32, dataOffset: UInt64) {
    _index = index
    _width = width
    _height = height
    _bytesPerRow = bytesPerRow
    _bytesPerImage = bytesPerImage
    _dataSize = dataSize
    _dataOffset = dataOffset
  }

  internal init() {
    _index = 0
    _width = 0
    _height = 0
    _bytesPerRow = 0
    _bytesPerImage = 0
    _dataSize = 0
    _dataOffset = 0
  }

  ///  index of the mipmap used to send singular mips
  internal var index: Int32 { _index }
  ///  Width of the mipmap
  internal var width: Int32 { _width }
  ///  Height of the mipmap
  internal var height: Int32 { _height }
  ///  Describes the byte layout state for the mipmap.
  ///  Bytes in a row of pixels for uncompressed formats; bytes in a row of blocks for compressed
  internal var bytesPerRow: Int32 { _bytesPerRow }
  ///  Bytes in a 2D plane of pixels (for 3D textures).
  internal var bytesPerImage: Int32 { _bytesPerImage }
  ///  The actual size of the mipmap data.
  internal var dataSize: UInt32 { _dataSize }
  ///  Offset into base nativeDataPtr
  internal var dataOffset: UInt64 { _dataOffset }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialTextureMipData.self)
  }
}

///  Mip-map data for a texture that has mip-map representations.
internal struct Unity_PolySpatial_Internals_PolySpatialTextureMipData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var index: Int32 { return _accessor.readBuffer(of: Int32.self, at: 0) }
  internal var width: Int32 { return _accessor.readBuffer(of: Int32.self, at: 4) }
  internal var height: Int32 { return _accessor.readBuffer(of: Int32.self, at: 8) }
  internal var bytesPerRow: Int32 { return _accessor.readBuffer(of: Int32.self, at: 12) }
  internal var bytesPerImage: Int32 { return _accessor.readBuffer(of: Int32.self, at: 16) }
  internal var dataSize: UInt32 { return _accessor.readBuffer(of: UInt32.self, at: 20) }
  internal var dataOffset: UInt64 { return _accessor.readBuffer(of: UInt64.self, at: 24) }
}

///  Describes a texture that has already been uploaded to the GPU (and thus has a native texture
///  pointer--e.g., an id<MTLTexture>).
internal struct Unity_PolySpatial_Internals_PolySpatialNativeTextureData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  If true, this texture is expected to change every frame and we should optimize accordingly
  ///  (e.g., by using the DrawableQueue API in RealityKit).
  private var _isStreaming: Bool
  private let padding0__: UInt8 = 0
  private let padding1__: UInt16 = 0
  private var _shape: Int32
  private var _width: Int32
  private var _height: Int32
  private var _depth: Int32
  private var _filterMode: Int32
  private var _wrapModeU: Int32
  private var _wrapModeV: Int32
  private var _wrapModeW: Int32
  private var _mipCount: Int32
  private var _unityGraphicsFormat: UInt32
  private let padding2__: UInt32 = 0
  private var _nativeTexturePtr: UInt64

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _isStreaming = _accessor.readBuffer(of: Bool.self, at: 0)
    _shape = _accessor.readBuffer(of: Int32.self, at: 4)
    _width = _accessor.readBuffer(of: Int32.self, at: 8)
    _height = _accessor.readBuffer(of: Int32.self, at: 12)
    _depth = _accessor.readBuffer(of: Int32.self, at: 16)
    _filterMode = _accessor.readBuffer(of: Int32.self, at: 20)
    _wrapModeU = _accessor.readBuffer(of: Int32.self, at: 24)
    _wrapModeV = _accessor.readBuffer(of: Int32.self, at: 28)
    _wrapModeW = _accessor.readBuffer(of: Int32.self, at: 32)
    _mipCount = _accessor.readBuffer(of: Int32.self, at: 36)
    _unityGraphicsFormat = _accessor.readBuffer(of: UInt32.self, at: 40)
    _nativeTexturePtr = _accessor.readBuffer(of: UInt64.self, at: 48)
  }

  internal init(isStreaming: Bool, shape: Unity_PolySpatial_Internals_PolySpatialTextureShape, width: Int32, height: Int32, depth: Int32, filterMode: Unity_PolySpatial_Internals_PolySpatialTextureFilterMode, wrapModeU: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode, wrapModeV: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode, wrapModeW: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode, mipCount: Int32, unityGraphicsFormat: UInt32, nativeTexturePtr: UInt64) {
    _isStreaming = isStreaming
    _shape = shape.value
    _width = width
    _height = height
    _depth = depth
    _filterMode = filterMode.value
    _wrapModeU = wrapModeU.value
    _wrapModeV = wrapModeV.value
    _wrapModeW = wrapModeW.value
    _mipCount = mipCount
    _unityGraphicsFormat = unityGraphicsFormat
    _nativeTexturePtr = nativeTexturePtr
  }

  internal init() {
    _isStreaming = false
    _shape = 0
    _width = 0
    _height = 0
    _depth = 0
    _filterMode = 0
    _wrapModeU = 0
    _wrapModeV = 0
    _wrapModeW = 0
    _mipCount = 0
    _unityGraphicsFormat = 0
    _nativeTexturePtr = 0
  }

  ///  If true, this texture is expected to change every frame and we should optimize accordingly
  ///  (e.g., by using the DrawableQueue API in RealityKit).
  internal var isStreaming: Bool { _isStreaming }
  internal var shape: Unity_PolySpatial_Internals_PolySpatialTextureShape { Unity_PolySpatial_Internals_PolySpatialTextureShape(rawValue: _shape)! }
  internal var width: Int32 { _width }
  internal var height: Int32 { _height }
  internal var depth: Int32 { _depth }
  internal var filterMode: Unity_PolySpatial_Internals_PolySpatialTextureFilterMode { Unity_PolySpatial_Internals_PolySpatialTextureFilterMode(rawValue: _filterMode)! }
  internal var wrapModeU: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode { Unity_PolySpatial_Internals_PolySpatialTextureWrapMode(rawValue: _wrapModeU)! }
  internal var wrapModeV: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode { Unity_PolySpatial_Internals_PolySpatialTextureWrapMode(rawValue: _wrapModeV)! }
  internal var wrapModeW: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode { Unity_PolySpatial_Internals_PolySpatialTextureWrapMode(rawValue: _wrapModeW)! }
  internal var mipCount: Int32 { _mipCount }
  internal var unityGraphicsFormat: UInt32 { _unityGraphicsFormat }
  internal var nativeTexturePtr: UInt64 { _nativeTexturePtr }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialNativeTextureData.self)
  }
}

///  Describes a texture that has already been uploaded to the GPU (and thus has a native texture
///  pointer--e.g., an id<MTLTexture>).
internal struct Unity_PolySpatial_Internals_PolySpatialNativeTextureData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var isStreaming: Bool { return _accessor.readBuffer(of: Bool.self, at: 0) }
  internal var shape: Unity_PolySpatial_Internals_PolySpatialTextureShape { return Unity_PolySpatial_Internals_PolySpatialTextureShape(rawValue: _accessor.readBuffer(of: Int32.self, at: 4)) ?? .texture2D }
  internal var width: Int32 { return _accessor.readBuffer(of: Int32.self, at: 8) }
  internal var height: Int32 { return _accessor.readBuffer(of: Int32.self, at: 12) }
  internal var depth: Int32 { return _accessor.readBuffer(of: Int32.self, at: 16) }
  internal var filterMode: Unity_PolySpatial_Internals_PolySpatialTextureFilterMode { return Unity_PolySpatial_Internals_PolySpatialTextureFilterMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 20)) ?? .point }
  internal var wrapModeU: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode { return Unity_PolySpatial_Internals_PolySpatialTextureWrapMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 24)) ?? .repeat_ }
  internal var wrapModeV: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode { return Unity_PolySpatial_Internals_PolySpatialTextureWrapMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 28)) ?? .repeat_ }
  internal var wrapModeW: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode { return Unity_PolySpatial_Internals_PolySpatialTextureWrapMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 32)) ?? .repeat_ }
  internal var mipCount: Int32 { return _accessor.readBuffer(of: Int32.self, at: 36) }
  internal var unityGraphicsFormat: UInt32 { return _accessor.readBuffer(of: UInt32.self, at: 40) }
  internal var nativeTexturePtr: UInt64 { return _accessor.readBuffer(of: UInt64.self, at: 48) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialTextureId: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _isRenderTexture: Bool
  private let padding0__: UInt8 = 0
  private let padding1__: UInt16 = 0
  private let padding2__: UInt32 = 0
  ///  The PolySpatialAssetID that maps to the texture that should be used
  ///  to get the actual texture resource.
  private var _id: Unity_PolySpatial_Internals_PolySpatialAssetID

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _isRenderTexture = _accessor.readBuffer(of: Bool.self, at: 0)
    _id = Unity_PolySpatial_Internals_PolySpatialAssetID(_accessor.bb, o: _accessor.postion + 8)
  }

  internal init(isRenderTexture: Bool, id: Unity_PolySpatial_Internals_PolySpatialAssetID) {
    _isRenderTexture = isRenderTexture
    _id = id
  }

  internal init() {
    _isRenderTexture = false
    _id = Unity_PolySpatial_Internals_PolySpatialAssetID()
  }

  internal var isRenderTexture: Bool { _isRenderTexture }
  ///  The PolySpatialAssetID that maps to the texture that should be used
  ///  to get the actual texture resource.
  internal var id: Unity_PolySpatial_Internals_PolySpatialAssetID { _id }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialTextureId.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialTextureId_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var isRenderTexture: Bool { return _accessor.readBuffer(of: Bool.self, at: 0) }
  internal var id: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable { return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.postion + 8) }
}

///  Information about a texture resource.
internal struct Unity_PolySpatial_Internals_PolySpatialTexture: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _textureId: Unity_PolySpatial_Internals_PolySpatialTextureId

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _textureId = Unity_PolySpatial_Internals_PolySpatialTextureId(_accessor.bb, o: _accessor.postion + 0)
  }

  internal init(textureId: Unity_PolySpatial_Internals_PolySpatialTextureId) {
    _textureId = textureId
  }

  internal init() {
    _textureId = Unity_PolySpatial_Internals_PolySpatialTextureId()
  }

  internal var textureId: Unity_PolySpatial_Internals_PolySpatialTextureId { _textureId }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialTexture.self)
  }
}

///  Information about a texture resource.
internal struct Unity_PolySpatial_Internals_PolySpatialTexture_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var textureId: Unity_PolySpatial_Internals_PolySpatialTextureId_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureId_Mutable(_accessor.bb, o: _accessor.postion + 0) }
}

///  Information about a texture resource that can also describe it's content using
///  a scalar value. An example would be an alpha map described as a texture or just a
///  simple alpha value.
///  Value are not mutually exclusive, and use is left up to the platform.
internal struct Unity_PolySpatial_Internals_PolySpatialTextureScalar: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  A scalar value that can be used to represent the entirety of a "texture".
  ///  E.g. An alpha value instead of an alpha map.
  private var _scalar: Float32
  private let padding0__: UInt32 = 0
  ///  An actual texture resource to be used. E.g. An alpha map texture.
  private var _textureId: Unity_PolySpatial_Internals_PolySpatialTextureId

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _scalar = _accessor.readBuffer(of: Float32.self, at: 0)
    _textureId = Unity_PolySpatial_Internals_PolySpatialTextureId(_accessor.bb, o: _accessor.postion + 8)
  }

  internal init(scalar: Float32, textureId: Unity_PolySpatial_Internals_PolySpatialTextureId) {
    _scalar = scalar
    _textureId = textureId
  }

  internal init() {
    _scalar = 0.0
    _textureId = Unity_PolySpatial_Internals_PolySpatialTextureId()
  }

  ///  A scalar value that can be used to represent the entirety of a "texture".
  ///  E.g. An alpha value instead of an alpha map.
  internal var scalar: Float32 { _scalar }
  ///  An actual texture resource to be used. E.g. An alpha map texture.
  internal var textureId: Unity_PolySpatial_Internals_PolySpatialTextureId { _textureId }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialTextureScalar.self)
  }
}

///  Information about a texture resource that can also describe it's content using
///  a scalar value. An example would be an alpha map described as a texture or just a
///  simple alpha value.
///  Value are not mutually exclusive, and use is left up to the platform.
internal struct Unity_PolySpatial_Internals_PolySpatialTextureScalar_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var scalar: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  internal var textureId: Unity_PolySpatial_Internals_PolySpatialTextureId_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureId_Mutable(_accessor.bb, o: _accessor.postion + 8) }
}

///  Information about a texture resource that can also describe it's content using
///  a color value. An example would be an tinting texture described as a texture or just a
///  simple color value.
///  Value are not mutually exclusive, and use is left up to the platform.
internal struct Unity_PolySpatial_Internals_PolySpatialTextureColor: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  A color value that can be used to represent the entirety of a "texture".
  private var _color: UnityEngine_Color32
  private let padding0__: UInt32 = 0
  ///  An actual texture resource to be used. E.g. A normal map texture.
  private var _textureId: Unity_PolySpatial_Internals_PolySpatialTextureId

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _color = UnityEngine_Color32(_accessor.bb, o: _accessor.postion + 0)
    _textureId = Unity_PolySpatial_Internals_PolySpatialTextureId(_accessor.bb, o: _accessor.postion + 8)
  }

  internal init(color: UnityEngine_Color32, textureId: Unity_PolySpatial_Internals_PolySpatialTextureId) {
    _color = color
    _textureId = textureId
  }

  internal init() {
    _color = UnityEngine_Color32()
    _textureId = Unity_PolySpatial_Internals_PolySpatialTextureId()
  }

  ///  A color value that can be used to represent the entirety of a "texture".
  internal var color: UnityEngine_Color32 { _color }
  ///  An actual texture resource to be used. E.g. A normal map texture.
  internal var textureId: Unity_PolySpatial_Internals_PolySpatialTextureId { _textureId }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialTextureColor.self)
  }
}

///  Information about a texture resource that can also describe it's content using
///  a color value. An example would be an tinting texture described as a texture or just a
///  simple color value.
///  Value are not mutually exclusive, and use is left up to the platform.
internal struct Unity_PolySpatial_Internals_PolySpatialTextureColor_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var color: UnityEngine_Color32_Mutable { return UnityEngine_Color32_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var textureId: Unity_PolySpatial_Internals_PolySpatialTextureId_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureId_Mutable(_accessor.bb, o: _accessor.postion + 8) }
}

///  Contains the opacity threshold state: whether to enable alpha clipping and the threshold value.
internal struct Unity_PolySpatial_Internals_PolySpatialOpacityThreshold: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  Whether or not alpha clipping is enabled.
  private var _isEnabled: Bool
  private let padding0__: UInt8 = 0
  private let padding1__: UInt16 = 0
  ///  The threshold value for alpha clipping.  If enabled, fragments with opacity less than this will be discarded.
  private var _value: Float32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _isEnabled = _accessor.readBuffer(of: Bool.self, at: 0)
    _value = _accessor.readBuffer(of: Float32.self, at: 4)
  }

  internal init(isEnabled: Bool, value: Float32) {
    _isEnabled = isEnabled
    _value = value
  }

  internal init() {
    _isEnabled = false
    _value = 0.0
  }

  ///  Whether or not alpha clipping is enabled.
  internal var isEnabled: Bool { _isEnabled }
  ///  The threshold value for alpha clipping.  If enabled, fragments with opacity less than this will be discarded.
  internal var value: Float32 { _value }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold.self)
  }
}

///  Contains the opacity threshold state: whether to enable alpha clipping and the threshold value.
internal struct Unity_PolySpatial_Internals_PolySpatialOpacityThreshold_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var isEnabled: Bool { return _accessor.readBuffer(of: Bool.self, at: 0) }
  internal var value: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
}

///  Definition of an Occlusion material in the PolySpatial system.
internal struct Unity_PolySpatial_Internals_PolySpatialOcclusionMaterial: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  Determines if the occlusion material recieves shadows or not.
  private var _receivesShadows: Bool

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _receivesShadows = _accessor.readBuffer(of: Bool.self, at: 0)
  }

  internal init(receivesShadows: Bool) {
    _receivesShadows = receivesShadows
  }

  internal init() {
    _receivesShadows = false
  }

  ///  Determines if the occlusion material recieves shadows or not.
  internal var receivesShadows: Bool { _receivesShadows }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialOcclusionMaterial.self)
  }
}

///  Definition of an Occlusion material in the PolySpatial system.
internal struct Unity_PolySpatial_Internals_PolySpatialOcclusionMaterial_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var receivesShadows: Bool { return _accessor.readBuffer(of: Bool.self, at: 0) }
}

///  Definition of an Unlit material in the PolySpatial system.
internal struct Unity_PolySpatial_Internals_PolySpatialUnlitMaterial: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  Defines the base color for the material.
  private var _baseColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor
  ///  Defines the face culling mode used to render any mesh using this material.
  private var _cullMode: Int32
  ///  Used to set if this material requires special handling for transparency
  ///  rendering.
  private var _isTransparent: Bool
  ///  Should GPU instancing be enabled or not.
  private var _enableInstancing: Bool
  private let padding0__: UInt16 = 0
  ///  The relative rendering priority for this material.
  private var _priority: Int32
  ///  The opacity level of this material. Used to blend the material with the background.
  ///  This is a value between 0 and 1, where 0 is fully transparent and 1 is fully opaque.
  private var _opacity: Float32
  ///  The opacity threshold of this material.
  private var _opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold
  ///  The blending mode used when blending non-opaque materials.
  private var _blendingMode: Int32
  ///  The scale of the texture in the material.
  private var _scale: UnityEngine_Vector2
  ///  The offset of the main texture.
  private var _offset: UnityEngine_Vector2
  private var __Padding: UInt32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _baseColorMap = Unity_PolySpatial_Internals_PolySpatialTextureColor(_accessor.bb, o: _accessor.postion + 0)
    _cullMode = _accessor.readBuffer(of: Int32.self, at: 40)
    _isTransparent = _accessor.readBuffer(of: Bool.self, at: 44)
    _enableInstancing = _accessor.readBuffer(of: Bool.self, at: 45)
    _priority = _accessor.readBuffer(of: Int32.self, at: 48)
    _opacity = _accessor.readBuffer(of: Float32.self, at: 52)
    _opacityThreshold = Unity_PolySpatial_Internals_PolySpatialOpacityThreshold(_accessor.bb, o: _accessor.postion + 56)
    _blendingMode = _accessor.readBuffer(of: Int32.self, at: 64)
    _scale = UnityEngine_Vector2(_accessor.bb, o: _accessor.postion + 68)
    _offset = UnityEngine_Vector2(_accessor.bb, o: _accessor.postion + 76)
    __Padding = _accessor.readBuffer(of: UInt32.self, at: 84)
  }

  internal init(baseColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor, cullMode: Unity_PolySpatial_Internals_PolySpatialCullMode, isTransparent: Bool, enableInstancing: Bool, priority: Int32, opacity: Float32, opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold, blendingMode: Unity_PolySpatial_Internals_PolySpatialBlendingMode, scale: UnityEngine_Vector2, offset: UnityEngine_Vector2, _Padding: UInt32) {
    _baseColorMap = baseColorMap
    _cullMode = cullMode.value
    _isTransparent = isTransparent
    _enableInstancing = enableInstancing
    _priority = priority
    _opacity = opacity
    _opacityThreshold = opacityThreshold
    _blendingMode = blendingMode.value
    _scale = scale
    _offset = offset
    __Padding = _Padding
  }

  internal init() {
    _baseColorMap = Unity_PolySpatial_Internals_PolySpatialTextureColor()
    _cullMode = 0
    _isTransparent = false
    _enableInstancing = false
    _priority = 0
    _opacity = 0.0
    _opacityThreshold = Unity_PolySpatial_Internals_PolySpatialOpacityThreshold()
    _blendingMode = 0
    _scale = UnityEngine_Vector2()
    _offset = UnityEngine_Vector2()
    __Padding = 0
  }

  ///  Defines the base color for the material.
  internal var baseColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor { _baseColorMap }
  ///  Defines the face culling mode used to render any mesh using this material.
  internal var cullMode: Unity_PolySpatial_Internals_PolySpatialCullMode { Unity_PolySpatial_Internals_PolySpatialCullMode(rawValue: _cullMode)! }
  ///  Used to set if this material requires special handling for transparency
  ///  rendering.
  internal var isTransparent: Bool { _isTransparent }
  ///  Should GPU instancing be enabled or not.
  internal var enableInstancing: Bool { _enableInstancing }
  ///  The relative rendering priority for this material.
  internal var priority: Int32 { _priority }
  ///  The opacity level of this material. Used to blend the material with the background.
  ///  This is a value between 0 and 1, where 0 is fully transparent and 1 is fully opaque.
  internal var opacity: Float32 { _opacity }
  ///  The opacity threshold of this material.
  internal var opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold { _opacityThreshold }
  ///  The blending mode used when blending non-opaque materials.
  internal var blendingMode: Unity_PolySpatial_Internals_PolySpatialBlendingMode { Unity_PolySpatial_Internals_PolySpatialBlendingMode(rawValue: _blendingMode)! }
  ///  The scale of the texture in the material.
  internal var scale: UnityEngine_Vector2 { _scale }
  ///  The offset of the main texture.
  internal var offset: UnityEngine_Vector2 { _offset }
  internal var _Padding: UInt32 { __Padding }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialUnlitMaterial.self)
  }
}

///  Definition of an Unlit material in the PolySpatial system.
internal struct Unity_PolySpatial_Internals_PolySpatialUnlitMaterial_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var baseColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureColor_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var cullMode: Unity_PolySpatial_Internals_PolySpatialCullMode { return Unity_PolySpatial_Internals_PolySpatialCullMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 40)) ?? .none_ }
  internal var isTransparent: Bool { return _accessor.readBuffer(of: Bool.self, at: 44) }
  internal var enableInstancing: Bool { return _accessor.readBuffer(of: Bool.self, at: 45) }
  internal var priority: Int32 { return _accessor.readBuffer(of: Int32.self, at: 48) }
  internal var opacity: Float32 { return _accessor.readBuffer(of: Float32.self, at: 52) }
  internal var opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold_Mutable { return Unity_PolySpatial_Internals_PolySpatialOpacityThreshold_Mutable(_accessor.bb, o: _accessor.postion + 56) }
  internal var blendingMode: Unity_PolySpatial_Internals_PolySpatialBlendingMode { return Unity_PolySpatial_Internals_PolySpatialBlendingMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 64)) ?? .alpha }
  internal var scale: UnityEngine_Vector2_Mutable { return UnityEngine_Vector2_Mutable(_accessor.bb, o: _accessor.postion + 68) }
  internal var offset: UnityEngine_Vector2_Mutable { return UnityEngine_Vector2_Mutable(_accessor.bb, o: _accessor.postion + 76) }
  internal var _Padding: UInt32 { return _accessor.readBuffer(of: UInt32.self, at: 84) }
}

///  Definition of a lit particle material in the PolySpatial system.
internal struct Unity_PolySpatial_Internals_PolySpatialLitParticleMaterial: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _baseColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor
  private var _blendingMode: Int32
  private var _colorMode: Int32
  ///  Defines the emissive color for the material.
  private var _emissiveColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor
  private var _isTransparent: Bool
  ///  Should GPU instancing be enabled or not.
  private var _enableInstancing: Bool
  private let padding0__: UInt16 = 0
  private let padding1__: UInt32 = 0
  ///  Defines the metallic color for the material.
  private var _metallicMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar
  ///  Defines the normal map for the material.
  private var _normalMap: Unity_PolySpatial_Internals_PolySpatialTexture
  private var _opacity: Float32
  private var _opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold
  private var _smoothness: Float32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _baseColorMap = Unity_PolySpatial_Internals_PolySpatialTextureColor(_accessor.bb, o: _accessor.postion + 0)
    _blendingMode = _accessor.readBuffer(of: Int32.self, at: 40)
    _colorMode = _accessor.readBuffer(of: Int32.self, at: 44)
    _emissiveColorMap = Unity_PolySpatial_Internals_PolySpatialTextureColor(_accessor.bb, o: _accessor.postion + 48)
    _isTransparent = _accessor.readBuffer(of: Bool.self, at: 88)
    _enableInstancing = _accessor.readBuffer(of: Bool.self, at: 89)
    _metallicMap = Unity_PolySpatial_Internals_PolySpatialTextureScalar(_accessor.bb, o: _accessor.postion + 96)
    _normalMap = Unity_PolySpatial_Internals_PolySpatialTexture(_accessor.bb, o: _accessor.postion + 136)
    _opacity = _accessor.readBuffer(of: Float32.self, at: 168)
    _opacityThreshold = Unity_PolySpatial_Internals_PolySpatialOpacityThreshold(_accessor.bb, o: _accessor.postion + 172)
    _smoothness = _accessor.readBuffer(of: Float32.self, at: 180)
  }

  internal init(baseColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor, blendingMode: Unity_PolySpatial_Internals_PolySpatialBlendingMode, colorMode: Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode, emissiveColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor, isTransparent: Bool, enableInstancing: Bool, metallicMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar, normalMap: Unity_PolySpatial_Internals_PolySpatialTexture, opacity: Float32, opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold, smoothness: Float32) {
    _baseColorMap = baseColorMap
    _blendingMode = blendingMode.value
    _colorMode = colorMode.value
    _emissiveColorMap = emissiveColorMap
    _isTransparent = isTransparent
    _enableInstancing = enableInstancing
    _metallicMap = metallicMap
    _normalMap = normalMap
    _opacity = opacity
    _opacityThreshold = opacityThreshold
    _smoothness = smoothness
  }

  internal init() {
    _baseColorMap = Unity_PolySpatial_Internals_PolySpatialTextureColor()
    _blendingMode = 0
    _colorMode = 0
    _emissiveColorMap = Unity_PolySpatial_Internals_PolySpatialTextureColor()
    _isTransparent = false
    _enableInstancing = false
    _metallicMap = Unity_PolySpatial_Internals_PolySpatialTextureScalar()
    _normalMap = Unity_PolySpatial_Internals_PolySpatialTexture()
    _opacity = 0.0
    _opacityThreshold = Unity_PolySpatial_Internals_PolySpatialOpacityThreshold()
    _smoothness = 0.0
  }

  internal var baseColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor { _baseColorMap }
  internal var blendingMode: Unity_PolySpatial_Internals_PolySpatialBlendingMode { Unity_PolySpatial_Internals_PolySpatialBlendingMode(rawValue: _blendingMode)! }
  internal var colorMode: Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode { Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode(rawValue: _colorMode)! }
  ///  Defines the emissive color for the material.
  internal var emissiveColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor { _emissiveColorMap }
  internal var isTransparent: Bool { _isTransparent }
  ///  Should GPU instancing be enabled or not.
  internal var enableInstancing: Bool { _enableInstancing }
  ///  Defines the metallic color for the material.
  internal var metallicMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar { _metallicMap }
  ///  Defines the normal map for the material.
  internal var normalMap: Unity_PolySpatial_Internals_PolySpatialTexture { _normalMap }
  internal var opacity: Float32 { _opacity }
  internal var opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold { _opacityThreshold }
  internal var smoothness: Float32 { _smoothness }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialLitParticleMaterial.self)
  }
}

///  Definition of a lit particle material in the PolySpatial system.
internal struct Unity_PolySpatial_Internals_PolySpatialLitParticleMaterial_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var baseColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureColor_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var blendingMode: Unity_PolySpatial_Internals_PolySpatialBlendingMode { return Unity_PolySpatial_Internals_PolySpatialBlendingMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 40)) ?? .alpha }
  internal var colorMode: Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode { return Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 44)) ?? .multiply }
  internal var emissiveColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureColor_Mutable(_accessor.bb, o: _accessor.postion + 48) }
  internal var isTransparent: Bool { return _accessor.readBuffer(of: Bool.self, at: 88) }
  internal var enableInstancing: Bool { return _accessor.readBuffer(of: Bool.self, at: 89) }
  internal var metallicMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureScalar_Mutable(_accessor.bb, o: _accessor.postion + 96) }
  internal var normalMap: Unity_PolySpatial_Internals_PolySpatialTexture_Mutable { return Unity_PolySpatial_Internals_PolySpatialTexture_Mutable(_accessor.bb, o: _accessor.postion + 136) }
  internal var opacity: Float32 { return _accessor.readBuffer(of: Float32.self, at: 168) }
  internal var opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold_Mutable { return Unity_PolySpatial_Internals_PolySpatialOpacityThreshold_Mutable(_accessor.bb, o: _accessor.postion + 172) }
  internal var smoothness: Float32 { return _accessor.readBuffer(of: Float32.self, at: 180) }
}

///  Definition of a particle material in the PolySpatial system.
internal struct Unity_PolySpatial_Internals_PolySpatialUnlitParticleMaterial: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _baseColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor
  private var _blendingMode: Int32
  private var _colorMode: Int32
  private var _isTransparent: Bool
  ///  Should GPU instancing be enabled or not.
  private var _enableInstancing: Bool
  private let padding0__: UInt16 = 0
  private var _opacity: Float32
  private var _opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _baseColorMap = Unity_PolySpatial_Internals_PolySpatialTextureColor(_accessor.bb, o: _accessor.postion + 0)
    _blendingMode = _accessor.readBuffer(of: Int32.self, at: 40)
    _colorMode = _accessor.readBuffer(of: Int32.self, at: 44)
    _isTransparent = _accessor.readBuffer(of: Bool.self, at: 48)
    _enableInstancing = _accessor.readBuffer(of: Bool.self, at: 49)
    _opacity = _accessor.readBuffer(of: Float32.self, at: 52)
    _opacityThreshold = Unity_PolySpatial_Internals_PolySpatialOpacityThreshold(_accessor.bb, o: _accessor.postion + 56)
  }

  internal init(baseColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor, blendingMode: Unity_PolySpatial_Internals_PolySpatialBlendingMode, colorMode: Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode, isTransparent: Bool, enableInstancing: Bool, opacity: Float32, opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold) {
    _baseColorMap = baseColorMap
    _blendingMode = blendingMode.value
    _colorMode = colorMode.value
    _isTransparent = isTransparent
    _enableInstancing = enableInstancing
    _opacity = opacity
    _opacityThreshold = opacityThreshold
  }

  internal init() {
    _baseColorMap = Unity_PolySpatial_Internals_PolySpatialTextureColor()
    _blendingMode = 0
    _colorMode = 0
    _isTransparent = false
    _enableInstancing = false
    _opacity = 0.0
    _opacityThreshold = Unity_PolySpatial_Internals_PolySpatialOpacityThreshold()
  }

  internal var baseColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor { _baseColorMap }
  internal var blendingMode: Unity_PolySpatial_Internals_PolySpatialBlendingMode { Unity_PolySpatial_Internals_PolySpatialBlendingMode(rawValue: _blendingMode)! }
  internal var colorMode: Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode { Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode(rawValue: _colorMode)! }
  internal var isTransparent: Bool { _isTransparent }
  ///  Should GPU instancing be enabled or not.
  internal var enableInstancing: Bool { _enableInstancing }
  internal var opacity: Float32 { _opacity }
  internal var opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold { _opacityThreshold }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialUnlitParticleMaterial.self)
  }
}

///  Definition of a particle material in the PolySpatial system.
internal struct Unity_PolySpatial_Internals_PolySpatialUnlitParticleMaterial_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var baseColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureColor_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var blendingMode: Unity_PolySpatial_Internals_PolySpatialBlendingMode { return Unity_PolySpatial_Internals_PolySpatialBlendingMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 40)) ?? .alpha }
  internal var colorMode: Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode { return Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 44)) ?? .multiply }
  internal var isTransparent: Bool { return _accessor.readBuffer(of: Bool.self, at: 48) }
  internal var enableInstancing: Bool { return _accessor.readBuffer(of: Bool.self, at: 49) }
  internal var opacity: Float32 { return _accessor.readBuffer(of: Float32.self, at: 52) }
  internal var opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold_Mutable { return Unity_PolySpatial_Internals_PolySpatialOpacityThreshold_Mutable(_accessor.bb, o: _accessor.postion + 56) }
}

///  Representation of a texture map resource.
internal struct Unity_PolySpatial_Internals_PolySpatialTextureMapData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  Simple boolean declaring if this map is enabled and intended to be used by the underlying rendering layer.
  private var _isEnabled: Bool
  private let padding0__: UInt8 = 0
  private let padding1__: UInt16 = 0
  private let padding2__: UInt32 = 0
  ///  The texture asset id for the resource we want to actually use.
  private var _assetId: Unity_PolySpatial_Internals_PolySpatialTextureId

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _isEnabled = _accessor.readBuffer(of: Bool.self, at: 0)
    _assetId = Unity_PolySpatial_Internals_PolySpatialTextureId(_accessor.bb, o: _accessor.postion + 8)
  }

  internal init(isEnabled: Bool, assetId: Unity_PolySpatial_Internals_PolySpatialTextureId) {
    _isEnabled = isEnabled
    _assetId = assetId
  }

  internal init() {
    _isEnabled = false
    _assetId = Unity_PolySpatial_Internals_PolySpatialTextureId()
  }

  ///  Simple boolean declaring if this map is enabled and intended to be used by the underlying rendering layer.
  internal var isEnabled: Bool { _isEnabled }
  ///  The texture asset id for the resource we want to actually use.
  internal var assetId: Unity_PolySpatial_Internals_PolySpatialTextureId { _assetId }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialTextureMapData.self)
  }
}

///  Representation of a texture map resource.
internal struct Unity_PolySpatial_Internals_PolySpatialTextureMapData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var isEnabled: Bool { return _accessor.readBuffer(of: Bool.self, at: 0) }
  internal var assetId: Unity_PolySpatial_Internals_PolySpatialTextureId_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureId_Mutable(_accessor.bb, o: _accessor.postion + 8) }
}

///  Representation of a map that contains either a texture resource or a scalar value.
internal struct Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  Simple boolean declaring if this map is enabled and intended to be used by the underlying rendering layer.
  private var _isEnabled: Bool
  private let padding0__: UInt8 = 0
  private let padding1__: UInt16 = 0
  private let padding2__: UInt32 = 0
  ///  The texture asset id for the resource we want to actually use.
  private var _assetId: Unity_PolySpatial_Internals_PolySpatialTextureId
  ///  The scalar value to be used if the asset id for the texture is undefined.
  private var _scalar: Float32
  private var __Padding: UInt32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _isEnabled = _accessor.readBuffer(of: Bool.self, at: 0)
    _assetId = Unity_PolySpatial_Internals_PolySpatialTextureId(_accessor.bb, o: _accessor.postion + 8)
    _scalar = _accessor.readBuffer(of: Float32.self, at: 40)
    __Padding = _accessor.readBuffer(of: UInt32.self, at: 44)
  }

  internal init(isEnabled: Bool, assetId: Unity_PolySpatial_Internals_PolySpatialTextureId, scalar: Float32, _Padding: UInt32) {
    _isEnabled = isEnabled
    _assetId = assetId
    _scalar = scalar
    __Padding = _Padding
  }

  internal init() {
    _isEnabled = false
    _assetId = Unity_PolySpatial_Internals_PolySpatialTextureId()
    _scalar = 0.0
    __Padding = 0
  }

  ///  Simple boolean declaring if this map is enabled and intended to be used by the underlying rendering layer.
  internal var isEnabled: Bool { _isEnabled }
  ///  The texture asset id for the resource we want to actually use.
  internal var assetId: Unity_PolySpatial_Internals_PolySpatialTextureId { _assetId }
  ///  The scalar value to be used if the asset id for the texture is undefined.
  internal var scalar: Float32 { _scalar }
  internal var _Padding: UInt32 { __Padding }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData.self)
  }
}

///  Representation of a map that contains either a texture resource or a scalar value.
internal struct Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var isEnabled: Bool { return _accessor.readBuffer(of: Bool.self, at: 0) }
  internal var assetId: Unity_PolySpatial_Internals_PolySpatialTextureId_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureId_Mutable(_accessor.bb, o: _accessor.postion + 8) }
  internal var scalar: Float32 { return _accessor.readBuffer(of: Float32.self, at: 40) }
  internal var _Padding: UInt32 { return _accessor.readBuffer(of: UInt32.self, at: 44) }
}

///  Representation of a map that contains either a texture resource or a color value.
internal struct Unity_PolySpatial_Internals_PolySpatialColorTextureMapData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  Simple boolean declaring if this map is enabled and intended to be used by the underlying rendering layer.
  private var _isEnabled: Bool
  private let padding0__: UInt8 = 0
  private let padding1__: UInt16 = 0
  private let padding2__: UInt32 = 0
  ///  The texture asset id for the resource we want to actually use.
  private var _assetId: Unity_PolySpatial_Internals_PolySpatialTextureId
  ///  The color value to be used if the asset id for the texture is undefined.
  private var _color: UnityEngine_Color

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _isEnabled = _accessor.readBuffer(of: Bool.self, at: 0)
    _assetId = Unity_PolySpatial_Internals_PolySpatialTextureId(_accessor.bb, o: _accessor.postion + 8)
    _color = UnityEngine_Color(_accessor.bb, o: _accessor.postion + 40)
  }

  internal init(isEnabled: Bool, assetId: Unity_PolySpatial_Internals_PolySpatialTextureId, color: UnityEngine_Color) {
    _isEnabled = isEnabled
    _assetId = assetId
    _color = color
  }

  internal init() {
    _isEnabled = false
    _assetId = Unity_PolySpatial_Internals_PolySpatialTextureId()
    _color = UnityEngine_Color()
  }

  ///  Simple boolean declaring if this map is enabled and intended to be used by the underlying rendering layer.
  internal var isEnabled: Bool { _isEnabled }
  ///  The texture asset id for the resource we want to actually use.
  internal var assetId: Unity_PolySpatial_Internals_PolySpatialTextureId { _assetId }
  ///  The color value to be used if the asset id for the texture is undefined.
  internal var color: UnityEngine_Color { _color }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialColorTextureMapData.self)
  }
}

///  Representation of a map that contains either a texture resource or a color value.
internal struct Unity_PolySpatial_Internals_PolySpatialColorTextureMapData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var isEnabled: Bool { return _accessor.readBuffer(of: Bool.self, at: 0) }
  internal var assetId: Unity_PolySpatial_Internals_PolySpatialTextureId_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureId_Mutable(_accessor.bb, o: _accessor.postion + 8) }
  internal var color: UnityEngine_Color_Mutable { return UnityEngine_Color_Mutable(_accessor.bb, o: _accessor.postion + 40) }
}

///  Definition of a Physically Based Rendering material.
internal struct Unity_PolySpatial_Internals_PolySpatialPBRMaterial: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  Defines the base color for the material.
  private var _baseColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor
  ///  Defines the specular color for the material.
  private var _specularMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar
  ///  Defines the roughness color for the material.
  private var _roughnessMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar
  ///  Defines the metallic color for the material.
  private var _metallicMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar
  ///  Defines the normal color for the material.
  private var _normalMap: Unity_PolySpatial_Internals_PolySpatialTexture
  ///  Defines the transparency color for the material.
  private var _transparencyMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar
  ///  Defines the emissive color for the material.
  private var _emissiveColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor
  ///  The intensity of the emissive color, if any.
  private var _emissiveIntensity: Float32
  private let padding0__: UInt32 = 0
  ///  Defines the ambient occlusion level for the material.
  private var _ambientOcclusionMap: Unity_PolySpatial_Internals_PolySpatialTexture
  ///  Defines the clearcoat level for the material.
  private var _clearcoatMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar
  ///  Defines the clearcoat roughness level for the material.
  private var _clearcoatRoughnessMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar
  ///  Defines the face culling mode used to render any mesh using this material.
  private var _cullMode: Int32
  ///  Used to set if this material requires special handling for transparency
  ///  rendering.
  private var _isTransparent: Bool
  ///  Determines if specular highlights will be preserved during rendering or not.
  private var _shouldPreserveSpecularHighlights: Bool
  private let padding1__: UInt16 = 0
  ///  The relative rendering priority for this material.
  private var _priority: Int32
  ///  The opacity level of this material. Used to blend the material with the background.
  ///  This is a value between 0 and 1, where 0 is fully transparent and 1 is fully opaque.
  private var _opacity: Float32
  ///  The opacity threshold of this material.
  private var _opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold
  ///  The blending mode used when blending non-opaque materials.
  private var _blendingMode: Int32
  ///  The scale of the texture in the material.
  private var _scale: UnityEngine_Vector2
  ///  The offset of the main texture.
  private var _offset: UnityEngine_Vector2
  ///  The surface rendering workflow to be used when rendering this
  ///  material.
  private var _workflow: Int32
  ///  Should GPU instancing be enabled or not.
  private var _enableInstancing: Bool
  private var __Padding0: UInt8
  private var __Padding1: UInt16
  private var __Padding2: UInt32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _baseColorMap = Unity_PolySpatial_Internals_PolySpatialTextureColor(_accessor.bb, o: _accessor.postion + 0)
    _specularMap = Unity_PolySpatial_Internals_PolySpatialTextureScalar(_accessor.bb, o: _accessor.postion + 40)
    _roughnessMap = Unity_PolySpatial_Internals_PolySpatialTextureScalar(_accessor.bb, o: _accessor.postion + 80)
    _metallicMap = Unity_PolySpatial_Internals_PolySpatialTextureScalar(_accessor.bb, o: _accessor.postion + 120)
    _normalMap = Unity_PolySpatial_Internals_PolySpatialTexture(_accessor.bb, o: _accessor.postion + 160)
    _transparencyMap = Unity_PolySpatial_Internals_PolySpatialTextureScalar(_accessor.bb, o: _accessor.postion + 192)
    _emissiveColorMap = Unity_PolySpatial_Internals_PolySpatialTextureColor(_accessor.bb, o: _accessor.postion + 232)
    _emissiveIntensity = _accessor.readBuffer(of: Float32.self, at: 272)
    _ambientOcclusionMap = Unity_PolySpatial_Internals_PolySpatialTexture(_accessor.bb, o: _accessor.postion + 280)
    _clearcoatMap = Unity_PolySpatial_Internals_PolySpatialTextureScalar(_accessor.bb, o: _accessor.postion + 312)
    _clearcoatRoughnessMap = Unity_PolySpatial_Internals_PolySpatialTextureScalar(_accessor.bb, o: _accessor.postion + 352)
    _cullMode = _accessor.readBuffer(of: Int32.self, at: 392)
    _isTransparent = _accessor.readBuffer(of: Bool.self, at: 396)
    _shouldPreserveSpecularHighlights = _accessor.readBuffer(of: Bool.self, at: 397)
    _priority = _accessor.readBuffer(of: Int32.self, at: 400)
    _opacity = _accessor.readBuffer(of: Float32.self, at: 404)
    _opacityThreshold = Unity_PolySpatial_Internals_PolySpatialOpacityThreshold(_accessor.bb, o: _accessor.postion + 408)
    _blendingMode = _accessor.readBuffer(of: Int32.self, at: 416)
    _scale = UnityEngine_Vector2(_accessor.bb, o: _accessor.postion + 420)
    _offset = UnityEngine_Vector2(_accessor.bb, o: _accessor.postion + 428)
    _workflow = _accessor.readBuffer(of: Int32.self, at: 436)
    _enableInstancing = _accessor.readBuffer(of: Bool.self, at: 440)
    __Padding0 = _accessor.readBuffer(of: UInt8.self, at: 441)
    __Padding1 = _accessor.readBuffer(of: UInt16.self, at: 442)
    __Padding2 = _accessor.readBuffer(of: UInt32.self, at: 444)
  }

  internal init(baseColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor, specularMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar, roughnessMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar, metallicMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar, normalMap: Unity_PolySpatial_Internals_PolySpatialTexture, transparencyMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar, emissiveColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor, emissiveIntensity: Float32, ambientOcclusionMap: Unity_PolySpatial_Internals_PolySpatialTexture, clearcoatMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar, clearcoatRoughnessMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar, cullMode: Unity_PolySpatial_Internals_PolySpatialCullMode, isTransparent: Bool, shouldPreserveSpecularHighlights: Bool, priority: Int32, opacity: Float32, opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold, blendingMode: Unity_PolySpatial_Internals_PolySpatialBlendingMode, scale: UnityEngine_Vector2, offset: UnityEngine_Vector2, workflow: Unity_PolySpatial_Internals_PolySpatialMaterialWorkflow, enableInstancing: Bool, _Padding0: UInt8, _Padding1: UInt16, _Padding2: UInt32) {
    _baseColorMap = baseColorMap
    _specularMap = specularMap
    _roughnessMap = roughnessMap
    _metallicMap = metallicMap
    _normalMap = normalMap
    _transparencyMap = transparencyMap
    _emissiveColorMap = emissiveColorMap
    _emissiveIntensity = emissiveIntensity
    _ambientOcclusionMap = ambientOcclusionMap
    _clearcoatMap = clearcoatMap
    _clearcoatRoughnessMap = clearcoatRoughnessMap
    _cullMode = cullMode.value
    _isTransparent = isTransparent
    _shouldPreserveSpecularHighlights = shouldPreserveSpecularHighlights
    _priority = priority
    _opacity = opacity
    _opacityThreshold = opacityThreshold
    _blendingMode = blendingMode.value
    _scale = scale
    _offset = offset
    _workflow = workflow.value
    _enableInstancing = enableInstancing
    __Padding0 = _Padding0
    __Padding1 = _Padding1
    __Padding2 = _Padding2
  }

  internal init() {
    _baseColorMap = Unity_PolySpatial_Internals_PolySpatialTextureColor()
    _specularMap = Unity_PolySpatial_Internals_PolySpatialTextureScalar()
    _roughnessMap = Unity_PolySpatial_Internals_PolySpatialTextureScalar()
    _metallicMap = Unity_PolySpatial_Internals_PolySpatialTextureScalar()
    _normalMap = Unity_PolySpatial_Internals_PolySpatialTexture()
    _transparencyMap = Unity_PolySpatial_Internals_PolySpatialTextureScalar()
    _emissiveColorMap = Unity_PolySpatial_Internals_PolySpatialTextureColor()
    _emissiveIntensity = 0.0
    _ambientOcclusionMap = Unity_PolySpatial_Internals_PolySpatialTexture()
    _clearcoatMap = Unity_PolySpatial_Internals_PolySpatialTextureScalar()
    _clearcoatRoughnessMap = Unity_PolySpatial_Internals_PolySpatialTextureScalar()
    _cullMode = 0
    _isTransparent = false
    _shouldPreserveSpecularHighlights = false
    _priority = 0
    _opacity = 0.0
    _opacityThreshold = Unity_PolySpatial_Internals_PolySpatialOpacityThreshold()
    _blendingMode = 0
    _scale = UnityEngine_Vector2()
    _offset = UnityEngine_Vector2()
    _workflow = 0
    _enableInstancing = false
    __Padding0 = 0
    __Padding1 = 0
    __Padding2 = 0
  }

  ///  Defines the base color for the material.
  internal var baseColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor { _baseColorMap }
  ///  Defines the specular color for the material.
  internal var specularMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar { _specularMap }
  ///  Defines the roughness color for the material.
  internal var roughnessMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar { _roughnessMap }
  ///  Defines the metallic color for the material.
  internal var metallicMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar { _metallicMap }
  ///  Defines the normal color for the material.
  internal var normalMap: Unity_PolySpatial_Internals_PolySpatialTexture { _normalMap }
  ///  Defines the transparency color for the material.
  internal var transparencyMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar { _transparencyMap }
  ///  Defines the emissive color for the material.
  internal var emissiveColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor { _emissiveColorMap }
  ///  The intensity of the emissive color, if any.
  internal var emissiveIntensity: Float32 { _emissiveIntensity }
  ///  Defines the ambient occlusion level for the material.
  internal var ambientOcclusionMap: Unity_PolySpatial_Internals_PolySpatialTexture { _ambientOcclusionMap }
  ///  Defines the clearcoat level for the material.
  internal var clearcoatMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar { _clearcoatMap }
  ///  Defines the clearcoat roughness level for the material.
  internal var clearcoatRoughnessMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar { _clearcoatRoughnessMap }
  ///  Defines the face culling mode used to render any mesh using this material.
  internal var cullMode: Unity_PolySpatial_Internals_PolySpatialCullMode { Unity_PolySpatial_Internals_PolySpatialCullMode(rawValue: _cullMode)! }
  ///  Used to set if this material requires special handling for transparency
  ///  rendering.
  internal var isTransparent: Bool { _isTransparent }
  ///  Determines if specular highlights will be preserved during rendering or not.
  internal var shouldPreserveSpecularHighlights: Bool { _shouldPreserveSpecularHighlights }
  ///  The relative rendering priority for this material.
  internal var priority: Int32 { _priority }
  ///  The opacity level of this material. Used to blend the material with the background.
  ///  This is a value between 0 and 1, where 0 is fully transparent and 1 is fully opaque.
  internal var opacity: Float32 { _opacity }
  ///  The opacity threshold of this material.
  internal var opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold { _opacityThreshold }
  ///  The blending mode used when blending non-opaque materials.
  internal var blendingMode: Unity_PolySpatial_Internals_PolySpatialBlendingMode { Unity_PolySpatial_Internals_PolySpatialBlendingMode(rawValue: _blendingMode)! }
  ///  The scale of the texture in the material.
  internal var scale: UnityEngine_Vector2 { _scale }
  ///  The offset of the main texture.
  internal var offset: UnityEngine_Vector2 { _offset }
  ///  The surface rendering workflow to be used when rendering this
  ///  material.
  internal var workflow: Unity_PolySpatial_Internals_PolySpatialMaterialWorkflow { Unity_PolySpatial_Internals_PolySpatialMaterialWorkflow(rawValue: _workflow)! }
  ///  Should GPU instancing be enabled or not.
  internal var enableInstancing: Bool { _enableInstancing }
  internal var _Padding0: UInt8 { __Padding0 }
  internal var _Padding1: UInt16 { __Padding1 }
  internal var _Padding2: UInt32 { __Padding2 }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialPBRMaterial.self)
  }
}

///  Definition of a Physically Based Rendering material.
internal struct Unity_PolySpatial_Internals_PolySpatialPBRMaterial_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var baseColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureColor_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var specularMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureScalar_Mutable(_accessor.bb, o: _accessor.postion + 40) }
  internal var roughnessMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureScalar_Mutable(_accessor.bb, o: _accessor.postion + 80) }
  internal var metallicMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureScalar_Mutable(_accessor.bb, o: _accessor.postion + 120) }
  internal var normalMap: Unity_PolySpatial_Internals_PolySpatialTexture_Mutable { return Unity_PolySpatial_Internals_PolySpatialTexture_Mutable(_accessor.bb, o: _accessor.postion + 160) }
  internal var transparencyMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureScalar_Mutable(_accessor.bb, o: _accessor.postion + 192) }
  internal var emissiveColorMap: Unity_PolySpatial_Internals_PolySpatialTextureColor_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureColor_Mutable(_accessor.bb, o: _accessor.postion + 232) }
  internal var emissiveIntensity: Float32 { return _accessor.readBuffer(of: Float32.self, at: 272) }
  internal var ambientOcclusionMap: Unity_PolySpatial_Internals_PolySpatialTexture_Mutable { return Unity_PolySpatial_Internals_PolySpatialTexture_Mutable(_accessor.bb, o: _accessor.postion + 280) }
  internal var clearcoatMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureScalar_Mutable(_accessor.bb, o: _accessor.postion + 312) }
  internal var clearcoatRoughnessMap: Unity_PolySpatial_Internals_PolySpatialTextureScalar_Mutable { return Unity_PolySpatial_Internals_PolySpatialTextureScalar_Mutable(_accessor.bb, o: _accessor.postion + 352) }
  internal var cullMode: Unity_PolySpatial_Internals_PolySpatialCullMode { return Unity_PolySpatial_Internals_PolySpatialCullMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 392)) ?? .none_ }
  internal var isTransparent: Bool { return _accessor.readBuffer(of: Bool.self, at: 396) }
  internal var shouldPreserveSpecularHighlights: Bool { return _accessor.readBuffer(of: Bool.self, at: 397) }
  internal var priority: Int32 { return _accessor.readBuffer(of: Int32.self, at: 400) }
  internal var opacity: Float32 { return _accessor.readBuffer(of: Float32.self, at: 404) }
  internal var opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold_Mutable { return Unity_PolySpatial_Internals_PolySpatialOpacityThreshold_Mutable(_accessor.bb, o: _accessor.postion + 408) }
  internal var blendingMode: Unity_PolySpatial_Internals_PolySpatialBlendingMode { return Unity_PolySpatial_Internals_PolySpatialBlendingMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 416)) ?? .alpha }
  internal var scale: UnityEngine_Vector2_Mutable { return UnityEngine_Vector2_Mutable(_accessor.bb, o: _accessor.postion + 420) }
  internal var offset: UnityEngine_Vector2_Mutable { return UnityEngine_Vector2_Mutable(_accessor.bb, o: _accessor.postion + 428) }
  internal var workflow: Unity_PolySpatial_Internals_PolySpatialMaterialWorkflow { return Unity_PolySpatial_Internals_PolySpatialMaterialWorkflow(rawValue: _accessor.readBuffer(of: Int32.self, at: 436)) ?? .polySpatialSpecularWorkflow }
  internal var enableInstancing: Bool { return _accessor.readBuffer(of: Bool.self, at: 440) }
  internal var _Padding0: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 441) }
  internal var _Padding1: UInt16 { return _accessor.readBuffer(of: UInt16.self, at: 442) }
  internal var _Padding2: UInt32 { return _accessor.readBuffer(of: UInt32.self, at: 444) }
}

///  Information required to define a light within the PolySpatial system.
internal struct Unity_PolySpatial_Internals_PolySpatialLightData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The type of the light we are defining.
  private var _lightType: Int32
  ///  The color of the light.
  private var _color: UnityEngine_Color32
  ///  The culling mask that determines which layers the light affects.
  private var _cullingMask: Int32
  ///  The initial intensity of the light.
  private var _intensity: Float32
  ///  The maximum range of the light. Anything outside of this range recieves
  ///  no light. This value has no effect if the light is Directional.
  private var _range: Float32
  ///  The inner angle of the spotlight from which the light intensity will
  ///  be max.
  private var _innerAngle: Float32
  ///  The outer angle of the spotlight that defines the drop off in intensity from the
  ///  inner angle to no lighting.
  private var _outerAngle: Float32
  private var _renderingLayers: UInt32
  ///  The type of shadows cast by the light.
  private var _shadows: Int32
  ///  The constant bias to apply to the shadow depth values.
  private var _shadowBias: Float32
  ///  The distance from the light at which the shadows start.
  private var _shadowNearPlane: Float32
  ///  The type of lighting to use in visionOS.
  private var _visionOsmode: Int32
  ///  Additional shadow bias to add on visionOS only (to compensate for lack of directional bias).
  private var _visionOsshadowBiasOffset: Float32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _lightType = _accessor.readBuffer(of: Int32.self, at: 0)
    _color = UnityEngine_Color32(_accessor.bb, o: _accessor.postion + 4)
    _cullingMask = _accessor.readBuffer(of: Int32.self, at: 8)
    _intensity = _accessor.readBuffer(of: Float32.self, at: 12)
    _range = _accessor.readBuffer(of: Float32.self, at: 16)
    _innerAngle = _accessor.readBuffer(of: Float32.self, at: 20)
    _outerAngle = _accessor.readBuffer(of: Float32.self, at: 24)
    _renderingLayers = _accessor.readBuffer(of: UInt32.self, at: 28)
    _shadows = _accessor.readBuffer(of: Int32.self, at: 32)
    _shadowBias = _accessor.readBuffer(of: Float32.self, at: 36)
    _shadowNearPlane = _accessor.readBuffer(of: Float32.self, at: 40)
    _visionOsmode = _accessor.readBuffer(of: Int32.self, at: 44)
    _visionOsshadowBiasOffset = _accessor.readBuffer(of: Float32.self, at: 48)
  }

  internal init(lightType: Unity_PolySpatial_Internals_PolySpatialLightType, color: UnityEngine_Color32, cullingMask: Int32, intensity: Float32, range: Float32, innerAngle: Float32, outerAngle: Float32, renderingLayers: UInt32, shadows: Unity_PolySpatial_Internals_PolySpatialLightShadows, shadowBias: Float32, shadowNearPlane: Float32, visionOsmode: Unity_PolySpatial_Internals_PolySpatialVisionOSLightMode, visionOsshadowBiasOffset: Float32) {
    _lightType = lightType.value
    _color = color
    _cullingMask = cullingMask
    _intensity = intensity
    _range = range
    _innerAngle = innerAngle
    _outerAngle = outerAngle
    _renderingLayers = renderingLayers
    _shadows = shadows.value
    _shadowBias = shadowBias
    _shadowNearPlane = shadowNearPlane
    _visionOsmode = visionOsmode.value
    _visionOsshadowBiasOffset = visionOsshadowBiasOffset
  }

  internal init() {
    _lightType = 0
    _color = UnityEngine_Color32()
    _cullingMask = 0
    _intensity = 0.0
    _range = 0.0
    _innerAngle = 0.0
    _outerAngle = 0.0
    _renderingLayers = 0
    _shadows = 0
    _shadowBias = 0.0
    _shadowNearPlane = 0.0
    _visionOsmode = 0
    _visionOsshadowBiasOffset = 0.0
  }

  ///  The type of the light we are defining.
  internal var lightType: Unity_PolySpatial_Internals_PolySpatialLightType { Unity_PolySpatial_Internals_PolySpatialLightType(rawValue: _lightType)! }
  ///  The color of the light.
  internal var color: UnityEngine_Color32 { _color }
  ///  The culling mask that determines which layers the light affects.
  internal var cullingMask: Int32 { _cullingMask }
  ///  The initial intensity of the light.
  internal var intensity: Float32 { _intensity }
  ///  The maximum range of the light. Anything outside of this range recieves
  ///  no light. This value has no effect if the light is Directional.
  internal var range: Float32 { _range }
  ///  The inner angle of the spotlight from which the light intensity will
  ///  be max.
  internal var innerAngle: Float32 { _innerAngle }
  ///  The outer angle of the spotlight that defines the drop off in intensity from the
  ///  inner angle to no lighting.
  internal var outerAngle: Float32 { _outerAngle }
  internal var renderingLayers: UInt32 { _renderingLayers }
  ///  The type of shadows cast by the light.
  internal var shadows: Unity_PolySpatial_Internals_PolySpatialLightShadows { Unity_PolySpatial_Internals_PolySpatialLightShadows(rawValue: _shadows)! }
  ///  The constant bias to apply to the shadow depth values.
  internal var shadowBias: Float32 { _shadowBias }
  ///  The distance from the light at which the shadows start.
  internal var shadowNearPlane: Float32 { _shadowNearPlane }
  ///  The type of lighting to use in visionOS.
  internal var visionOsmode: Unity_PolySpatial_Internals_PolySpatialVisionOSLightMode { Unity_PolySpatial_Internals_PolySpatialVisionOSLightMode(rawValue: _visionOsmode)! }
  ///  Additional shadow bias to add on visionOS only (to compensate for lack of directional bias).
  internal var visionOsshadowBiasOffset: Float32 { _visionOsshadowBiasOffset }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialLightData.self)
  }
}

///  Information required to define a light within the PolySpatial system.
internal struct Unity_PolySpatial_Internals_PolySpatialLightData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var lightType: Unity_PolySpatial_Internals_PolySpatialLightType { return Unity_PolySpatial_Internals_PolySpatialLightType(rawValue: _accessor.readBuffer(of: Int32.self, at: 0)) ?? .spot }
  internal var color: UnityEngine_Color32_Mutable { return UnityEngine_Color32_Mutable(_accessor.bb, o: _accessor.postion + 4) }
  internal var cullingMask: Int32 { return _accessor.readBuffer(of: Int32.self, at: 8) }
  internal var intensity: Float32 { return _accessor.readBuffer(of: Float32.self, at: 12) }
  internal var range: Float32 { return _accessor.readBuffer(of: Float32.self, at: 16) }
  internal var innerAngle: Float32 { return _accessor.readBuffer(of: Float32.self, at: 20) }
  internal var outerAngle: Float32 { return _accessor.readBuffer(of: Float32.self, at: 24) }
  internal var renderingLayers: UInt32 { return _accessor.readBuffer(of: UInt32.self, at: 28) }
  internal var shadows: Unity_PolySpatial_Internals_PolySpatialLightShadows { return Unity_PolySpatial_Internals_PolySpatialLightShadows(rawValue: _accessor.readBuffer(of: Int32.self, at: 32)) ?? .none_ }
  internal var shadowBias: Float32 { return _accessor.readBuffer(of: Float32.self, at: 36) }
  internal var shadowNearPlane: Float32 { return _accessor.readBuffer(of: Float32.self, at: 40) }
  internal var visionOsmode: Unity_PolySpatial_Internals_PolySpatialVisionOSLightMode { return Unity_PolySpatial_Internals_PolySpatialVisionOSLightMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 44)) ?? .disabled }
  internal var visionOsshadowBiasOffset: Float32 { return _accessor.readBuffer(of: Float32.self, at: 48) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialLightmapRenderData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The index of the lightmap in the scene list.
  private var _index: Int32
  ///  The UV scale (xy) and offset (zw) within the lightmap textures.
  private var _scaleOffset: UnityEngine_Vector4

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _index = _accessor.readBuffer(of: Int32.self, at: 0)
    _scaleOffset = UnityEngine_Vector4(_accessor.bb, o: _accessor.postion + 4)
  }

  internal init(index: Int32, scaleOffset: UnityEngine_Vector4) {
    _index = index
    _scaleOffset = scaleOffset
  }

  internal init() {
    _index = 0
    _scaleOffset = UnityEngine_Vector4()
  }

  ///  The index of the lightmap in the scene list.
  internal var index: Int32 { _index }
  ///  The UV scale (xy) and offset (zw) within the lightmap textures.
  internal var scaleOffset: UnityEngine_Vector4 { _scaleOffset }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialLightmapRenderData.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialLightmapRenderData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var index: Int32 { return _accessor.readBuffer(of: Int32.self, at: 0) }
  internal var scaleOffset: UnityEngine_Vector4_Mutable { return UnityEngine_Vector4_Mutable(_accessor.bb, o: _accessor.postion + 4) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialLightProbeData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  Red constant/linear polynomial terms.
  private var _shAr: UnityEngine_Vector4
  ///  Green constant/linear polynomial terms.
  private var _shAg: UnityEngine_Vector4
  ///  Blue constant/linear polynomial terms.
  private var _shAb: UnityEngine_Vector4
  ///  Red quadratic polynomial terms.
  private var _shBr: UnityEngine_Vector4
  ///  Green quadratic polynomial terms.
  private var _shBg: UnityEngine_Vector4
  ///  Blue quadratic polynomial terms.
  private var _shBb: UnityEngine_Vector4
  ///  Remaining quadratic polynomial terms.
  private var _shC: UnityEngine_Vector3

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _shAr = UnityEngine_Vector4(_accessor.bb, o: _accessor.postion + 0)
    _shAg = UnityEngine_Vector4(_accessor.bb, o: _accessor.postion + 16)
    _shAb = UnityEngine_Vector4(_accessor.bb, o: _accessor.postion + 32)
    _shBr = UnityEngine_Vector4(_accessor.bb, o: _accessor.postion + 48)
    _shBg = UnityEngine_Vector4(_accessor.bb, o: _accessor.postion + 64)
    _shBb = UnityEngine_Vector4(_accessor.bb, o: _accessor.postion + 80)
    _shC = UnityEngine_Vector3(_accessor.bb, o: _accessor.postion + 96)
  }

  internal init(shAr: UnityEngine_Vector4, shAg: UnityEngine_Vector4, shAb: UnityEngine_Vector4, shBr: UnityEngine_Vector4, shBg: UnityEngine_Vector4, shBb: UnityEngine_Vector4, shC: UnityEngine_Vector3) {
    _shAr = shAr
    _shAg = shAg
    _shAb = shAb
    _shBr = shBr
    _shBg = shBg
    _shBb = shBb
    _shC = shC
  }

  internal init() {
    _shAr = UnityEngine_Vector4()
    _shAg = UnityEngine_Vector4()
    _shAb = UnityEngine_Vector4()
    _shBr = UnityEngine_Vector4()
    _shBg = UnityEngine_Vector4()
    _shBb = UnityEngine_Vector4()
    _shC = UnityEngine_Vector3()
  }

  ///  Red constant/linear polynomial terms.
  internal var shAr: UnityEngine_Vector4 { _shAr }
  ///  Green constant/linear polynomial terms.
  internal var shAg: UnityEngine_Vector4 { _shAg }
  ///  Blue constant/linear polynomial terms.
  internal var shAb: UnityEngine_Vector4 { _shAb }
  ///  Red quadratic polynomial terms.
  internal var shBr: UnityEngine_Vector4 { _shBr }
  ///  Green quadratic polynomial terms.
  internal var shBg: UnityEngine_Vector4 { _shBg }
  ///  Blue quadratic polynomial terms.
  internal var shBb: UnityEngine_Vector4 { _shBb }
  ///  Remaining quadratic polynomial terms.
  internal var shC: UnityEngine_Vector3 { _shC }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialLightProbeData.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialLightProbeData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var shAr: UnityEngine_Vector4_Mutable { return UnityEngine_Vector4_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var shAg: UnityEngine_Vector4_Mutable { return UnityEngine_Vector4_Mutable(_accessor.bb, o: _accessor.postion + 16) }
  internal var shAb: UnityEngine_Vector4_Mutable { return UnityEngine_Vector4_Mutable(_accessor.bb, o: _accessor.postion + 32) }
  internal var shBr: UnityEngine_Vector4_Mutable { return UnityEngine_Vector4_Mutable(_accessor.bb, o: _accessor.postion + 48) }
  internal var shBg: UnityEngine_Vector4_Mutable { return UnityEngine_Vector4_Mutable(_accessor.bb, o: _accessor.postion + 64) }
  internal var shBb: UnityEngine_Vector4_Mutable { return UnityEngine_Vector4_Mutable(_accessor.bb, o: _accessor.postion + 80) }
  internal var shC: UnityEngine_Vector3_Mutable { return UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.postion + 96) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialReflectionProbeData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The asset id of the reflection probe texture.
  private var _textureAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID
  ///  The weight of the reflection probe.
  private var _weight: Float32
  private var __Padding: UInt32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _textureAssetId = Unity_PolySpatial_Internals_PolySpatialAssetID(_accessor.bb, o: _accessor.postion + 0)
    _weight = _accessor.readBuffer(of: Float32.self, at: 24)
    __Padding = _accessor.readBuffer(of: UInt32.self, at: 28)
  }

  internal init(textureAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID, weight: Float32, _Padding: UInt32) {
    _textureAssetId = textureAssetId
    _weight = weight
    __Padding = _Padding
  }

  internal init() {
    _textureAssetId = Unity_PolySpatial_Internals_PolySpatialAssetID()
    _weight = 0.0
    __Padding = 0
  }

  ///  The asset id of the reflection probe texture.
  internal var textureAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID { _textureAssetId }
  ///  The weight of the reflection probe.
  internal var weight: Float32 { _weight }
  internal var _Padding: UInt32 { __Padding }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialReflectionProbeData.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialReflectionProbeData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var textureAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable { return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var weight: Float32 { return _accessor.readBuffer(of: Float32.self, at: 24) }
  internal var _Padding: UInt32 { return _accessor.readBuffer(of: UInt32.self, at: 28) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialImageBasedLightData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The asset id of the first image-based light texture, if any.  Neither, either, or both of the source assets
  ///  may be valid.  If both are valid, they are blended together in proportion according to the blend parameter.
  private var _sourceAssetId0: Unity_PolySpatial_Internals_PolySpatialAssetID
  ///  The asset id of the second image-based light texture, if any.
  private var _sourceAssetId1: Unity_PolySpatial_Internals_PolySpatialAssetID
  ///  The blend parameter that determines the proportionate amount of each source asset to include, if both
  ///  assets are valid (e.g., a value of 0.25 would include 25% of sourceAssetId0 and 75% of sourceAssetId1).
  private var _blend: Float32
  ///  Whether or not the light inherits the rotation of the object's transform.
  private var _inheritsRotation: Bool
  private let padding0__: UInt8 = 0
  private let padding1__: UInt16 = 0
  ///  The power of two by which to scale the light's intensity.
  private var _intensityExponent: Float32
  private var __Padding: UInt32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _sourceAssetId0 = Unity_PolySpatial_Internals_PolySpatialAssetID(_accessor.bb, o: _accessor.postion + 0)
    _sourceAssetId1 = Unity_PolySpatial_Internals_PolySpatialAssetID(_accessor.bb, o: _accessor.postion + 24)
    _blend = _accessor.readBuffer(of: Float32.self, at: 48)
    _inheritsRotation = _accessor.readBuffer(of: Bool.self, at: 52)
    _intensityExponent = _accessor.readBuffer(of: Float32.self, at: 56)
    __Padding = _accessor.readBuffer(of: UInt32.self, at: 60)
  }

  internal init(sourceAssetId0: Unity_PolySpatial_Internals_PolySpatialAssetID, sourceAssetId1: Unity_PolySpatial_Internals_PolySpatialAssetID, blend: Float32, inheritsRotation: Bool, intensityExponent: Float32, _Padding: UInt32) {
    _sourceAssetId0 = sourceAssetId0
    _sourceAssetId1 = sourceAssetId1
    _blend = blend
    _inheritsRotation = inheritsRotation
    _intensityExponent = intensityExponent
    __Padding = _Padding
  }

  internal init() {
    _sourceAssetId0 = Unity_PolySpatial_Internals_PolySpatialAssetID()
    _sourceAssetId1 = Unity_PolySpatial_Internals_PolySpatialAssetID()
    _blend = 0.0
    _inheritsRotation = false
    _intensityExponent = 0.0
    __Padding = 0
  }

  ///  The asset id of the first image-based light texture, if any.  Neither, either, or both of the source assets
  ///  may be valid.  If both are valid, they are blended together in proportion according to the blend parameter.
  internal var sourceAssetId0: Unity_PolySpatial_Internals_PolySpatialAssetID { _sourceAssetId0 }
  ///  The asset id of the second image-based light texture, if any.
  internal var sourceAssetId1: Unity_PolySpatial_Internals_PolySpatialAssetID { _sourceAssetId1 }
  ///  The blend parameter that determines the proportionate amount of each source asset to include, if both
  ///  assets are valid (e.g., a value of 0.25 would include 25% of sourceAssetId0 and 75% of sourceAssetId1).
  internal var blend: Float32 { _blend }
  ///  Whether or not the light inherits the rotation of the object's transform.
  internal var inheritsRotation: Bool { _inheritsRotation }
  ///  The power of two by which to scale the light's intensity.
  internal var intensityExponent: Float32 { _intensityExponent }
  internal var _Padding: UInt32 { __Padding }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialImageBasedLightData.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialImageBasedLightData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var sourceAssetId0: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable { return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var sourceAssetId1: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable { return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.postion + 24) }
  internal var blend: Float32 { return _accessor.readBuffer(of: Float32.self, at: 48) }
  internal var inheritsRotation: Bool { return _accessor.readBuffer(of: Bool.self, at: 52) }
  internal var intensityExponent: Float32 { return _accessor.readBuffer(of: Float32.self, at: 56) }
  internal var _Padding: UInt32 { return _accessor.readBuffer(of: UInt32.self, at: 60) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialImageBasedLightReceiverData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _imageBasedLightId: Unity_PolySpatial_Internals_PolySpatialInstanceID

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _imageBasedLightId = Unity_PolySpatial_Internals_PolySpatialInstanceID(_accessor.bb, o: _accessor.postion + 0)
  }

  internal init(imageBasedLightId: Unity_PolySpatial_Internals_PolySpatialInstanceID) {
    _imageBasedLightId = imageBasedLightId
  }

  internal init() {
    _imageBasedLightId = Unity_PolySpatial_Internals_PolySpatialInstanceID()
  }

  internal var imageBasedLightId: Unity_PolySpatial_Internals_PolySpatialInstanceID { _imageBasedLightId }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialImageBasedLightReceiverData.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialImageBasedLightReceiverData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var imageBasedLightId: Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable { return Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable(_accessor.bb, o: _accessor.postion + 0) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialEnvironmentLightingConfigurationData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _environmentLightingWeight: Float32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _environmentLightingWeight = _accessor.readBuffer(of: Float32.self, at: 0)
  }

  internal init(environmentLightingWeight: Float32) {
    _environmentLightingWeight = environmentLightingWeight
  }

  internal init() {
    _environmentLightingWeight = 0.0
  }

  internal var environmentLightingWeight: Float32 { _environmentLightingWeight }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialEnvironmentLightingConfigurationData.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialEnvironmentLightingConfigurationData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var environmentLightingWeight: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialLightmapData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _lightmapColor: Unity_PolySpatial_Internals_PolySpatialAssetID
  private var _lightmapDir: Unity_PolySpatial_Internals_PolySpatialAssetID
  private var _shadowMask: Unity_PolySpatial_Internals_PolySpatialAssetID

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _lightmapColor = Unity_PolySpatial_Internals_PolySpatialAssetID(_accessor.bb, o: _accessor.postion + 0)
    _lightmapDir = Unity_PolySpatial_Internals_PolySpatialAssetID(_accessor.bb, o: _accessor.postion + 24)
    _shadowMask = Unity_PolySpatial_Internals_PolySpatialAssetID(_accessor.bb, o: _accessor.postion + 48)
  }

  internal init(lightmapColor: Unity_PolySpatial_Internals_PolySpatialAssetID, lightmapDir: Unity_PolySpatial_Internals_PolySpatialAssetID, shadowMask: Unity_PolySpatial_Internals_PolySpatialAssetID) {
    _lightmapColor = lightmapColor
    _lightmapDir = lightmapDir
    _shadowMask = shadowMask
  }

  internal init() {
    _lightmapColor = Unity_PolySpatial_Internals_PolySpatialAssetID()
    _lightmapDir = Unity_PolySpatial_Internals_PolySpatialAssetID()
    _shadowMask = Unity_PolySpatial_Internals_PolySpatialAssetID()
  }

  internal var lightmapColor: Unity_PolySpatial_Internals_PolySpatialAssetID { _lightmapColor }
  internal var lightmapDir: Unity_PolySpatial_Internals_PolySpatialAssetID { _lightmapDir }
  internal var shadowMask: Unity_PolySpatial_Internals_PolySpatialAssetID { _shadowMask }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialLightmapData.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialLightmapData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var lightmapColor: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable { return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var lightmapDir: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable { return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.postion + 24) }
  internal var shadowMask: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable { return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.postion + 48) }
}

///  A sorting group, consisting of a list of renderers and sorting indices, along with an int that represents the sorting group.
internal struct Unity_PolySpatial_Internals_PolySpatialSortingOrder: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  Sort index for this renderer - lower numbers indicate it should be drawn first.
  private var _sortOrder: Int32
  private var _shouldApplyDescendant: Bool
  private let padding0__: UInt8 = 0
  private let padding1__: UInt16 = 0
  ///  Renderer to which this sort index is applied to.
  private var _renderer: Unity_PolySpatial_Internals_PolySpatialInstanceID

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _sortOrder = _accessor.readBuffer(of: Int32.self, at: 0)
    _shouldApplyDescendant = _accessor.readBuffer(of: Bool.self, at: 4)
    _renderer = Unity_PolySpatial_Internals_PolySpatialInstanceID(_accessor.bb, o: _accessor.postion + 8)
  }

  internal init(sortOrder: Int32, shouldApplyDescendant: Bool, renderer: Unity_PolySpatial_Internals_PolySpatialInstanceID) {
    _sortOrder = sortOrder
    _shouldApplyDescendant = shouldApplyDescendant
    _renderer = renderer
  }

  internal init() {
    _sortOrder = 0
    _shouldApplyDescendant = false
    _renderer = Unity_PolySpatial_Internals_PolySpatialInstanceID()
  }

  ///  Sort index for this renderer - lower numbers indicate it should be drawn first.
  internal var sortOrder: Int32 { _sortOrder }
  internal var shouldApplyDescendant: Bool { _shouldApplyDescendant }
  ///  Renderer to which this sort index is applied to.
  internal var renderer: Unity_PolySpatial_Internals_PolySpatialInstanceID { _renderer }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialSortingOrder.self)
  }
}

///  A sorting group, consisting of a list of renderers and sorting indices, along with an int that represents the sorting group.
internal struct Unity_PolySpatial_Internals_PolySpatialSortingOrder_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var sortOrder: Int32 { return _accessor.readBuffer(of: Int32.self, at: 0) }
  internal var shouldApplyDescendant: Bool { return _accessor.readBuffer(of: Bool.self, at: 4) }
  internal var renderer: Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable { return Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable(_accessor.bb, o: _accessor.postion + 8) }
}

///  Defines information associated with a UI graphic.
internal struct Unity_PolySpatial_Internals_PolySpatialUIGraphicData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _raycastTarget: Bool
  private var _p0: Int8
  private var _p1: Int8
  private var _p2: Int8

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _raycastTarget = _accessor.readBuffer(of: Bool.self, at: 0)
    _p0 = _accessor.readBuffer(of: Int8.self, at: 1)
    _p1 = _accessor.readBuffer(of: Int8.self, at: 2)
    _p2 = _accessor.readBuffer(of: Int8.self, at: 3)
  }

  internal init(raycastTarget: Bool, p0: Int8, p1: Int8, p2: Int8) {
    _raycastTarget = raycastTarget
    _p0 = p0
    _p1 = p1
    _p2 = p2
  }

  internal init() {
    _raycastTarget = false
    _p0 = 0
    _p1 = 0
    _p2 = 0
  }

  internal var raycastTarget: Bool { _raycastTarget }
  internal var p0: Int8 { _p0 }
  internal var p1: Int8 { _p1 }
  internal var p2: Int8 { _p2 }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialUIGraphicData.self)
  }
}

///  Defines information associated with a UI graphic.
internal struct Unity_PolySpatial_Internals_PolySpatialUIGraphicData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var raycastTarget: Bool { return _accessor.readBuffer(of: Bool.self, at: 0) }
  internal var p0: Int8 { return _accessor.readBuffer(of: Int8.self, at: 1) }
  internal var p1: Int8 { return _accessor.readBuffer(of: Int8.self, at: 2) }
  internal var p2: Int8 { return _accessor.readBuffer(of: Int8.self, at: 3) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialPointerEvent: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _interactionId: Int32
  private var _interactionPosition: UnityEngine_Vector3
  private var _interactionRayOrigin: UnityEngine_Vector3
  private var _interactionRayDirection: UnityEngine_Vector3
  private var _inputDevicePosition: UnityEngine_Vector3
  private var _inputDeviceRotation: UnityEngine_Quaternion
  private var _modifierKeys: UInt16
  private var _kind: Int8
  private var _phase: Int8
  private var _targetId: Unity_PolySpatial_Internals_PolySpatialInstanceID
  private var _volumeId: Unity_PolySpatial_Internals_PolySpatialInstanceID

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _interactionId = _accessor.readBuffer(of: Int32.self, at: 0)
    _interactionPosition = UnityEngine_Vector3(_accessor.bb, o: _accessor.postion + 4)
    _interactionRayOrigin = UnityEngine_Vector3(_accessor.bb, o: _accessor.postion + 16)
    _interactionRayDirection = UnityEngine_Vector3(_accessor.bb, o: _accessor.postion + 28)
    _inputDevicePosition = UnityEngine_Vector3(_accessor.bb, o: _accessor.postion + 40)
    _inputDeviceRotation = UnityEngine_Quaternion(_accessor.bb, o: _accessor.postion + 52)
    _modifierKeys = _accessor.readBuffer(of: UInt16.self, at: 68)
    _kind = _accessor.readBuffer(of: Int8.self, at: 70)
    _phase = _accessor.readBuffer(of: Int8.self, at: 71)
    _targetId = Unity_PolySpatial_Internals_PolySpatialInstanceID(_accessor.bb, o: _accessor.postion + 72)
    _volumeId = Unity_PolySpatial_Internals_PolySpatialInstanceID(_accessor.bb, o: _accessor.postion + 88)
  }

  internal init(interactionId: Int32, interactionPosition: UnityEngine_Vector3, interactionRayOrigin: UnityEngine_Vector3, interactionRayDirection: UnityEngine_Vector3, inputDevicePosition: UnityEngine_Vector3, inputDeviceRotation: UnityEngine_Quaternion, modifierKeys: Unity_PolySpatial_Internals_PolySpatialPointerModifierKeys, kind: Unity_PolySpatial_Internals_PolySpatialPointerKind, phase: Unity_PolySpatial_Internals_PolySpatialPointerPhase, targetId: Unity_PolySpatial_Internals_PolySpatialInstanceID, volumeId: Unity_PolySpatial_Internals_PolySpatialInstanceID) {
    _interactionId = interactionId
    _interactionPosition = interactionPosition
    _interactionRayOrigin = interactionRayOrigin
    _interactionRayDirection = interactionRayDirection
    _inputDevicePosition = inputDevicePosition
    _inputDeviceRotation = inputDeviceRotation
    _modifierKeys = modifierKeys.value
    _kind = kind.value
    _phase = phase.value
    _targetId = targetId
    _volumeId = volumeId
  }

  internal init() {
    _interactionId = 0
    _interactionPosition = UnityEngine_Vector3()
    _interactionRayOrigin = UnityEngine_Vector3()
    _interactionRayDirection = UnityEngine_Vector3()
    _inputDevicePosition = UnityEngine_Vector3()
    _inputDeviceRotation = UnityEngine_Quaternion()
    _modifierKeys = 0
    _kind = 0
    _phase = 0
    _targetId = Unity_PolySpatial_Internals_PolySpatialInstanceID()
    _volumeId = Unity_PolySpatial_Internals_PolySpatialInstanceID()
  }

  internal var interactionId: Int32 { _interactionId }
  internal var interactionPosition: UnityEngine_Vector3 { _interactionPosition }
  internal var interactionRayOrigin: UnityEngine_Vector3 { _interactionRayOrigin }
  internal var interactionRayDirection: UnityEngine_Vector3 { _interactionRayDirection }
  internal var inputDevicePosition: UnityEngine_Vector3 { _inputDevicePosition }
  internal var inputDeviceRotation: UnityEngine_Quaternion { _inputDeviceRotation }
  internal var modifierKeys: Unity_PolySpatial_Internals_PolySpatialPointerModifierKeys { Unity_PolySpatial_Internals_PolySpatialPointerModifierKeys(rawValue: _modifierKeys) }
  internal var kind: Unity_PolySpatial_Internals_PolySpatialPointerKind { Unity_PolySpatial_Internals_PolySpatialPointerKind(rawValue: _kind)! }
  internal var phase: Unity_PolySpatial_Internals_PolySpatialPointerPhase { Unity_PolySpatial_Internals_PolySpatialPointerPhase(rawValue: _phase)! }
  internal var targetId: Unity_PolySpatial_Internals_PolySpatialInstanceID { _targetId }
  internal var volumeId: Unity_PolySpatial_Internals_PolySpatialInstanceID { _volumeId }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialPointerEvent.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialPointerEvent_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var interactionId: Int32 { return _accessor.readBuffer(of: Int32.self, at: 0) }
  internal var interactionPosition: UnityEngine_Vector3_Mutable { return UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.postion + 4) }
  internal var interactionRayOrigin: UnityEngine_Vector3_Mutable { return UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.postion + 16) }
  internal var interactionRayDirection: UnityEngine_Vector3_Mutable { return UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.postion + 28) }
  internal var inputDevicePosition: UnityEngine_Vector3_Mutable { return UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.postion + 40) }
  internal var inputDeviceRotation: UnityEngine_Quaternion_Mutable { return UnityEngine_Quaternion_Mutable(_accessor.bb, o: _accessor.postion + 52) }
  internal var modifierKeys: Unity_PolySpatial_Internals_PolySpatialPointerModifierKeys { return Unity_PolySpatial_Internals_PolySpatialPointerModifierKeys(rawValue: _accessor.readBuffer(of: UInt16.self, at: 68))  }
  internal var kind: Unity_PolySpatial_Internals_PolySpatialPointerKind { return Unity_PolySpatial_Internals_PolySpatialPointerKind(rawValue: _accessor.readBuffer(of: Int8.self, at: 70)) ?? .directPinch }
  internal var phase: Unity_PolySpatial_Internals_PolySpatialPointerPhase { return Unity_PolySpatial_Internals_PolySpatialPointerPhase(rawValue: _accessor.readBuffer(of: Int8.self, at: 71)) ?? .none_ }
  internal var targetId: Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable { return Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable(_accessor.bb, o: _accessor.postion + 72) }
  internal var volumeId: Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable { return Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable(_accessor.bb, o: _accessor.postion + 88) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialHeadPoseEvent: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _pose: UnityEngine_Pose
  private var _tracked: Bool
  private var _padding0: Int8
  private var _padding1: Int8
  private var _padding2: Int8

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _pose = UnityEngine_Pose(_accessor.bb, o: _accessor.postion + 0)
    _tracked = _accessor.readBuffer(of: Bool.self, at: 28)
    _padding0 = _accessor.readBuffer(of: Int8.self, at: 29)
    _padding1 = _accessor.readBuffer(of: Int8.self, at: 30)
    _padding2 = _accessor.readBuffer(of: Int8.self, at: 31)
  }

  internal init(pose: UnityEngine_Pose, tracked: Bool, padding0: Int8, padding1: Int8, padding2: Int8) {
    _pose = pose
    _tracked = tracked
    _padding0 = padding0
    _padding1 = padding1
    _padding2 = padding2
  }

  internal init() {
    _pose = UnityEngine_Pose()
    _tracked = false
    _padding0 = 0
    _padding1 = 0
    _padding2 = 0
  }

  internal var pose: UnityEngine_Pose { _pose }
  internal var tracked: Bool { _tracked }
  internal var padding0: Int8 { _padding0 }
  internal var padding1: Int8 { _padding1 }
  internal var padding2: Int8 { _padding2 }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialHeadPoseEvent.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialHeadPoseEvent_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var pose: UnityEngine_Pose_Mutable { return UnityEngine_Pose_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var tracked: Bool { return _accessor.readBuffer(of: Bool.self, at: 28) }
  internal var padding0: Int8 { return _accessor.readBuffer(of: Int8.self, at: 29) }
  internal var padding1: Int8 { return _accessor.readBuffer(of: Int8.self, at: 30) }
  internal var padding2: Int8 { return _accessor.readBuffer(of: Int8.self, at: 31) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialColliderData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _colliderId: Unity_PolySpatial_Internals_PolySpatialComponentID
  private var _shape: Int32
  private var _center: UnityEngine_Vector3
  private var _size: UnityEngine_Vector3
  private let padding0__: UInt32 = 0
  private var _meshId: Unity_PolySpatial_Internals_PolySpatialAssetID
  private var _options: UInt32
  private var __Padding: UInt32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _colliderId = Unity_PolySpatial_Internals_PolySpatialComponentID(_accessor.bb, o: _accessor.postion + 0)
    _shape = _accessor.readBuffer(of: Int32.self, at: 8)
    _center = UnityEngine_Vector3(_accessor.bb, o: _accessor.postion + 12)
    _size = UnityEngine_Vector3(_accessor.bb, o: _accessor.postion + 24)
    _meshId = Unity_PolySpatial_Internals_PolySpatialAssetID(_accessor.bb, o: _accessor.postion + 40)
    _options = _accessor.readBuffer(of: UInt32.self, at: 64)
    __Padding = _accessor.readBuffer(of: UInt32.self, at: 68)
  }

  internal init(colliderId: Unity_PolySpatial_Internals_PolySpatialComponentID, shape: Unity_PolySpatial_Internals_PolySpatialColliderShape, center: UnityEngine_Vector3, size: UnityEngine_Vector3, meshId: Unity_PolySpatial_Internals_PolySpatialAssetID, options: UInt32, _Padding: UInt32) {
    _colliderId = colliderId
    _shape = shape.value
    _center = center
    _size = size
    _meshId = meshId
    _options = options
    __Padding = _Padding
  }

  internal init() {
    _colliderId = Unity_PolySpatial_Internals_PolySpatialComponentID()
    _shape = 0
    _center = UnityEngine_Vector3()
    _size = UnityEngine_Vector3()
    _meshId = Unity_PolySpatial_Internals_PolySpatialAssetID()
    _options = 0
    __Padding = 0
  }

  internal var colliderId: Unity_PolySpatial_Internals_PolySpatialComponentID { _colliderId }
  internal var shape: Unity_PolySpatial_Internals_PolySpatialColliderShape { Unity_PolySpatial_Internals_PolySpatialColliderShape(rawValue: _shape)! }
  internal var center: UnityEngine_Vector3 { _center }
  internal var size: UnityEngine_Vector3 { _size }
  internal var meshId: Unity_PolySpatial_Internals_PolySpatialAssetID { _meshId }
  internal var options: UInt32 { _options }
  internal var _Padding: UInt32 { __Padding }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialColliderData.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialColliderData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var colliderId: Unity_PolySpatial_Internals_PolySpatialComponentID_Mutable { return Unity_PolySpatial_Internals_PolySpatialComponentID_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var shape: Unity_PolySpatial_Internals_PolySpatialColliderShape { return Unity_PolySpatial_Internals_PolySpatialColliderShape(rawValue: _accessor.readBuffer(of: Int32.self, at: 8)) ?? .box }
  internal var center: UnityEngine_Vector3_Mutable { return UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.postion + 12) }
  internal var size: UnityEngine_Vector3_Mutable { return UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.postion + 24) }
  internal var meshId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable { return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.postion + 40) }
  internal var options: UInt32 { return _accessor.readBuffer(of: UInt32.self, at: 64) }
  internal var _Padding: UInt32 { return _accessor.readBuffer(of: UInt32.self, at: 68) }
}

///  Represents the state of a single UnityEngine.Rendering.Volume component.
internal struct Unity_PolySpatial_Internals_PolySpatialRenderingVolumeData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The instance ID of the original component.
  private var _componentId: Unity_PolySpatial_Internals_PolySpatialComponentID
  ///  Whether or not this is a global volume, versus one limited by colliders on the same entity.
  private var _isGlobal: Bool
  private let padding0__: UInt8 = 0
  private let padding1__: UInt16 = 0
  ///  For local volumes, the outer distance to start blending from.
  private var _blendDistance: Float32
  ///  The total weight of the volume in the scene (zero for no effect, one for full effect).
  private var _weight: Float32
  ///  Used as a tie-breaker for volumes with equal amounts of influence; higher priorities override lower ones.
  private var _priority: Float32
  ///  The asset ID of the volume profile to use for the volume.
  private var _profileAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _componentId = Unity_PolySpatial_Internals_PolySpatialComponentID(_accessor.bb, o: _accessor.postion + 0)
    _isGlobal = _accessor.readBuffer(of: Bool.self, at: 8)
    _blendDistance = _accessor.readBuffer(of: Float32.self, at: 12)
    _weight = _accessor.readBuffer(of: Float32.self, at: 16)
    _priority = _accessor.readBuffer(of: Float32.self, at: 20)
    _profileAssetId = Unity_PolySpatial_Internals_PolySpatialAssetID(_accessor.bb, o: _accessor.postion + 24)
  }

  internal init(componentId: Unity_PolySpatial_Internals_PolySpatialComponentID, isGlobal: Bool, blendDistance: Float32, weight: Float32, priority: Float32, profileAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID) {
    _componentId = componentId
    _isGlobal = isGlobal
    _blendDistance = blendDistance
    _weight = weight
    _priority = priority
    _profileAssetId = profileAssetId
  }

  internal init() {
    _componentId = Unity_PolySpatial_Internals_PolySpatialComponentID()
    _isGlobal = false
    _blendDistance = 0.0
    _weight = 0.0
    _priority = 0.0
    _profileAssetId = Unity_PolySpatial_Internals_PolySpatialAssetID()
  }

  ///  The instance ID of the original component.
  internal var componentId: Unity_PolySpatial_Internals_PolySpatialComponentID { _componentId }
  ///  Whether or not this is a global volume, versus one limited by colliders on the same entity.
  internal var isGlobal: Bool { _isGlobal }
  ///  For local volumes, the outer distance to start blending from.
  internal var blendDistance: Float32 { _blendDistance }
  ///  The total weight of the volume in the scene (zero for no effect, one for full effect).
  internal var weight: Float32 { _weight }
  ///  Used as a tie-breaker for volumes with equal amounts of influence; higher priorities override lower ones.
  internal var priority: Float32 { _priority }
  ///  The asset ID of the volume profile to use for the volume.
  internal var profileAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID { _profileAssetId }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialRenderingVolumeData.self)
  }
}

///  Represents the state of a single UnityEngine.Rendering.Volume component.
internal struct Unity_PolySpatial_Internals_PolySpatialRenderingVolumeData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var componentId: Unity_PolySpatial_Internals_PolySpatialComponentID_Mutable { return Unity_PolySpatial_Internals_PolySpatialComponentID_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var isGlobal: Bool { return _accessor.readBuffer(of: Bool.self, at: 8) }
  internal var blendDistance: Float32 { return _accessor.readBuffer(of: Float32.self, at: 12) }
  internal var weight: Float32 { return _accessor.readBuffer(of: Float32.self, at: 16) }
  internal var priority: Float32 { return _accessor.readBuffer(of: Float32.self, at: 20) }
  internal var profileAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable { return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.postion + 24) }
}

///  Contains the render settings for a scene.  See the documentation for
///  https://docs.unity3d.com/6000.0/Documentation/ScriptReference/RenderSettings.html
internal struct Unity_PolySpatial_Internals_PolySpatialRenderSettingsData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _ambientEquatorColor: UnityEngine_Color
  private var _ambientGroundColor: UnityEngine_Color
  private var _ambientIntensity: Float32
  private var _ambientLight: UnityEngine_Color
  private var _ambientMode: Int32
  private var _ambientProbe: Unity_PolySpatial_Internals_PolySpatialLightProbeData
  private var _ambientSkyColor: UnityEngine_Color
  private var _defaultReflectionMode: Int32
  private var _defaultReflectionResolution: Int32
  private var _flareFadeSpeed: Float32
  private var _flareStrength: Float32
  private var _fog: Bool
  private let padding0__: UInt8 = 0
  private let padding1__: UInt16 = 0
  private var _fogColor: UnityEngine_Color
  private var _fogDensity: Float32
  private var _fogEndDistance: Float32
  private var _fogMode: Int32
  private var _fogStartDistance: Float32
  private var _haloStrength: Float32
  private var _reflectionBounces: Int32
  private var _reflectionIntensity: Float32
  private let padding2__: UInt32 = 0
  private var _skybox: Unity_PolySpatial_Internals_PolySpatialAssetID
  private var _subtractiveShadowColor: UnityEngine_Color
  private var _sun: Unity_PolySpatial_Internals_PolySpatialInstanceID

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _ambientEquatorColor = UnityEngine_Color(_accessor.bb, o: _accessor.postion + 0)
    _ambientGroundColor = UnityEngine_Color(_accessor.bb, o: _accessor.postion + 16)
    _ambientIntensity = _accessor.readBuffer(of: Float32.self, at: 32)
    _ambientLight = UnityEngine_Color(_accessor.bb, o: _accessor.postion + 36)
    _ambientMode = _accessor.readBuffer(of: Int32.self, at: 52)
    _ambientProbe = Unity_PolySpatial_Internals_PolySpatialLightProbeData(_accessor.bb, o: _accessor.postion + 56)
    _ambientSkyColor = UnityEngine_Color(_accessor.bb, o: _accessor.postion + 164)
    _defaultReflectionMode = _accessor.readBuffer(of: Int32.self, at: 180)
    _defaultReflectionResolution = _accessor.readBuffer(of: Int32.self, at: 184)
    _flareFadeSpeed = _accessor.readBuffer(of: Float32.self, at: 188)
    _flareStrength = _accessor.readBuffer(of: Float32.self, at: 192)
    _fog = _accessor.readBuffer(of: Bool.self, at: 196)
    _fogColor = UnityEngine_Color(_accessor.bb, o: _accessor.postion + 200)
    _fogDensity = _accessor.readBuffer(of: Float32.self, at: 216)
    _fogEndDistance = _accessor.readBuffer(of: Float32.self, at: 220)
    _fogMode = _accessor.readBuffer(of: Int32.self, at: 224)
    _fogStartDistance = _accessor.readBuffer(of: Float32.self, at: 228)
    _haloStrength = _accessor.readBuffer(of: Float32.self, at: 232)
    _reflectionBounces = _accessor.readBuffer(of: Int32.self, at: 236)
    _reflectionIntensity = _accessor.readBuffer(of: Float32.self, at: 240)
    _skybox = Unity_PolySpatial_Internals_PolySpatialAssetID(_accessor.bb, o: _accessor.postion + 248)
    _subtractiveShadowColor = UnityEngine_Color(_accessor.bb, o: _accessor.postion + 272)
    _sun = Unity_PolySpatial_Internals_PolySpatialInstanceID(_accessor.bb, o: _accessor.postion + 288)
  }

  internal init(ambientEquatorColor: UnityEngine_Color, ambientGroundColor: UnityEngine_Color, ambientIntensity: Float32, ambientLight: UnityEngine_Color, ambientMode: Unity_PolySpatial_Internals_PolySpatialAmbientMode, ambientProbe: Unity_PolySpatial_Internals_PolySpatialLightProbeData, ambientSkyColor: UnityEngine_Color, defaultReflectionMode: Unity_PolySpatial_Internals_PolySpatialDefaultReflectionMode, defaultReflectionResolution: Int32, flareFadeSpeed: Float32, flareStrength: Float32, fog: Bool, fogColor: UnityEngine_Color, fogDensity: Float32, fogEndDistance: Float32, fogMode: Unity_PolySpatial_Internals_PolySpatialFogMode, fogStartDistance: Float32, haloStrength: Float32, reflectionBounces: Int32, reflectionIntensity: Float32, skybox: Unity_PolySpatial_Internals_PolySpatialAssetID, subtractiveShadowColor: UnityEngine_Color, sun: Unity_PolySpatial_Internals_PolySpatialInstanceID) {
    _ambientEquatorColor = ambientEquatorColor
    _ambientGroundColor = ambientGroundColor
    _ambientIntensity = ambientIntensity
    _ambientLight = ambientLight
    _ambientMode = ambientMode.value
    _ambientProbe = ambientProbe
    _ambientSkyColor = ambientSkyColor
    _defaultReflectionMode = defaultReflectionMode.value
    _defaultReflectionResolution = defaultReflectionResolution
    _flareFadeSpeed = flareFadeSpeed
    _flareStrength = flareStrength
    _fog = fog
    _fogColor = fogColor
    _fogDensity = fogDensity
    _fogEndDistance = fogEndDistance
    _fogMode = fogMode.value
    _fogStartDistance = fogStartDistance
    _haloStrength = haloStrength
    _reflectionBounces = reflectionBounces
    _reflectionIntensity = reflectionIntensity
    _skybox = skybox
    _subtractiveShadowColor = subtractiveShadowColor
    _sun = sun
  }

  internal init() {
    _ambientEquatorColor = UnityEngine_Color()
    _ambientGroundColor = UnityEngine_Color()
    _ambientIntensity = 0.0
    _ambientLight = UnityEngine_Color()
    _ambientMode = 0
    _ambientProbe = Unity_PolySpatial_Internals_PolySpatialLightProbeData()
    _ambientSkyColor = UnityEngine_Color()
    _defaultReflectionMode = 0
    _defaultReflectionResolution = 0
    _flareFadeSpeed = 0.0
    _flareStrength = 0.0
    _fog = false
    _fogColor = UnityEngine_Color()
    _fogDensity = 0.0
    _fogEndDistance = 0.0
    _fogMode = 0
    _fogStartDistance = 0.0
    _haloStrength = 0.0
    _reflectionBounces = 0
    _reflectionIntensity = 0.0
    _skybox = Unity_PolySpatial_Internals_PolySpatialAssetID()
    _subtractiveShadowColor = UnityEngine_Color()
    _sun = Unity_PolySpatial_Internals_PolySpatialInstanceID()
  }

  internal var ambientEquatorColor: UnityEngine_Color { _ambientEquatorColor }
  internal var ambientGroundColor: UnityEngine_Color { _ambientGroundColor }
  internal var ambientIntensity: Float32 { _ambientIntensity }
  internal var ambientLight: UnityEngine_Color { _ambientLight }
  internal var ambientMode: Unity_PolySpatial_Internals_PolySpatialAmbientMode { Unity_PolySpatial_Internals_PolySpatialAmbientMode(rawValue: _ambientMode)! }
  internal var ambientProbe: Unity_PolySpatial_Internals_PolySpatialLightProbeData { _ambientProbe }
  internal var ambientSkyColor: UnityEngine_Color { _ambientSkyColor }
  internal var defaultReflectionMode: Unity_PolySpatial_Internals_PolySpatialDefaultReflectionMode { Unity_PolySpatial_Internals_PolySpatialDefaultReflectionMode(rawValue: _defaultReflectionMode)! }
  internal var defaultReflectionResolution: Int32 { _defaultReflectionResolution }
  internal var flareFadeSpeed: Float32 { _flareFadeSpeed }
  internal var flareStrength: Float32 { _flareStrength }
  internal var fog: Bool { _fog }
  internal var fogColor: UnityEngine_Color { _fogColor }
  internal var fogDensity: Float32 { _fogDensity }
  internal var fogEndDistance: Float32 { _fogEndDistance }
  internal var fogMode: Unity_PolySpatial_Internals_PolySpatialFogMode { Unity_PolySpatial_Internals_PolySpatialFogMode(rawValue: _fogMode)! }
  internal var fogStartDistance: Float32 { _fogStartDistance }
  internal var haloStrength: Float32 { _haloStrength }
  internal var reflectionBounces: Int32 { _reflectionBounces }
  internal var reflectionIntensity: Float32 { _reflectionIntensity }
  internal var skybox: Unity_PolySpatial_Internals_PolySpatialAssetID { _skybox }
  internal var subtractiveShadowColor: UnityEngine_Color { _subtractiveShadowColor }
  internal var sun: Unity_PolySpatial_Internals_PolySpatialInstanceID { _sun }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialRenderSettingsData.self)
  }
}

///  Contains the render settings for a scene.  See the documentation for
///  https://docs.unity3d.com/6000.0/Documentation/ScriptReference/RenderSettings.html
internal struct Unity_PolySpatial_Internals_PolySpatialRenderSettingsData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var ambientEquatorColor: UnityEngine_Color_Mutable { return UnityEngine_Color_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var ambientGroundColor: UnityEngine_Color_Mutable { return UnityEngine_Color_Mutable(_accessor.bb, o: _accessor.postion + 16) }
  internal var ambientIntensity: Float32 { return _accessor.readBuffer(of: Float32.self, at: 32) }
  internal var ambientLight: UnityEngine_Color_Mutable { return UnityEngine_Color_Mutable(_accessor.bb, o: _accessor.postion + 36) }
  internal var ambientMode: Unity_PolySpatial_Internals_PolySpatialAmbientMode { return Unity_PolySpatial_Internals_PolySpatialAmbientMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 52)) ?? .skybox }
  internal var ambientProbe: Unity_PolySpatial_Internals_PolySpatialLightProbeData_Mutable { return Unity_PolySpatial_Internals_PolySpatialLightProbeData_Mutable(_accessor.bb, o: _accessor.postion + 56) }
  internal var ambientSkyColor: UnityEngine_Color_Mutable { return UnityEngine_Color_Mutable(_accessor.bb, o: _accessor.postion + 164) }
  internal var defaultReflectionMode: Unity_PolySpatial_Internals_PolySpatialDefaultReflectionMode { return Unity_PolySpatial_Internals_PolySpatialDefaultReflectionMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 180)) ?? .skybox }
  internal var defaultReflectionResolution: Int32 { return _accessor.readBuffer(of: Int32.self, at: 184) }
  internal var flareFadeSpeed: Float32 { return _accessor.readBuffer(of: Float32.self, at: 188) }
  internal var flareStrength: Float32 { return _accessor.readBuffer(of: Float32.self, at: 192) }
  internal var fog: Bool { return _accessor.readBuffer(of: Bool.self, at: 196) }
  internal var fogColor: UnityEngine_Color_Mutable { return UnityEngine_Color_Mutable(_accessor.bb, o: _accessor.postion + 200) }
  internal var fogDensity: Float32 { return _accessor.readBuffer(of: Float32.self, at: 216) }
  internal var fogEndDistance: Float32 { return _accessor.readBuffer(of: Float32.self, at: 220) }
  internal var fogMode: Unity_PolySpatial_Internals_PolySpatialFogMode { return Unity_PolySpatial_Internals_PolySpatialFogMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 224)) ?? .unused }
  internal var fogStartDistance: Float32 { return _accessor.readBuffer(of: Float32.self, at: 228) }
  internal var haloStrength: Float32 { return _accessor.readBuffer(of: Float32.self, at: 232) }
  internal var reflectionBounces: Int32 { return _accessor.readBuffer(of: Int32.self, at: 236) }
  internal var reflectionIntensity: Float32 { return _accessor.readBuffer(of: Float32.self, at: 240) }
  internal var skybox: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable { return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.postion + 248) }
  internal var subtractiveShadowColor: UnityEngine_Color_Mutable { return UnityEngine_Color_Mutable(_accessor.bb, o: _accessor.postion + 272) }
  internal var sun: Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable { return Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable(_accessor.bb, o: _accessor.postion + 288) }
}

///  Contains the graphics settings.  See the documentation for
///  https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rendering.GraphicsSettings.html
internal struct Unity_PolySpatial_Internals_PolySpatialGraphicsSettingsData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _currentRenderPipeline: Unity_PolySpatial_Internals_PolySpatialAssetID

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _currentRenderPipeline = Unity_PolySpatial_Internals_PolySpatialAssetID(_accessor.bb, o: _accessor.postion + 0)
  }

  internal init(currentRenderPipeline: Unity_PolySpatial_Internals_PolySpatialAssetID) {
    _currentRenderPipeline = currentRenderPipeline
  }

  internal init() {
    _currentRenderPipeline = Unity_PolySpatial_Internals_PolySpatialAssetID()
  }

  internal var currentRenderPipeline: Unity_PolySpatial_Internals_PolySpatialAssetID { _currentRenderPipeline }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialGraphicsSettingsData.self)
  }
}

///  Contains the graphics settings.  See the documentation for
///  https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rendering.GraphicsSettings.html
internal struct Unity_PolySpatial_Internals_PolySpatialGraphicsSettingsData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var currentRenderPipeline: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable { return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.postion + 0) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleBurst: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _time: Float32
  private var _count: Float32
  private var _cycles: Int32
  private var _interval: Float32
  private var _probability: Float32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _time = _accessor.readBuffer(of: Float32.self, at: 0)
    _count = _accessor.readBuffer(of: Float32.self, at: 4)
    _cycles = _accessor.readBuffer(of: Int32.self, at: 8)
    _interval = _accessor.readBuffer(of: Float32.self, at: 12)
    _probability = _accessor.readBuffer(of: Float32.self, at: 16)
  }

  internal init(time: Float32, count: Float32, cycles: Int32, interval: Float32, probability: Float32) {
    _time = time
    _count = count
    _cycles = cycles
    _interval = interval
    _probability = probability
  }

  internal init() {
    _time = 0.0
    _count = 0.0
    _cycles = 0
    _interval = 0.0
    _probability = 0.0
  }

  internal var time: Float32 { _time }
  internal var count: Float32 { _count }
  internal var cycles: Int32 { _cycles }
  internal var interval: Float32 { _interval }
  internal var probability: Float32 { _probability }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialParticleBurst.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleBurst_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var time: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  internal var count: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
  internal var cycles: Int32 { return _accessor.readBuffer(of: Int32.self, at: 8) }
  internal var interval: Float32 { return _accessor.readBuffer(of: Float32.self, at: 12) }
  internal var probability: Float32 { return _accessor.readBuffer(of: Float32.self, at: 16) }
}

///  Struct that captures the properties needed to recreate a minmax curve key.
internal struct Unity_PolySpatial_Internals_PolySpatialParticleCurveKey: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _time: Float32
  private var _value: Float32
  private var _inTangent: Float32
  private var _outTangent: Float32
  private var _inWeight: Float32
  private var _outWeight: Float32
  private var _weightedMode: Int32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _time = _accessor.readBuffer(of: Float32.self, at: 0)
    _value = _accessor.readBuffer(of: Float32.self, at: 4)
    _inTangent = _accessor.readBuffer(of: Float32.self, at: 8)
    _outTangent = _accessor.readBuffer(of: Float32.self, at: 12)
    _inWeight = _accessor.readBuffer(of: Float32.self, at: 16)
    _outWeight = _accessor.readBuffer(of: Float32.self, at: 20)
    _weightedMode = _accessor.readBuffer(of: Int32.self, at: 24)
  }

  internal init(time: Float32, value: Float32, inTangent: Float32, outTangent: Float32, inWeight: Float32, outWeight: Float32, weightedMode: Unity_PolySpatial_Internals_PolySpatialParticleCurveWeightedMode) {
    _time = time
    _value = value
    _inTangent = inTangent
    _outTangent = outTangent
    _inWeight = inWeight
    _outWeight = outWeight
    _weightedMode = weightedMode.value
  }

  internal init() {
    _time = 0.0
    _value = 0.0
    _inTangent = 0.0
    _outTangent = 0.0
    _inWeight = 0.0
    _outWeight = 0.0
    _weightedMode = 0
  }

  internal var time: Float32 { _time }
  internal var value: Float32 { _value }
  internal var inTangent: Float32 { _inTangent }
  internal var outTangent: Float32 { _outTangent }
  internal var inWeight: Float32 { _inWeight }
  internal var outWeight: Float32 { _outWeight }
  internal var weightedMode: Unity_PolySpatial_Internals_PolySpatialParticleCurveWeightedMode { Unity_PolySpatial_Internals_PolySpatialParticleCurveWeightedMode(rawValue: _weightedMode)! }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialParticleCurveKey.self)
  }
}

///  Struct that captures the properties needed to recreate a minmax curve key.
internal struct Unity_PolySpatial_Internals_PolySpatialParticleCurveKey_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var time: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  internal var value: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
  internal var inTangent: Float32 { return _accessor.readBuffer(of: Float32.self, at: 8) }
  internal var outTangent: Float32 { return _accessor.readBuffer(of: Float32.self, at: 12) }
  internal var inWeight: Float32 { return _accessor.readBuffer(of: Float32.self, at: 16) }
  internal var outWeight: Float32 { return _accessor.readBuffer(of: Float32.self, at: 20) }
  internal var weightedMode: Unity_PolySpatial_Internals_PolySpatialParticleCurveWeightedMode { return Unity_PolySpatial_Internals_PolySpatialParticleCurveWeightedMode(rawValue: _accessor.readBuffer(of: Int32.self, at: 24)) ?? .none_ }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleSubEmitter: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _id: Unity_PolySpatial_Internals_PolySpatialInstanceID
  private var _type: Int32
  private var _inherit: Int32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _id = Unity_PolySpatial_Internals_PolySpatialInstanceID(_accessor.bb, o: _accessor.postion + 0)
    _type = _accessor.readBuffer(of: Int32.self, at: 16)
    _inherit = _accessor.readBuffer(of: Int32.self, at: 20)
  }

  internal init(id: Unity_PolySpatial_Internals_PolySpatialInstanceID, type: Unity_PolySpatial_Internals_PolySpatialParticleSubEmitterType, inherit: Int32) {
    _id = id
    _type = type.value
    _inherit = inherit
  }

  internal init() {
    _id = Unity_PolySpatial_Internals_PolySpatialInstanceID()
    _type = 0
    _inherit = 0
  }

  internal var id: Unity_PolySpatial_Internals_PolySpatialInstanceID { _id }
  internal var type: Unity_PolySpatial_Internals_PolySpatialParticleSubEmitterType { Unity_PolySpatial_Internals_PolySpatialParticleSubEmitterType(rawValue: _type)! }
  internal var inherit: Int32 { _inherit }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialParticleSubEmitter.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleSubEmitter_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var id: Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable { return Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var type: Unity_PolySpatial_Internals_PolySpatialParticleSubEmitterType { return Unity_PolySpatial_Internals_PolySpatialParticleSubEmitterType(rawValue: _accessor.readBuffer(of: Int32.self, at: 16)) ?? .birth }
  internal var inherit: Int32 { return _accessor.readBuffer(of: Int32.self, at: 20) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialBillboardData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  "degree" that entity rotates towards camera.
  private var _blendFactor: Float32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _blendFactor = _accessor.readBuffer(of: Float32.self, at: 0)
  }

  internal init(blendFactor: Float32) {
    _blendFactor = blendFactor
  }

  internal init() {
    _blendFactor = 0.0
  }

  ///  "degree" that entity rotates towards camera.
  internal var blendFactor: Float32 { _blendFactor }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialBillboardData.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialBillboardData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var blendFactor: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
}

///  Wraps a PolySpatialCommand value that may be encoded with additional data (such as version)
///  This allows for extension methods to be written that can extract the separate values from the raw command value
internal struct Unity_PolySpatial_Internals_PolySpatialCommandHeader: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _rawValue: Int32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _rawValue = _accessor.readBuffer(of: Int32.self, at: 0)
  }

  internal init(rawValue: Int32) {
    _rawValue = rawValue
  }

  internal init() {
    _rawValue = 0
  }

  internal var rawValue: Int32 { _rawValue }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialCommandHeader.self)
  }
}

///  Wraps a PolySpatialCommand value that may be encoded with additional data (such as version)
///  This allows for extension methods to be written that can extract the separate values from the raw command value
internal struct Unity_PolySpatial_Internals_PolySpatialCommandHeader_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var rawValue: Int32 { return _accessor.readBuffer(of: Int32.self, at: 0) }
}

///  Wraps a PolySpatialHostCommand value that may be encoded with additional data (such as version)
internal struct Unity_PolySpatial_Internals_PolySpatialHostCommandHeader: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _rawValue: Int32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _rawValue = _accessor.readBuffer(of: Int32.self, at: 0)
  }

  internal init(rawValue: Int32) {
    _rawValue = rawValue
  }

  internal init() {
    _rawValue = 0
  }

  internal var rawValue: Int32 { _rawValue }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialHostCommandHeader.self)
  }
}

///  Wraps a PolySpatialHostCommand value that may be encoded with additional data (such as version)
internal struct Unity_PolySpatial_Internals_PolySpatialHostCommandHeader_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var rawValue: Int32 { return _accessor.readBuffer(of: Int32.self, at: 0) }
}

///  Modeled after UnityEngine.XR.ARSubsystems.TrackableId
internal struct Unity_PolySpatial_Internals_TrackableID: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  First 4 bytes of ID
  private var _subId1: UInt64
  ///  Second 4 bytes of ID
  private var _subId2: UInt64

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _subId1 = _accessor.readBuffer(of: UInt64.self, at: 0)
    _subId2 = _accessor.readBuffer(of: UInt64.self, at: 8)
  }

  internal init(subId1: UInt64, subId2: UInt64) {
    _subId1 = subId1
    _subId2 = subId2
  }

  internal init() {
    _subId1 = 0
    _subId2 = 0
  }

  ///  First 4 bytes of ID
  internal var subId1: UInt64 { _subId1 }
  ///  Second 4 bytes of ID
  internal var subId2: UInt64 { _subId2 }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_TrackableID.self)
  }
}

///  Modeled after UnityEngine.XR.ARSubsystems.TrackableId
internal struct Unity_PolySpatial_Internals_TrackableID_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var subId1: UInt64 { return _accessor.readBuffer(of: UInt64.self, at: 0) }
  internal var subId2: UInt64 { return _accessor.readBuffer(of: UInt64.self, at: 8) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialAlignmentMarkerData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The asset id of the texture depicting the fiducial marker.
  private var _textureAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID
  ///  The size of the fiducial marker.
  private var _size: UnityEngine_Vector2
  ///  The linear difference (in meters) allowed before making an alignment correction.
  private var _linearCorrectionThreshold: Float32
  ///  The angular difference (in degrees) allowed before making an alignment correction.
  private var _angularCorrectionThreshold: Float32
  ///  The linear speed (in meters per second) to use when correcting alignment.
  private var _linearCorrectionSpeed: Float32
  ///  The angular speed (in degrees per second) to use when correcting alignment.
  private var _angularCorrectionSpeed: Float32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _textureAssetId = Unity_PolySpatial_Internals_PolySpatialAssetID(_accessor.bb, o: _accessor.postion + 0)
    _size = UnityEngine_Vector2(_accessor.bb, o: _accessor.postion + 24)
    _linearCorrectionThreshold = _accessor.readBuffer(of: Float32.self, at: 32)
    _angularCorrectionThreshold = _accessor.readBuffer(of: Float32.self, at: 36)
    _linearCorrectionSpeed = _accessor.readBuffer(of: Float32.self, at: 40)
    _angularCorrectionSpeed = _accessor.readBuffer(of: Float32.self, at: 44)
  }

  internal init(textureAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID, size: UnityEngine_Vector2, linearCorrectionThreshold: Float32, angularCorrectionThreshold: Float32, linearCorrectionSpeed: Float32, angularCorrectionSpeed: Float32) {
    _textureAssetId = textureAssetId
    _size = size
    _linearCorrectionThreshold = linearCorrectionThreshold
    _angularCorrectionThreshold = angularCorrectionThreshold
    _linearCorrectionSpeed = linearCorrectionSpeed
    _angularCorrectionSpeed = angularCorrectionSpeed
  }

  internal init() {
    _textureAssetId = Unity_PolySpatial_Internals_PolySpatialAssetID()
    _size = UnityEngine_Vector2()
    _linearCorrectionThreshold = 0.0
    _angularCorrectionThreshold = 0.0
    _linearCorrectionSpeed = 0.0
    _angularCorrectionSpeed = 0.0
  }

  ///  The asset id of the texture depicting the fiducial marker.
  internal var textureAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID { _textureAssetId }
  ///  The size of the fiducial marker.
  internal var size: UnityEngine_Vector2 { _size }
  ///  The linear difference (in meters) allowed before making an alignment correction.
  internal var linearCorrectionThreshold: Float32 { _linearCorrectionThreshold }
  ///  The angular difference (in degrees) allowed before making an alignment correction.
  internal var angularCorrectionThreshold: Float32 { _angularCorrectionThreshold }
  ///  The linear speed (in meters per second) to use when correcting alignment.
  internal var linearCorrectionSpeed: Float32 { _linearCorrectionSpeed }
  ///  The angular speed (in degrees per second) to use when correcting alignment.
  internal var angularCorrectionSpeed: Float32 { _angularCorrectionSpeed }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialAlignmentMarkerData.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialAlignmentMarkerData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var textureAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable { return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  internal var size: UnityEngine_Vector2_Mutable { return UnityEngine_Vector2_Mutable(_accessor.bb, o: _accessor.postion + 24) }
  internal var linearCorrectionThreshold: Float32 { return _accessor.readBuffer(of: Float32.self, at: 32) }
  internal var angularCorrectionThreshold: Float32 { return _accessor.readBuffer(of: Float32.self, at: 36) }
  internal var linearCorrectionSpeed: Float32 { return _accessor.readBuffer(of: Float32.self, at: 40) }
  internal var angularCorrectionSpeed: Float32 { return _accessor.readBuffer(of: Float32.self, at: 44) }
}

///  Describes a visionOS hover effect.
internal struct Unity_PolySpatial_Internals_PolySpatialHoverEffectData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The desired type of hover effect.
  private var _type: Int32
  ///  The color of the hover effect (used for the Spotlight and Highlight types
  ///  as well as for the MaskingShader for Selectable UI images).
  private var _color: UnityEngine_Color
  ///  The "normal" color of the Selectable.  When (and only when) the color property is equal to this,
  ///  the MaskingShader switches to the hover color when hovered.
  private var _selectableNormalColor: UnityEngine_Color
  ///  The intensity of the hover effect (used for Spotlight and Highlight types).
  private var _intensityMultiplier: Float32
  ///  The duration in seconds over which the effect fades in (used for Shader type).
  private var _fadeInDuration: Float32
  ///  The duration in seconds over which the effect fades out (used for Shader type).
  private var _fadeOutDuration: Float32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _type = _accessor.readBuffer(of: Int32.self, at: 0)
    _color = UnityEngine_Color(_accessor.bb, o: _accessor.postion + 4)
    _selectableNormalColor = UnityEngine_Color(_accessor.bb, o: _accessor.postion + 20)
    _intensityMultiplier = _accessor.readBuffer(of: Float32.self, at: 36)
    _fadeInDuration = _accessor.readBuffer(of: Float32.self, at: 40)
    _fadeOutDuration = _accessor.readBuffer(of: Float32.self, at: 44)
  }

  internal init(type: Unity_PolySpatial_Internals_PolySpatialHoverEffectType, color: UnityEngine_Color, selectableNormalColor: UnityEngine_Color, intensityMultiplier: Float32, fadeInDuration: Float32, fadeOutDuration: Float32) {
    _type = type.value
    _color = color
    _selectableNormalColor = selectableNormalColor
    _intensityMultiplier = intensityMultiplier
    _fadeInDuration = fadeInDuration
    _fadeOutDuration = fadeOutDuration
  }

  internal init() {
    _type = 0
    _color = UnityEngine_Color()
    _selectableNormalColor = UnityEngine_Color()
    _intensityMultiplier = 0.0
    _fadeInDuration = 0.0
    _fadeOutDuration = 0.0
  }

  ///  The desired type of hover effect.
  internal var type: Unity_PolySpatial_Internals_PolySpatialHoverEffectType { Unity_PolySpatial_Internals_PolySpatialHoverEffectType(rawValue: _type)! }
  ///  The color of the hover effect (used for the Spotlight and Highlight types
  ///  as well as for the MaskingShader for Selectable UI images).
  internal var color: UnityEngine_Color { _color }
  ///  The "normal" color of the Selectable.  When (and only when) the color property is equal to this,
  ///  the MaskingShader switches to the hover color when hovered.
  internal var selectableNormalColor: UnityEngine_Color { _selectableNormalColor }
  ///  The intensity of the hover effect (used for Spotlight and Highlight types).
  internal var intensityMultiplier: Float32 { _intensityMultiplier }
  ///  The duration in seconds over which the effect fades in (used for Shader type).
  internal var fadeInDuration: Float32 { _fadeInDuration }
  ///  The duration in seconds over which the effect fades out (used for Shader type).
  internal var fadeOutDuration: Float32 { _fadeOutDuration }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialHoverEffectData.self)
  }
}

///  Describes a visionOS hover effect.
internal struct Unity_PolySpatial_Internals_PolySpatialHoverEffectData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var type: Unity_PolySpatial_Internals_PolySpatialHoverEffectType { return Unity_PolySpatial_Internals_PolySpatialHoverEffectType(rawValue: _accessor.readBuffer(of: Int32.self, at: 0)) ?? .spotlight }
  internal var color: UnityEngine_Color_Mutable { return UnityEngine_Color_Mutable(_accessor.bb, o: _accessor.postion + 4) }
  internal var selectableNormalColor: UnityEngine_Color_Mutable { return UnityEngine_Color_Mutable(_accessor.bb, o: _accessor.postion + 20) }
  internal var intensityMultiplier: Float32 { return _accessor.readBuffer(of: Float32.self, at: 36) }
  internal var fadeInDuration: Float32 { return _accessor.readBuffer(of: Float32.self, at: 40) }
  internal var fadeOutDuration: Float32 { return _accessor.readBuffer(of: Float32.self, at: 44) }
}

///  This type represents  a slimmed down version of the
///  [Resolution](https://docs.unity3d.com/ScriptReference/Resolution.html) class.
///  We will expand it to reflect all fields if and when needed.
internal struct Unity_PolySpatial_Internals_PolySpatialHostDisplayResolution: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The width of the screen in pixels.
  private var _width: Int32
  ///  The height of the screen in pixels.
  private var _height: Int32

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _width = _accessor.readBuffer(of: Int32.self, at: 0)
    _height = _accessor.readBuffer(of: Int32.self, at: 4)
  }

  internal init(width: Int32, height: Int32) {
    _width = width
    _height = height
  }

  internal init() {
    _width = 0
    _height = 0
  }

  ///  The width of the screen in pixels.
  internal var width: Int32 { _width }
  ///  The height of the screen in pixels.
  internal var height: Int32 { _height }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialHostDisplayResolution.self)
  }
}

///  This type represents  a slimmed down version of the
///  [Resolution](https://docs.unity3d.com/ScriptReference/Resolution.html) class.
///  We will expand it to reflect all fields if and when needed.
internal struct Unity_PolySpatial_Internals_PolySpatialHostDisplayResolution_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var width: Int32 { return _accessor.readBuffer(of: Int32.self, at: 0) }
  internal var height: Int32 { return _accessor.readBuffer(of: Int32.self, at: 4) }
}

internal struct Unity_PolySpatial_Internals_PolySpatialHaloData: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  ///  The size of the Halo.
  private var _size: Float32
  ///  The color of the Halo.
  private var _color: UnityEngine_Color

  internal init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _size = _accessor.readBuffer(of: Float32.self, at: 0)
    _color = UnityEngine_Color(_accessor.bb, o: _accessor.postion + 4)
  }

  internal init(size: Float32, color: UnityEngine_Color) {
    _size = size
    _color = color
  }

  internal init() {
    _size = 0.0
    _color = UnityEngine_Color()
  }

  ///  The size of the Halo.
  internal var size: Float32 { _size }
  ///  The color of the Halo.
  internal var color: UnityEngine_Color { _color }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Unity_PolySpatial_Internals_PolySpatialHaloData.self)
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialHaloData_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  internal var size: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  internal var color: UnityEngine_Color_Mutable { return UnityEngine_Color_Mutable(_accessor.bb, o: _accessor.postion + 4) }
}

internal struct Unity_PolySpatial_Internals_LogWithMarkup: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case log = 4
    case logLevel = 6
    case logTypes = 8
    case logValues = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var log: String? { let o = _accessor.offset(VTOFFSET.log.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var logSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.log.v) }
  internal var logLevel: Unity_PolySpatial_Internals_PolySpatialLogLevel { let o = _accessor.offset(VTOFFSET.logLevel.v); return o == 0 ? .exception : Unity_PolySpatial_Internals_PolySpatialLogLevel(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .exception }
  internal var hasLogTypes: Bool { let o = _accessor.offset(VTOFFSET.logTypes.v); return o == 0 ? false : true }
  internal var logTypesCount: Int32 { let o = _accessor.offset(VTOFFSET.logTypes.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func logTypes(at index: Int32) -> Unity_PolySpatial_Internals_LogMarkupType? { let o = _accessor.offset(VTOFFSET.logTypes.v); return o == 0 ? Unity_PolySpatial_Internals_LogMarkupType.instanceIdtoGameObject : Unity_PolySpatial_Internals_LogMarkupType(rawValue: _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4)) }
  internal var hasLogValues: Bool { let o = _accessor.offset(VTOFFSET.logValues.v); return o == 0 ? false : true }
  internal var logValuesCount: Int32 { let o = _accessor.offset(VTOFFSET.logValues.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func logValues(at index: Int32) -> Int64 { let o = _accessor.offset(VTOFFSET.logValues.v); return o == 0 ? 0 : _accessor.directRead(of: Int64.self, offset: _accessor.vector(at: o) + index * 8) }
  internal var logValues: [Int64] { return _accessor.getVector(at: VTOFFSET.logValues.v) ?? [] }
  internal var logValuesAsBuffer: UnsafeBufferPointer<Int64>? { return _accessor.getBufferPointer(at: VTOFFSET.logValues.v) }
  internal static func startLogWithMarkup(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  internal static func add(log: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: log, at: VTOFFSET.log.p) }
  internal static func add(logLevel: Unity_PolySpatial_Internals_PolySpatialLogLevel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: logLevel.rawValue, def: 0, at: VTOFFSET.logLevel.p) }
  internal static func addVectorOf(logTypes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: logTypes, at: VTOFFSET.logTypes.p) }
  internal static func addVectorOf(logValues: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: logValues, at: VTOFFSET.logValues.p) }
  internal static func endLogWithMarkup(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createLogWithMarkup(
    _ fbb: inout FlatBufferBuilder,
    logOffset log: Offset = Offset(),
    logLevel: Unity_PolySpatial_Internals_PolySpatialLogLevel = .exception,
    logTypesVectorOffset logTypes: Offset = Offset(),
    logValuesVectorOffset logValues: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_LogWithMarkup.startLogWithMarkup(&fbb)
    Unity_PolySpatial_Internals_LogWithMarkup.add(log: log, &fbb)
    Unity_PolySpatial_Internals_LogWithMarkup.add(logLevel: logLevel, &fbb)
    Unity_PolySpatial_Internals_LogWithMarkup.addVectorOf(logTypes: logTypes, &fbb)
    Unity_PolySpatial_Internals_LogWithMarkup.addVectorOf(logValues: logValues, &fbb)
    return Unity_PolySpatial_Internals_LogWithMarkup.endLogWithMarkup(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.log.p, fieldName: "log", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.logLevel.p, fieldName: "logLevel", required: false, type: Unity_PolySpatial_Internals_PolySpatialLogLevel.self)
    try _v.visit(field: VTOFFSET.logTypes.p, fieldName: "logTypes", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_LogMarkupType, Unity_PolySpatial_Internals_LogMarkupType>>.self)
    try _v.visit(field: VTOFFSET.logValues.p, fieldName: "logValues", required: false, type: ForwardOffset<Vector<Int64, Int64>>.self)
    _v.finish()
  }
}

///  Defines an array of console log messages
internal struct Unity_PolySpatial_Internals_ConsoleLogMessageData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case text = 4
    case stackTrace = 6
    case logLevel = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The console log messages
  internal var hasText: Bool { let o = _accessor.offset(VTOFFSET.text.v); return o == 0 ? false : true }
  internal var textCount: Int32 { let o = _accessor.offset(VTOFFSET.text.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func text(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.text.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  The console log stack traces
  internal var hasStackTrace: Bool { let o = _accessor.offset(VTOFFSET.stackTrace.v); return o == 0 ? false : true }
  internal var stackTraceCount: Int32 { let o = _accessor.offset(VTOFFSET.stackTrace.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func stackTrace(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.stackTrace.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  The console log levels or LogTypes
  internal var hasLogLevel: Bool { let o = _accessor.offset(VTOFFSET.logLevel.v); return o == 0 ? false : true }
  internal var logLevelCount: Int32 { let o = _accessor.offset(VTOFFSET.logLevel.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func logLevel(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialLogLevel? { let o = _accessor.offset(VTOFFSET.logLevel.v); return o == 0 ? Unity_PolySpatial_Internals_PolySpatialLogLevel.exception : Unity_PolySpatial_Internals_PolySpatialLogLevel(rawValue: _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4)) }
  internal static func startConsoleLogMessageData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  internal static func addVectorOf(text: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: text, at: VTOFFSET.text.p) }
  internal static func addVectorOf(stackTrace: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: stackTrace, at: VTOFFSET.stackTrace.p) }
  internal static func addVectorOf(logLevel: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: logLevel, at: VTOFFSET.logLevel.p) }
  internal static func endConsoleLogMessageData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createConsoleLogMessageData(
    _ fbb: inout FlatBufferBuilder,
    textVectorOffset text: Offset = Offset(),
    stackTraceVectorOffset stackTrace: Offset = Offset(),
    logLevelVectorOffset logLevel: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_ConsoleLogMessageData.startConsoleLogMessageData(&fbb)
    Unity_PolySpatial_Internals_ConsoleLogMessageData.addVectorOf(text: text, &fbb)
    Unity_PolySpatial_Internals_ConsoleLogMessageData.addVectorOf(stackTrace: stackTrace, &fbb)
    Unity_PolySpatial_Internals_ConsoleLogMessageData.addVectorOf(logLevel: logLevel, &fbb)
    return Unity_PolySpatial_Internals_ConsoleLogMessageData.endConsoleLogMessageData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.text.p, fieldName: "text", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.stackTrace.p, fieldName: "stackTrace", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.logLevel.p, fieldName: "logLevel", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialLogLevel, Unity_PolySpatial_Internals_PolySpatialLogLevel>>.self)
    _v.finish()
  }
}

///  Defines the mesh and set of materials applied to a PolySpatial entity
///  for rendering.
internal struct Unity_PolySpatial_Internals_PolySpatialRenderData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case meshId = 4
    case materialIds = 6
    case renderingLayerMask = 8
    case lightmap = 10
    case lightProbe = 12
    case reflectionProbes = 14
    case sortingGroup = 16
    case sortingOrder = 18
    case syncColliders = 20
    case staticBatchRootId = 22
    case shadowCastingMode = 24
    case rendererProperties = 26
    case localBounds = 28
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The asset id for the mesh asset that defines the shape of the entity.
  internal var meshId: Unity_PolySpatial_Internals_PolySpatialAssetID? { let o = _accessor.offset(VTOFFSET.meshId.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, at: o) }
  internal var mutableMeshId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable? { let o = _accessor.offset(VTOFFSET.meshId.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The set of materials that are applied to the entity. One material per
  ///  sub mesh. If there are fewer materials than sub meshes in the mesh, then
  ///  the last material is used for all remaining sub meshes.
  internal var hasMaterialIds: Bool { let o = _accessor.offset(VTOFFSET.materialIds.v); return o == 0 ? false : true }
  internal var materialIdsCount: Int32 { let o = _accessor.offset(VTOFFSET.materialIds.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func materialIds(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialAssetID? { let o = _accessor.offset(VTOFFSET.materialIds.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, offset: _accessor.vector(at: o) + index * 24) }
  internal var materialIdsAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialAssetID>? { return _accessor.getBufferPointer(at: VTOFFSET.materialIds.v) }
  internal func mutableMaterialIds(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable? { let o = _accessor.offset(VTOFFSET.materialIds.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 24) }
  internal var renderingLayerMask: UInt32 { let o = _accessor.offset(VTOFFSET.renderingLayerMask.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  internal var lightmap: Unity_PolySpatial_Internals_PolySpatialLightmapRenderData? { let o = _accessor.offset(VTOFFSET.lightmap.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialLightmapRenderData.self, at: o) }
  internal var mutableLightmap: Unity_PolySpatial_Internals_PolySpatialLightmapRenderData_Mutable? { let o = _accessor.offset(VTOFFSET.lightmap.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialLightmapRenderData_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var lightProbe: Unity_PolySpatial_Internals_PolySpatialLightProbeData? { let o = _accessor.offset(VTOFFSET.lightProbe.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialLightProbeData.self, at: o) }
  internal var mutableLightProbe: Unity_PolySpatial_Internals_PolySpatialLightProbeData_Mutable? { let o = _accessor.offset(VTOFFSET.lightProbe.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialLightProbeData_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var hasReflectionProbes: Bool { let o = _accessor.offset(VTOFFSET.reflectionProbes.v); return o == 0 ? false : true }
  internal var reflectionProbesCount: Int32 { let o = _accessor.offset(VTOFFSET.reflectionProbes.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func reflectionProbes(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialReflectionProbeData? { let o = _accessor.offset(VTOFFSET.reflectionProbes.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialReflectionProbeData.self, offset: _accessor.vector(at: o) + index * 32) }
  internal var reflectionProbesAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialReflectionProbeData>? { return _accessor.getBufferPointer(at: VTOFFSET.reflectionProbes.v) }
  internal func mutableReflectionProbes(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialReflectionProbeData_Mutable? { let o = _accessor.offset(VTOFFSET.reflectionProbes.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialReflectionProbeData_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 32) }
  internal var sortingGroup: Unity_PolySpatial_Internals_PolySpatialSortGroup { let o = _accessor.offset(VTOFFSET.sortingGroup.v); return o == 0 ? .default_ : Unity_PolySpatial_Internals_PolySpatialSortGroup(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .default_ }
  internal var sortingOrder: Int32 { let o = _accessor.offset(VTOFFSET.sortingOrder.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var syncColliders: Bool { let o = _accessor.offset(VTOFFSET.syncColliders.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var staticBatchRootId: Unity_PolySpatial_Internals_PolySpatialInstanceID? { let o = _accessor.offset(VTOFFSET.staticBatchRootId.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialInstanceID.self, at: o) }
  internal var mutableStaticBatchRootId: Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable? { let o = _accessor.offset(VTOFFSET.staticBatchRootId.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The manner in which the entity casts shadows (or doesn't, as the case may be).
  internal var shadowCastingMode: Unity_PolySpatial_Internals_PolySpatialShadowCastingMode { let o = _accessor.offset(VTOFFSET.shadowCastingMode.v); return o == 0 ? .off : Unity_PolySpatial_Internals_PolySpatialShadowCastingMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .off }
  ///  The additional renderer properties for for Unity->Unity component replication.
  internal var rendererProperties: Unity_PolySpatial_Internals_PolySpatialUnityRendererData? { let o = _accessor.offset(VTOFFSET.rendererProperties.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialUnityRendererData(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var localBounds: UnityEngine_Bounds? { let o = _accessor.offset(VTOFFSET.localBounds.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Bounds.self, at: o) }
  internal var mutableLocalBounds: UnityEngine_Bounds_Mutable? { let o = _accessor.offset(VTOFFSET.localBounds.v); return o == 0 ? nil : UnityEngine_Bounds_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal static func startPolySpatialRenderData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 13) }
  internal static func add(meshId: Unity_PolySpatial_Internals_PolySpatialAssetID?, _ fbb: inout FlatBufferBuilder) { guard let meshId = meshId else { return }; fbb.create(struct: meshId, position: VTOFFSET.meshId.p) }
  internal static func addVectorOf(materialIds: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: materialIds, at: VTOFFSET.materialIds.p) }
  internal static func startVectorOfMaterialIds(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialAssetID>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialAssetID>.alignment)
  }
  internal static func add(renderingLayerMask: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: renderingLayerMask, def: 0, at: VTOFFSET.renderingLayerMask.p) }
  internal static func add(lightmap: Unity_PolySpatial_Internals_PolySpatialLightmapRenderData?, _ fbb: inout FlatBufferBuilder) { guard let lightmap = lightmap else { return }; fbb.create(struct: lightmap, position: VTOFFSET.lightmap.p) }
  internal static func add(lightProbe: Unity_PolySpatial_Internals_PolySpatialLightProbeData?, _ fbb: inout FlatBufferBuilder) { guard let lightProbe = lightProbe else { return }; fbb.create(struct: lightProbe, position: VTOFFSET.lightProbe.p) }
  internal static func addVectorOf(reflectionProbes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: reflectionProbes, at: VTOFFSET.reflectionProbes.p) }
  internal static func startVectorOfReflectionProbes(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialReflectionProbeData>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialReflectionProbeData>.alignment)
  }
  internal static func add(sortingGroup: Unity_PolySpatial_Internals_PolySpatialSortGroup, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sortingGroup.rawValue, def: 0, at: VTOFFSET.sortingGroup.p) }
  internal static func add(sortingOrder: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sortingOrder, def: 0, at: VTOFFSET.sortingOrder.p) }
  internal static func add(syncColliders: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: syncColliders, def: false,
   at: VTOFFSET.syncColliders.p) }
  internal static func add(staticBatchRootId: Unity_PolySpatial_Internals_PolySpatialInstanceID?, _ fbb: inout FlatBufferBuilder) { guard let staticBatchRootId = staticBatchRootId else { return }; fbb.create(struct: staticBatchRootId, position: VTOFFSET.staticBatchRootId.p) }
  internal static func add(shadowCastingMode: Unity_PolySpatial_Internals_PolySpatialShadowCastingMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: shadowCastingMode.rawValue, def: 0, at: VTOFFSET.shadowCastingMode.p) }
  internal static func add(rendererProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rendererProperties, at: VTOFFSET.rendererProperties.p) }
  internal static func add(localBounds: UnityEngine_Bounds?, _ fbb: inout FlatBufferBuilder) { guard let localBounds = localBounds else { return }; fbb.create(struct: localBounds, position: VTOFFSET.localBounds.p) }
  internal static func endPolySpatialRenderData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialRenderData(
    _ fbb: inout FlatBufferBuilder,
    meshId: Unity_PolySpatial_Internals_PolySpatialAssetID? = nil,
    materialIdsVectorOffset materialIds: Offset = Offset(),
    renderingLayerMask: UInt32 = 0,
    lightmap: Unity_PolySpatial_Internals_PolySpatialLightmapRenderData? = nil,
    lightProbe: Unity_PolySpatial_Internals_PolySpatialLightProbeData? = nil,
    reflectionProbesVectorOffset reflectionProbes: Offset = Offset(),
    sortingGroup: Unity_PolySpatial_Internals_PolySpatialSortGroup = .default_,
    sortingOrder: Int32 = 0,
    syncColliders: Bool = false,
    staticBatchRootId: Unity_PolySpatial_Internals_PolySpatialInstanceID? = nil,
    shadowCastingMode: Unity_PolySpatial_Internals_PolySpatialShadowCastingMode = .off,
    rendererPropertiesOffset rendererProperties: Offset = Offset(),
    localBounds: UnityEngine_Bounds? = nil
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialRenderData.startPolySpatialRenderData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialRenderData.add(meshId: meshId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialRenderData.addVectorOf(materialIds: materialIds, &fbb)
    Unity_PolySpatial_Internals_PolySpatialRenderData.add(renderingLayerMask: renderingLayerMask, &fbb)
    Unity_PolySpatial_Internals_PolySpatialRenderData.add(lightmap: lightmap, &fbb)
    Unity_PolySpatial_Internals_PolySpatialRenderData.add(lightProbe: lightProbe, &fbb)
    Unity_PolySpatial_Internals_PolySpatialRenderData.addVectorOf(reflectionProbes: reflectionProbes, &fbb)
    Unity_PolySpatial_Internals_PolySpatialRenderData.add(sortingGroup: sortingGroup, &fbb)
    Unity_PolySpatial_Internals_PolySpatialRenderData.add(sortingOrder: sortingOrder, &fbb)
    Unity_PolySpatial_Internals_PolySpatialRenderData.add(syncColliders: syncColliders, &fbb)
    Unity_PolySpatial_Internals_PolySpatialRenderData.add(staticBatchRootId: staticBatchRootId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialRenderData.add(shadowCastingMode: shadowCastingMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialRenderData.add(rendererProperties: rendererProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialRenderData.add(localBounds: localBounds, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialRenderData.endPolySpatialRenderData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.meshId.p, fieldName: "meshId", required: false, type: Unity_PolySpatial_Internals_PolySpatialAssetID.self)
    try _v.visit(field: VTOFFSET.materialIds.p, fieldName: "materialIds", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialAssetID, Unity_PolySpatial_Internals_PolySpatialAssetID>>.self)
    try _v.visit(field: VTOFFSET.renderingLayerMask.p, fieldName: "renderingLayerMask", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.lightmap.p, fieldName: "lightmap", required: false, type: Unity_PolySpatial_Internals_PolySpatialLightmapRenderData.self)
    try _v.visit(field: VTOFFSET.lightProbe.p, fieldName: "lightProbe", required: false, type: Unity_PolySpatial_Internals_PolySpatialLightProbeData.self)
    try _v.visit(field: VTOFFSET.reflectionProbes.p, fieldName: "reflectionProbes", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialReflectionProbeData, Unity_PolySpatial_Internals_PolySpatialReflectionProbeData>>.self)
    try _v.visit(field: VTOFFSET.sortingGroup.p, fieldName: "sortingGroup", required: false, type: Unity_PolySpatial_Internals_PolySpatialSortGroup.self)
    try _v.visit(field: VTOFFSET.sortingOrder.p, fieldName: "sortingOrder", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.syncColliders.p, fieldName: "syncColliders", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.staticBatchRootId.p, fieldName: "staticBatchRootId", required: false, type: Unity_PolySpatial_Internals_PolySpatialInstanceID.self)
    try _v.visit(field: VTOFFSET.shadowCastingMode.p, fieldName: "shadowCastingMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialShadowCastingMode.self)
    try _v.visit(field: VTOFFSET.rendererProperties.p, fieldName: "rendererProperties", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialUnityRendererData>.self)
    try _v.visit(field: VTOFFSET.localBounds.p, fieldName: "localBounds", required: false, type: UnityEngine_Bounds.self)
    _v.finish()
  }
}

///  Defines the Renderer data not captured by PolySpatialRenderData specific for Unity->Unity communication.
internal struct Unity_PolySpatial_Internals_PolySpatialUnityRendererData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case shadowCastingMode = 4
    case dynamicOcclusion = 6
    case staticShadowCaster = 8
    case motionVectorGenerationMode = 10
    case sortingLayerName = 12
    case anchorOverride = 14
    case lightProbeUsage = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The manner in which the entity casts shadows (or doesn't, as the case may be).
  internal var shadowCastingMode: Unity_PolySpatial_Internals_PolySpatialShadowCastingMode { let o = _accessor.offset(VTOFFSET.shadowCastingMode.v); return o == 0 ? .off : Unity_PolySpatial_Internals_PolySpatialShadowCastingMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .off }
  ///  Whether the renderer supports dynamic occlusion.
  internal var dynamicOcclusion: Bool { let o = _accessor.offset(VTOFFSET.dynamicOcclusion.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  ///  When enabled, Unity considers this renderer as being static for the sake of shadow rendering.
  internal var staticShadowCaster: Bool { let o = _accessor.offset(VTOFFSET.staticShadowCaster.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  ///  The motion vector generation mode for the associated renderer.
  internal var motionVectorGenerationMode: Unity_PolySpatial_Internals_PolySpatialMotionVectorGenerationMode { let o = _accessor.offset(VTOFFSET.motionVectorGenerationMode.v); return o == 0 ? .camera : Unity_PolySpatial_Internals_PolySpatialMotionVectorGenerationMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .camera }
  ///  The sorting layer name for the associated renderer.
  internal var sortingLayerName: String? { let o = _accessor.offset(VTOFFSET.sortingLayerName.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var sortingLayerNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sortingLayerName.v) }
  ///  The light probe anchor override for the associated renderer.
  internal var anchorOverride: Unity_PolySpatial_Internals_PolySpatialInstanceID? { let o = _accessor.offset(VTOFFSET.anchorOverride.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialInstanceID.self, at: o) }
  internal var mutableAnchorOverride: Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable? { let o = _accessor.offset(VTOFFSET.anchorOverride.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The light probe usage for the associated renderer.
  internal var lightProbeUsage: Unity_PolySpatial_Internals_PolySpatialLightProbeUsage { let o = _accessor.offset(VTOFFSET.lightProbeUsage.v); return o == 0 ? .off : Unity_PolySpatial_Internals_PolySpatialLightProbeUsage(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .off }
  internal static func startPolySpatialUnityRendererData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  internal static func add(shadowCastingMode: Unity_PolySpatial_Internals_PolySpatialShadowCastingMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: shadowCastingMode.rawValue, def: 0, at: VTOFFSET.shadowCastingMode.p) }
  internal static func add(dynamicOcclusion: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dynamicOcclusion, def: false,
   at: VTOFFSET.dynamicOcclusion.p) }
  internal static func add(staticShadowCaster: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: staticShadowCaster, def: false,
   at: VTOFFSET.staticShadowCaster.p) }
  internal static func add(motionVectorGenerationMode: Unity_PolySpatial_Internals_PolySpatialMotionVectorGenerationMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: motionVectorGenerationMode.rawValue, def: 0, at: VTOFFSET.motionVectorGenerationMode.p) }
  internal static func add(sortingLayerName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sortingLayerName, at: VTOFFSET.sortingLayerName.p) }
  internal static func add(anchorOverride: Unity_PolySpatial_Internals_PolySpatialInstanceID?, _ fbb: inout FlatBufferBuilder) { guard let anchorOverride = anchorOverride else { return }; fbb.create(struct: anchorOverride, position: VTOFFSET.anchorOverride.p) }
  internal static func add(lightProbeUsage: Unity_PolySpatial_Internals_PolySpatialLightProbeUsage, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lightProbeUsage.rawValue, def: 0, at: VTOFFSET.lightProbeUsage.p) }
  internal static func endPolySpatialUnityRendererData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialUnityRendererData(
    _ fbb: inout FlatBufferBuilder,
    shadowCastingMode: Unity_PolySpatial_Internals_PolySpatialShadowCastingMode = .off,
    dynamicOcclusion: Bool = false,
    staticShadowCaster: Bool = false,
    motionVectorGenerationMode: Unity_PolySpatial_Internals_PolySpatialMotionVectorGenerationMode = .camera,
    sortingLayerNameOffset sortingLayerName: Offset = Offset(),
    anchorOverride: Unity_PolySpatial_Internals_PolySpatialInstanceID? = nil,
    lightProbeUsage: Unity_PolySpatial_Internals_PolySpatialLightProbeUsage = .off
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialUnityRendererData.startPolySpatialUnityRendererData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialUnityRendererData.add(shadowCastingMode: shadowCastingMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialUnityRendererData.add(dynamicOcclusion: dynamicOcclusion, &fbb)
    Unity_PolySpatial_Internals_PolySpatialUnityRendererData.add(staticShadowCaster: staticShadowCaster, &fbb)
    Unity_PolySpatial_Internals_PolySpatialUnityRendererData.add(motionVectorGenerationMode: motionVectorGenerationMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialUnityRendererData.add(sortingLayerName: sortingLayerName, &fbb)
    Unity_PolySpatial_Internals_PolySpatialUnityRendererData.add(anchorOverride: anchorOverride, &fbb)
    Unity_PolySpatial_Internals_PolySpatialUnityRendererData.add(lightProbeUsage: lightProbeUsage, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialUnityRendererData.endPolySpatialUnityRendererData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.shadowCastingMode.p, fieldName: "shadowCastingMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialShadowCastingMode.self)
    try _v.visit(field: VTOFFSET.dynamicOcclusion.p, fieldName: "dynamicOcclusion", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.staticShadowCaster.p, fieldName: "staticShadowCaster", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.motionVectorGenerationMode.p, fieldName: "motionVectorGenerationMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialMotionVectorGenerationMode.self)
    try _v.visit(field: VTOFFSET.sortingLayerName.p, fieldName: "sortingLayerName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.anchorOverride.p, fieldName: "anchorOverride", required: false, type: Unity_PolySpatial_Internals_PolySpatialInstanceID.self)
    try _v.visit(field: VTOFFSET.lightProbeUsage.p, fieldName: "lightProbeUsage", required: false, type: Unity_PolySpatial_Internals_PolySpatialLightProbeUsage.self)
    _v.finish()
  }
}

///  Table to describe an Animation Curve.
internal struct Unity_PolySpatial_Internals_PolySpatialAnimationCurve: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case keyBuffer = 4
    case postWrapMode = 6
    case preWrapMode = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The buffer that contains the keys of the curve.
  internal var hasKeyBuffer: Bool { let o = _accessor.offset(VTOFFSET.keyBuffer.v); return o == 0 ? false : true }
  internal var keyBufferCount: Int32 { let o = _accessor.offset(VTOFFSET.keyBuffer.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func keyBuffer(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialAnimationCurveKey? { let o = _accessor.offset(VTOFFSET.keyBuffer.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialAnimationCurveKey.self, offset: _accessor.vector(at: o) + index * 28) }
  internal var keyBufferAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialAnimationCurveKey>? { return _accessor.getBufferPointer(at: VTOFFSET.keyBuffer.v) }
  internal func mutableKeyBuffer(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialAnimationCurveKey_Mutable? { let o = _accessor.offset(VTOFFSET.keyBuffer.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAnimationCurveKey_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 28) }
  ///  The post wrap mode of the curve.
  internal var postWrapMode: Unity_PolySpatial_Internals_PolySpatialAnimationCurveWrapMode { let o = _accessor.offset(VTOFFSET.postWrapMode.v); return o == 0 ? .default_ : Unity_PolySpatial_Internals_PolySpatialAnimationCurveWrapMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .default_ }
  ///  The pre wrap mode of the curve.
  internal var preWrapMode: Unity_PolySpatial_Internals_PolySpatialAnimationCurveWrapMode { let o = _accessor.offset(VTOFFSET.preWrapMode.v); return o == 0 ? .default_ : Unity_PolySpatial_Internals_PolySpatialAnimationCurveWrapMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .default_ }
  internal static func startPolySpatialAnimationCurve(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  internal static func addVectorOf(keyBuffer: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: keyBuffer, at: VTOFFSET.keyBuffer.p) }
  internal static func startVectorOfKeyBuffer(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialAnimationCurveKey>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialAnimationCurveKey>.alignment)
  }
  internal static func add(postWrapMode: Unity_PolySpatial_Internals_PolySpatialAnimationCurveWrapMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: postWrapMode.rawValue, def: 0, at: VTOFFSET.postWrapMode.p) }
  internal static func add(preWrapMode: Unity_PolySpatial_Internals_PolySpatialAnimationCurveWrapMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: preWrapMode.rawValue, def: 0, at: VTOFFSET.preWrapMode.p) }
  internal static func endPolySpatialAnimationCurve(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialAnimationCurve(
    _ fbb: inout FlatBufferBuilder,
    keyBufferVectorOffset keyBuffer: Offset = Offset(),
    postWrapMode: Unity_PolySpatial_Internals_PolySpatialAnimationCurveWrapMode = .default_,
    preWrapMode: Unity_PolySpatial_Internals_PolySpatialAnimationCurveWrapMode = .default_
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialAnimationCurve.startPolySpatialAnimationCurve(&fbb)
    Unity_PolySpatial_Internals_PolySpatialAnimationCurve.addVectorOf(keyBuffer: keyBuffer, &fbb)
    Unity_PolySpatial_Internals_PolySpatialAnimationCurve.add(postWrapMode: postWrapMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialAnimationCurve.add(preWrapMode: preWrapMode, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialAnimationCurve.endPolySpatialAnimationCurve(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.keyBuffer.p, fieldName: "keyBuffer", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialAnimationCurveKey, Unity_PolySpatial_Internals_PolySpatialAnimationCurveKey>>.self)
    try _v.visit(field: VTOFFSET.postWrapMode.p, fieldName: "postWrapMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialAnimationCurveWrapMode.self)
    try _v.visit(field: VTOFFSET.preWrapMode.p, fieldName: "preWrapMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialAnimationCurveWrapMode.self)
    _v.finish()
  }
}

///  Table to describe a color gradient.
internal struct Unity_PolySpatial_Internals_PolySpatialGradient: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case mode = 4
    case gradientColorKeyBuffer = 6
    case gradientAlphaKeyBuffer = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The mode of the gradient.
  internal var mode: Unity_PolySpatial_Internals_PolySpatialGradientMode { let o = _accessor.offset(VTOFFSET.mode.v); return o == 0 ? .blend : Unity_PolySpatial_Internals_PolySpatialGradientMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .blend }
  ///  The color key buffer of the gradient.
  internal var hasGradientColorKeyBuffer: Bool { let o = _accessor.offset(VTOFFSET.gradientColorKeyBuffer.v); return o == 0 ? false : true }
  internal var gradientColorKeyBufferCount: Int32 { let o = _accessor.offset(VTOFFSET.gradientColorKeyBuffer.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func gradientColorKeyBuffer(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey? { let o = _accessor.offset(VTOFFSET.gradientColorKeyBuffer.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey.self, offset: _accessor.vector(at: o) + index * 8) }
  internal var gradientColorKeyBufferAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey>? { return _accessor.getBufferPointer(at: VTOFFSET.gradientColorKeyBuffer.v) }
  internal func mutableGradientColorKeyBuffer(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey_Mutable? { let o = _accessor.offset(VTOFFSET.gradientColorKeyBuffer.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 8) }
  ///  The alpha key buffer of the gradient.
  internal var hasGradientAlphaKeyBuffer: Bool { let o = _accessor.offset(VTOFFSET.gradientAlphaKeyBuffer.v); return o == 0 ? false : true }
  internal var gradientAlphaKeyBufferCount: Int32 { let o = _accessor.offset(VTOFFSET.gradientAlphaKeyBuffer.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func gradientAlphaKeyBuffer(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey? { let o = _accessor.offset(VTOFFSET.gradientAlphaKeyBuffer.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey.self, offset: _accessor.vector(at: o) + index * 8) }
  internal var gradientAlphaKeyBufferAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey>? { return _accessor.getBufferPointer(at: VTOFFSET.gradientAlphaKeyBuffer.v) }
  internal func mutableGradientAlphaKeyBuffer(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey_Mutable? { let o = _accessor.offset(VTOFFSET.gradientAlphaKeyBuffer.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 8) }
  internal static func startPolySpatialGradient(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  internal static func add(mode: Unity_PolySpatial_Internals_PolySpatialGradientMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mode.rawValue, def: 0, at: VTOFFSET.mode.p) }
  internal static func addVectorOf(gradientColorKeyBuffer: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: gradientColorKeyBuffer, at: VTOFFSET.gradientColorKeyBuffer.p) }
  internal static func startVectorOfGradientColorKeyBuffer(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey>.alignment)
  }
  internal static func addVectorOf(gradientAlphaKeyBuffer: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: gradientAlphaKeyBuffer, at: VTOFFSET.gradientAlphaKeyBuffer.p) }
  internal static func startVectorOfGradientAlphaKeyBuffer(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey>.alignment)
  }
  internal static func endPolySpatialGradient(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialGradient(
    _ fbb: inout FlatBufferBuilder,
    mode: Unity_PolySpatial_Internals_PolySpatialGradientMode = .blend,
    gradientColorKeyBufferVectorOffset gradientColorKeyBuffer: Offset = Offset(),
    gradientAlphaKeyBufferVectorOffset gradientAlphaKeyBuffer: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialGradient.startPolySpatialGradient(&fbb)
    Unity_PolySpatial_Internals_PolySpatialGradient.add(mode: mode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialGradient.addVectorOf(gradientColorKeyBuffer: gradientColorKeyBuffer, &fbb)
    Unity_PolySpatial_Internals_PolySpatialGradient.addVectorOf(gradientAlphaKeyBuffer: gradientAlphaKeyBuffer, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialGradient.endPolySpatialGradient(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.mode.p, fieldName: "mode", required: false, type: Unity_PolySpatial_Internals_PolySpatialGradientMode.self)
    try _v.visit(field: VTOFFSET.gradientColorKeyBuffer.p, fieldName: "gradientColorKeyBuffer", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey, Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey>>.self)
    try _v.visit(field: VTOFFSET.gradientAlphaKeyBuffer.p, fieldName: "gradientAlphaKeyBuffer", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey, Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey>>.self)
    _v.finish()
  }
}

///  A description of the render data for a canvas renderer.
internal struct Unity_PolySpatial_Internals_PolySpatialCanvasRendererData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case renderData = 4
    case color = 6
    case mainTextureId = 8
    case maskTextureId = 10
    case maskUvtransform = 12
    case clipRect = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The render data for this canvas renderer - data on mesh and materials.
  internal var renderData: Unity_PolySpatial_Internals_PolySpatialRenderData! { let o = _accessor.offset(VTOFFSET.renderData.v); return Unity_PolySpatial_Internals_PolySpatialRenderData(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  The color to apply to the renderer material.
  internal var color: UnityEngine_Color! { let o = _accessor.offset(VTOFFSET.color.v); return _accessor.readBuffer(of: UnityEngine_Color.self, at: o) }
  internal var mutableColor: UnityEngine_Color_Mutable! { let o = _accessor.offset(VTOFFSET.color.v); return UnityEngine_Color_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The main texture to apply to the renderer material, or an invalid ID if none.  Font materials don't
  internal var mainTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID! { let o = _accessor.offset(VTOFFSET.mainTextureId.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, at: o) }
  internal var mutableMainTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable! { let o = _accessor.offset(VTOFFSET.mainTextureId.v); return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The id of the mask texture to apply to the renderer material.
  internal var maskTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID! { let o = _accessor.offset(VTOFFSET.maskTextureId.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, at: o) }
  internal var mutableMaskTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable! { let o = _accessor.offset(VTOFFSET.maskTextureId.v); return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The UV transform for the UI mask.
  internal var maskUvtransform: UnityEngine_Matrix4x4! { let o = _accessor.offset(VTOFFSET.maskUvtransform.v); return _accessor.readBuffer(of: UnityEngine_Matrix4x4.self, at: o) }
  internal var mutableMaskUvtransform: UnityEngine_Matrix4x4_Mutable! { let o = _accessor.offset(VTOFFSET.maskUvtransform.v); return UnityEngine_Matrix4x4_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The clip rect for UI Masking.
  internal var clipRect: UnityEngine_Rect? { let o = _accessor.offset(VTOFFSET.clipRect.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Rect.self, at: o) }
  internal var mutableClipRect: UnityEngine_Rect_Mutable? { let o = _accessor.offset(VTOFFSET.clipRect.v); return o == 0 ? nil : UnityEngine_Rect_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal static func startPolySpatialCanvasRendererData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  internal static func add(renderData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: renderData, at: VTOFFSET.renderData.p) }
  internal static func add(color: UnityEngine_Color?, _ fbb: inout FlatBufferBuilder) { guard let color = color else { return }; fbb.create(struct: color, position: VTOFFSET.color.p) }
  internal static func add(mainTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID?, _ fbb: inout FlatBufferBuilder) { guard let mainTextureId = mainTextureId else { return }; fbb.create(struct: mainTextureId, position: VTOFFSET.mainTextureId.p) }
  internal static func add(maskTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID?, _ fbb: inout FlatBufferBuilder) { guard let maskTextureId = maskTextureId else { return }; fbb.create(struct: maskTextureId, position: VTOFFSET.maskTextureId.p) }
  internal static func add(maskUvtransform: UnityEngine_Matrix4x4?, _ fbb: inout FlatBufferBuilder) { guard let maskUvtransform = maskUvtransform else { return }; fbb.create(struct: maskUvtransform, position: VTOFFSET.maskUvtransform.p) }
  internal static func add(clipRect: UnityEngine_Rect?, _ fbb: inout FlatBufferBuilder) { guard let clipRect = clipRect else { return }; fbb.create(struct: clipRect, position: VTOFFSET.clipRect.p) }
  internal static func endPolySpatialCanvasRendererData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6, 8, 10, 12]); return end }
  internal static func createPolySpatialCanvasRendererData(
    _ fbb: inout FlatBufferBuilder,
    renderDataOffset renderData: Offset,
    color: UnityEngine_Color,
    mainTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID,
    maskTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID,
    maskUvtransform: UnityEngine_Matrix4x4,
    clipRect: UnityEngine_Rect? = nil
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialCanvasRendererData.startPolySpatialCanvasRendererData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialCanvasRendererData.add(renderData: renderData, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCanvasRendererData.add(color: color, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCanvasRendererData.add(mainTextureId: mainTextureId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCanvasRendererData.add(maskTextureId: maskTextureId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCanvasRendererData.add(maskUvtransform: maskUvtransform, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCanvasRendererData.add(clipRect: clipRect, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialCanvasRendererData.endPolySpatialCanvasRendererData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.renderData.p, fieldName: "renderData", required: true, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialRenderData>.self)
    try _v.visit(field: VTOFFSET.color.p, fieldName: "color", required: true, type: UnityEngine_Color.self)
    try _v.visit(field: VTOFFSET.mainTextureId.p, fieldName: "mainTextureId", required: true, type: Unity_PolySpatial_Internals_PolySpatialAssetID.self)
    try _v.visit(field: VTOFFSET.maskTextureId.p, fieldName: "maskTextureId", required: true, type: Unity_PolySpatial_Internals_PolySpatialAssetID.self)
    try _v.visit(field: VTOFFSET.maskUvtransform.p, fieldName: "maskUvtransform", required: true, type: UnityEngine_Matrix4x4.self)
    try _v.visit(field: VTOFFSET.clipRect.p, fieldName: "clipRect", required: false, type: UnityEngine_Rect.self)
    _v.finish()
  }
}

///  Contains versioning and capabilities information sent when establishing a
///  connection.
internal struct Unity_PolySpatial_Internals_PolySpatialConnectionData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case protocolVersion = 4
    case polySpatialApiMagicCookie = 6
    case runtimePlatform = 8
    case unityVersion = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Must be NetMessageConnection.ProtocolVersion
  internal var protocolVersion: UInt32 { let o = _accessor.offset(VTOFFSET.protocolVersion.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  ///  Must match the local PolySpatial magic cookie or the connection will fail
  internal var polySpatialApiMagicCookie: UInt64 { let o = _accessor.offset(VTOFFSET.polySpatialApiMagicCookie.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  ///  The UnityEngine.RuntimePlatform of the sender (Application.platform),
  /// encoded as a uint
  internal var runtimePlatform: UInt32 { let o = _accessor.offset(VTOFFSET.runtimePlatform.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  ///  The unity version of the host, expressed as a string
  internal var unityVersion: String? { let o = _accessor.offset(VTOFFSET.unityVersion.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var unityVersionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.unityVersion.v) }
  internal static func startPolySpatialConnectionData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  internal static func add(protocolVersion: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: protocolVersion, def: 0, at: VTOFFSET.protocolVersion.p) }
  internal static func add(polySpatialApiMagicCookie: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: polySpatialApiMagicCookie, def: 0, at: VTOFFSET.polySpatialApiMagicCookie.p) }
  internal static func add(runtimePlatform: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: runtimePlatform, def: 0, at: VTOFFSET.runtimePlatform.p) }
  internal static func add(unityVersion: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: unityVersion, at: VTOFFSET.unityVersion.p) }
  internal static func endPolySpatialConnectionData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialConnectionData(
    _ fbb: inout FlatBufferBuilder,
    protocolVersion: UInt32 = 0,
    polySpatialApiMagicCookie: UInt64 = 0,
    runtimePlatform: UInt32 = 0,
    unityVersionOffset unityVersion: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialConnectionData.startPolySpatialConnectionData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialConnectionData.add(protocolVersion: protocolVersion, &fbb)
    Unity_PolySpatial_Internals_PolySpatialConnectionData.add(polySpatialApiMagicCookie: polySpatialApiMagicCookie, &fbb)
    Unity_PolySpatial_Internals_PolySpatialConnectionData.add(runtimePlatform: runtimePlatform, &fbb)
    Unity_PolySpatial_Internals_PolySpatialConnectionData.add(unityVersion: unityVersion, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialConnectionData.endPolySpatialConnectionData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.protocolVersion.p, fieldName: "protocolVersion", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.polySpatialApiMagicCookie.p, fieldName: "polySpatialApiMagicCookie", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.runtimePlatform.p, fieldName: "runtimePlatform", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.unityVersion.p, fieldName: "unityVersion", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Contains information related to connection end-of-life
internal struct Unity_PolySpatial_Internals_PolySpatialEndConnectionData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case errorCode = 4
    case errorMessage = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Machine-friendly error code; will be None if no error occurred
  internal var errorCode: Unity_PolySpatial_Internals_ErrorCode { let o = _accessor.offset(VTOFFSET.errorCode.v); return o == 0 ? .none_ : Unity_PolySpatial_Internals_ErrorCode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .none_ }
  ///  A human-readable error message that's non-empty when an error case was encountered
  internal var errorMessage: String? { let o = _accessor.offset(VTOFFSET.errorMessage.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var errorMessageSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.errorMessage.v) }
  internal static func startPolySpatialEndConnectionData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  internal static func add(errorCode: Unity_PolySpatial_Internals_ErrorCode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: errorCode.rawValue, def: 0, at: VTOFFSET.errorCode.p) }
  internal static func add(errorMessage: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: errorMessage, at: VTOFFSET.errorMessage.p) }
  internal static func endPolySpatialEndConnectionData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialEndConnectionData(
    _ fbb: inout FlatBufferBuilder,
    errorCode: Unity_PolySpatial_Internals_ErrorCode = .none_,
    errorMessageOffset errorMessage: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialEndConnectionData.startPolySpatialEndConnectionData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialEndConnectionData.add(errorCode: errorCode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialEndConnectionData.add(errorMessage: errorMessage, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialEndConnectionData.endPolySpatialEndConnectionData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.errorCode.p, fieldName: "errorCode", required: false, type: Unity_PolySpatial_Internals_ErrorCode.self)
    try _v.visit(field: VTOFFSET.errorMessage.p, fieldName: "errorMessage", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Contains information sent when creating a new session
internal struct Unity_PolySpatial_Internals_PolySpatialSessionData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case productName = 4
    case capabilities = 6
    case particleReplicationMode = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The productName of the app
  internal var productName: String? { let o = _accessor.offset(VTOFFSET.productName.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var productNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.productName.v) }
  ///  The capabilities of the host platform
  internal var capabilities: Unity_PolySpatial_Internals_PolySpatialPlatformCapabilities? { let o = _accessor.offset(VTOFFSET.capabilities.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialPlatformCapabilities.self, at: o) }
  internal var mutableCapabilities: Unity_PolySpatial_Internals_PolySpatialPlatformCapabilities_Mutable? { let o = _accessor.offset(VTOFFSET.capabilities.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialPlatformCapabilities_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The way in which particles will be encoded & replicated over the polyspatial protocol - for example,
  ///  by replicating properties and rendering locally, baking to mesh & materia, etc.
  internal var particleReplicationMode: Unity_PolySpatial_Internals_ParticleReplicationMode { let o = _accessor.offset(VTOFFSET.particleReplicationMode.v); return o == 0 ? .replicateProperties : Unity_PolySpatial_Internals_ParticleReplicationMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .replicateProperties }
  internal static func startPolySpatialSessionData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  internal static func add(productName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: productName, at: VTOFFSET.productName.p) }
  internal static func add(capabilities: Unity_PolySpatial_Internals_PolySpatialPlatformCapabilities?, _ fbb: inout FlatBufferBuilder) { guard let capabilities = capabilities else { return }; fbb.create(struct: capabilities, position: VTOFFSET.capabilities.p) }
  internal static func add(particleReplicationMode: Unity_PolySpatial_Internals_ParticleReplicationMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: particleReplicationMode.rawValue, def: 0, at: VTOFFSET.particleReplicationMode.p) }
  internal static func endPolySpatialSessionData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialSessionData(
    _ fbb: inout FlatBufferBuilder,
    productNameOffset productName: Offset = Offset(),
    capabilities: Unity_PolySpatial_Internals_PolySpatialPlatformCapabilities? = nil,
    particleReplicationMode: Unity_PolySpatial_Internals_ParticleReplicationMode = .replicateProperties
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialSessionData.startPolySpatialSessionData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialSessionData.add(productName: productName, &fbb)
    Unity_PolySpatial_Internals_PolySpatialSessionData.add(capabilities: capabilities, &fbb)
    Unity_PolySpatial_Internals_PolySpatialSessionData.add(particleReplicationMode: particleReplicationMode, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialSessionData.endPolySpatialSessionData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.productName.p, fieldName: "productName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.capabilities.p, fieldName: "capabilities", required: false, type: Unity_PolySpatial_Internals_PolySpatialPlatformCapabilities.self)
    try _v.visit(field: VTOFFSET.particleReplicationMode.p, fieldName: "particleReplicationMode", required: false, type: Unity_PolySpatial_Internals_ParticleReplicationMode.self)
    _v.finish()
  }
}

///  Contains information related to session end-of-life
internal struct Unity_PolySpatial_Internals_PolySpatialEndSessionData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case productName = 4
    case errorCode = 6
    case errorMessage = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The productName of the app
  internal var productName: String? { let o = _accessor.offset(VTOFFSET.productName.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var productNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.productName.v) }
  ///  Machine-friendly error code; will be None if no error occurred
  internal var errorCode: Unity_PolySpatial_Internals_ErrorCode { let o = _accessor.offset(VTOFFSET.errorCode.v); return o == 0 ? .none_ : Unity_PolySpatial_Internals_ErrorCode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .none_ }
  ///  A human-readable error message that's non-empty when an error case was encountered
  internal var errorMessage: String? { let o = _accessor.offset(VTOFFSET.errorMessage.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var errorMessageSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.errorMessage.v) }
  internal static func startPolySpatialEndSessionData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  internal static func add(productName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: productName, at: VTOFFSET.productName.p) }
  internal static func add(errorCode: Unity_PolySpatial_Internals_ErrorCode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: errorCode.rawValue, def: 0, at: VTOFFSET.errorCode.p) }
  internal static func add(errorMessage: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: errorMessage, at: VTOFFSET.errorMessage.p) }
  internal static func endPolySpatialEndSessionData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialEndSessionData(
    _ fbb: inout FlatBufferBuilder,
    productNameOffset productName: Offset = Offset(),
    errorCode: Unity_PolySpatial_Internals_ErrorCode = .none_,
    errorMessageOffset errorMessage: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialEndSessionData.startPolySpatialEndSessionData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialEndSessionData.add(productName: productName, &fbb)
    Unity_PolySpatial_Internals_PolySpatialEndSessionData.add(errorCode: errorCode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialEndSessionData.add(errorMessage: errorMessage, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialEndSessionData.endPolySpatialEndSessionData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.productName.p, fieldName: "productName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.errorCode.p, fieldName: "errorCode", required: false, type: Unity_PolySpatial_Internals_ErrorCode.self)
    try _v.visit(field: VTOFFSET.errorMessage.p, fieldName: "errorMessage", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialVolumeCameraData_v0: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case position = 4
    case rotation = 6
    case scale = 8
    case dimensions = 10
    case outputMode = 12
    case outputDimensions = 14
    case scaleWithWindow = 16
    case windowOpen = 18
    case cullingMask = 20
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var position: UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.position.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector3.self, at: o) }
  internal var mutablePosition: UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.position.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var rotation: UnityEngine_Quaternion? { let o = _accessor.offset(VTOFFSET.rotation.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Quaternion.self, at: o) }
  internal var mutableRotation: UnityEngine_Quaternion_Mutable? { let o = _accessor.offset(VTOFFSET.rotation.v); return o == 0 ? nil : UnityEngine_Quaternion_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var scale: UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.scale.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector3.self, at: o) }
  internal var mutableScale: UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.scale.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var dimensions: UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.dimensions.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector3.self, at: o) }
  internal var mutableDimensions: UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.dimensions.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var outputMode: Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode { let o = _accessor.offset(VTOFFSET.outputMode.v); return o == 0 ? .bounded : Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode(rawValue: _accessor.readBuffer(of: Int16.self, at: o)) ?? .bounded }
  internal var outputDimensions: UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.outputDimensions.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector3.self, at: o) }
  internal var mutableOutputDimensions: UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.outputDimensions.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var scaleWithWindow: Bool { let o = _accessor.offset(VTOFFSET.scaleWithWindow.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var windowOpen: Bool { let o = _accessor.offset(VTOFFSET.windowOpen.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var hasCullingMask: Bool { let o = _accessor.offset(VTOFFSET.cullingMask.v); return o == 0 ? false : true }
  internal var cullingMaskCount: Int32 { let o = _accessor.offset(VTOFFSET.cullingMask.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func cullingMask(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.cullingMask.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  internal var cullingMask: [UInt8] { return _accessor.getVector(at: VTOFFSET.cullingMask.v) ?? [] }
  internal var cullingMaskAsBuffer: UnsafeBufferPointer<UInt8>? { return _accessor.getBufferPointer(at: VTOFFSET.cullingMask.v) }
  internal static func startPolySpatialVolumeCameraData_v0(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 9) }
  internal static func add(position: UnityEngine_Vector3?, _ fbb: inout FlatBufferBuilder) { guard let position = position else { return }; fbb.create(struct: position, position: VTOFFSET.position.p) }
  internal static func add(rotation: UnityEngine_Quaternion?, _ fbb: inout FlatBufferBuilder) { guard let rotation = rotation else { return }; fbb.create(struct: rotation, position: VTOFFSET.rotation.p) }
  internal static func add(scale: UnityEngine_Vector3?, _ fbb: inout FlatBufferBuilder) { guard let scale = scale else { return }; fbb.create(struct: scale, position: VTOFFSET.scale.p) }
  internal static func add(dimensions: UnityEngine_Vector3?, _ fbb: inout FlatBufferBuilder) { guard let dimensions = dimensions else { return }; fbb.create(struct: dimensions, position: VTOFFSET.dimensions.p) }
  internal static func add(outputMode: Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: outputMode.rawValue, def: 0, at: VTOFFSET.outputMode.p) }
  internal static func add(outputDimensions: UnityEngine_Vector3?, _ fbb: inout FlatBufferBuilder) { guard let outputDimensions = outputDimensions else { return }; fbb.create(struct: outputDimensions, position: VTOFFSET.outputDimensions.p) }
  internal static func add(scaleWithWindow: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: scaleWithWindow, def: false,
   at: VTOFFSET.scaleWithWindow.p) }
  internal static func add(windowOpen: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: windowOpen, def: false,
   at: VTOFFSET.windowOpen.p) }
  internal static func addVectorOf(cullingMask: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: cullingMask, at: VTOFFSET.cullingMask.p) }
  internal static func endPolySpatialVolumeCameraData_v0(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialVolumeCameraData_v0(
    _ fbb: inout FlatBufferBuilder,
    position: UnityEngine_Vector3? = nil,
    rotation: UnityEngine_Quaternion? = nil,
    scale: UnityEngine_Vector3? = nil,
    dimensions: UnityEngine_Vector3? = nil,
    outputMode: Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode = .bounded,
    outputDimensions: UnityEngine_Vector3? = nil,
    scaleWithWindow: Bool = false,
    windowOpen: Bool = false,
    cullingMaskVectorOffset cullingMask: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialVolumeCameraData_v0.startPolySpatialVolumeCameraData_v0(&fbb)
    Unity_PolySpatial_Internals_PolySpatialVolumeCameraData_v0.add(position: position, &fbb)
    Unity_PolySpatial_Internals_PolySpatialVolumeCameraData_v0.add(rotation: rotation, &fbb)
    Unity_PolySpatial_Internals_PolySpatialVolumeCameraData_v0.add(scale: scale, &fbb)
    Unity_PolySpatial_Internals_PolySpatialVolumeCameraData_v0.add(dimensions: dimensions, &fbb)
    Unity_PolySpatial_Internals_PolySpatialVolumeCameraData_v0.add(outputMode: outputMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialVolumeCameraData_v0.add(outputDimensions: outputDimensions, &fbb)
    Unity_PolySpatial_Internals_PolySpatialVolumeCameraData_v0.add(scaleWithWindow: scaleWithWindow, &fbb)
    Unity_PolySpatial_Internals_PolySpatialVolumeCameraData_v0.add(windowOpen: windowOpen, &fbb)
    Unity_PolySpatial_Internals_PolySpatialVolumeCameraData_v0.addVectorOf(cullingMask: cullingMask, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialVolumeCameraData_v0.endPolySpatialVolumeCameraData_v0(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.position.p, fieldName: "position", required: false, type: UnityEngine_Vector3.self)
    try _v.visit(field: VTOFFSET.rotation.p, fieldName: "rotation", required: false, type: UnityEngine_Quaternion.self)
    try _v.visit(field: VTOFFSET.scale.p, fieldName: "scale", required: false, type: UnityEngine_Vector3.self)
    try _v.visit(field: VTOFFSET.dimensions.p, fieldName: "dimensions", required: false, type: UnityEngine_Vector3.self)
    try _v.visit(field: VTOFFSET.outputMode.p, fieldName: "outputMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialVolumeCameraMode.self)
    try _v.visit(field: VTOFFSET.outputDimensions.p, fieldName: "outputDimensions", required: false, type: UnityEngine_Vector3.self)
    try _v.visit(field: VTOFFSET.scaleWithWindow.p, fieldName: "scaleWithWindow", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.windowOpen.p, fieldName: "windowOpen", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.cullingMask.p, fieldName: "cullingMask", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialCameraData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case iid = 4
    case worldPosition = 6
    case worldRotation = 8
    case backgroundColor = 10
    case isOrthographic = 12
    case orthographicHalfSize = 14
    case aspectRatio = 16
    case fieldOfViewY = 18
    case focalLength = 20
    case nearClip = 22
    case farClip = 24
    case cullingMask = 26
    case clearFlags = 28
    case depth = 30
    case renderTextureId = 32
    case universalCameraData = 34
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var iid: Unity_PolySpatial_Internals_PolySpatialInstanceID! { let o = _accessor.offset(VTOFFSET.iid.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialInstanceID.self, at: o) }
  internal var mutableIid: Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable! { let o = _accessor.offset(VTOFFSET.iid.v); return Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var worldPosition: UnityEngine_Vector3! { let o = _accessor.offset(VTOFFSET.worldPosition.v); return _accessor.readBuffer(of: UnityEngine_Vector3.self, at: o) }
  internal var mutableWorldPosition: UnityEngine_Vector3_Mutable! { let o = _accessor.offset(VTOFFSET.worldPosition.v); return UnityEngine_Vector3_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var worldRotation: UnityEngine_Quaternion! { let o = _accessor.offset(VTOFFSET.worldRotation.v); return _accessor.readBuffer(of: UnityEngine_Quaternion.self, at: o) }
  internal var mutableWorldRotation: UnityEngine_Quaternion_Mutable! { let o = _accessor.offset(VTOFFSET.worldRotation.v); return UnityEngine_Quaternion_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var backgroundColor: UnityEngine_Color! { let o = _accessor.offset(VTOFFSET.backgroundColor.v); return _accessor.readBuffer(of: UnityEngine_Color.self, at: o) }
  internal var mutableBackgroundColor: UnityEngine_Color_Mutable! { let o = _accessor.offset(VTOFFSET.backgroundColor.v); return UnityEngine_Color_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var isOrthographic: Bool { let o = _accessor.offset(VTOFFSET.isOrthographic.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var orthographicHalfSize: Float32 { let o = _accessor.offset(VTOFFSET.orthographicHalfSize.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var aspectRatio: Float32 { let o = _accessor.offset(VTOFFSET.aspectRatio.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var fieldOfViewY: Float32 { let o = _accessor.offset(VTOFFSET.fieldOfViewY.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var focalLength: Float32 { let o = _accessor.offset(VTOFFSET.focalLength.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var nearClip: Float32 { let o = _accessor.offset(VTOFFSET.nearClip.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var farClip: Float32 { let o = _accessor.offset(VTOFFSET.farClip.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var cullingMask: Int32 { let o = _accessor.offset(VTOFFSET.cullingMask.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var clearFlags: Unity_PolySpatial_Internals_PolySpatialCameraClearFlags { let o = _accessor.offset(VTOFFSET.clearFlags.v); return o == 0 ? .unused : Unity_PolySpatial_Internals_PolySpatialCameraClearFlags(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .unused }
  internal var depth: Float32 { let o = _accessor.offset(VTOFFSET.depth.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var renderTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID? { let o = _accessor.offset(VTOFFSET.renderTextureId.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, at: o) }
  internal var mutableRenderTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable? { let o = _accessor.offset(VTOFFSET.renderTextureId.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var universalCameraData: Unity_PolySpatial_Internals_PolySpatialUniversalCameraData? { let o = _accessor.offset(VTOFFSET.universalCameraData.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialUniversalCameraData(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal static func startPolySpatialCameraData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 16) }
  internal static func add(iid: Unity_PolySpatial_Internals_PolySpatialInstanceID?, _ fbb: inout FlatBufferBuilder) { guard let iid = iid else { return }; fbb.create(struct: iid, position: VTOFFSET.iid.p) }
  internal static func add(worldPosition: UnityEngine_Vector3?, _ fbb: inout FlatBufferBuilder) { guard let worldPosition = worldPosition else { return }; fbb.create(struct: worldPosition, position: VTOFFSET.worldPosition.p) }
  internal static func add(worldRotation: UnityEngine_Quaternion?, _ fbb: inout FlatBufferBuilder) { guard let worldRotation = worldRotation else { return }; fbb.create(struct: worldRotation, position: VTOFFSET.worldRotation.p) }
  internal static func add(backgroundColor: UnityEngine_Color?, _ fbb: inout FlatBufferBuilder) { guard let backgroundColor = backgroundColor else { return }; fbb.create(struct: backgroundColor, position: VTOFFSET.backgroundColor.p) }
  internal static func add(isOrthographic: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isOrthographic, def: false,
   at: VTOFFSET.isOrthographic.p) }
  internal static func add(orthographicHalfSize: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: orthographicHalfSize, def: 0.0, at: VTOFFSET.orthographicHalfSize.p) }
  internal static func add(aspectRatio: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: aspectRatio, def: 0.0, at: VTOFFSET.aspectRatio.p) }
  internal static func add(fieldOfViewY: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fieldOfViewY, def: 0.0, at: VTOFFSET.fieldOfViewY.p) }
  internal static func add(focalLength: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: focalLength, def: 0.0, at: VTOFFSET.focalLength.p) }
  internal static func add(nearClip: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: nearClip, def: 0.0, at: VTOFFSET.nearClip.p) }
  internal static func add(farClip: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: farClip, def: 0.0, at: VTOFFSET.farClip.p) }
  internal static func add(cullingMask: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: cullingMask, def: 0, at: VTOFFSET.cullingMask.p) }
  internal static func add(clearFlags: Unity_PolySpatial_Internals_PolySpatialCameraClearFlags, _ fbb: inout FlatBufferBuilder) { fbb.add(element: clearFlags.rawValue, def: 0, at: VTOFFSET.clearFlags.p) }
  internal static func add(depth: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: depth, def: 0.0, at: VTOFFSET.depth.p) }
  internal static func add(renderTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID?, _ fbb: inout FlatBufferBuilder) { guard let renderTextureId = renderTextureId else { return }; fbb.create(struct: renderTextureId, position: VTOFFSET.renderTextureId.p) }
  internal static func add(universalCameraData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: universalCameraData, at: VTOFFSET.universalCameraData.p) }
  internal static func endPolySpatialCameraData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6, 8, 10]); return end }
  internal static func createPolySpatialCameraData(
    _ fbb: inout FlatBufferBuilder,
    iid: Unity_PolySpatial_Internals_PolySpatialInstanceID,
    worldPosition: UnityEngine_Vector3,
    worldRotation: UnityEngine_Quaternion,
    backgroundColor: UnityEngine_Color,
    isOrthographic: Bool = false,
    orthographicHalfSize: Float32 = 0.0,
    aspectRatio: Float32 = 0.0,
    fieldOfViewY: Float32 = 0.0,
    focalLength: Float32 = 0.0,
    nearClip: Float32 = 0.0,
    farClip: Float32 = 0.0,
    cullingMask: Int32 = 0,
    clearFlags: Unity_PolySpatial_Internals_PolySpatialCameraClearFlags = .unused,
    depth: Float32 = 0.0,
    renderTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID? = nil,
    universalCameraDataOffset universalCameraData: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialCameraData.startPolySpatialCameraData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialCameraData.add(iid: iid, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCameraData.add(worldPosition: worldPosition, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCameraData.add(worldRotation: worldRotation, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCameraData.add(backgroundColor: backgroundColor, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCameraData.add(isOrthographic: isOrthographic, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCameraData.add(orthographicHalfSize: orthographicHalfSize, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCameraData.add(aspectRatio: aspectRatio, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCameraData.add(fieldOfViewY: fieldOfViewY, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCameraData.add(focalLength: focalLength, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCameraData.add(nearClip: nearClip, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCameraData.add(farClip: farClip, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCameraData.add(cullingMask: cullingMask, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCameraData.add(clearFlags: clearFlags, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCameraData.add(depth: depth, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCameraData.add(renderTextureId: renderTextureId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialCameraData.add(universalCameraData: universalCameraData, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialCameraData.endPolySpatialCameraData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.iid.p, fieldName: "iid", required: true, type: Unity_PolySpatial_Internals_PolySpatialInstanceID.self)
    try _v.visit(field: VTOFFSET.worldPosition.p, fieldName: "worldPosition", required: true, type: UnityEngine_Vector3.self)
    try _v.visit(field: VTOFFSET.worldRotation.p, fieldName: "worldRotation", required: true, type: UnityEngine_Quaternion.self)
    try _v.visit(field: VTOFFSET.backgroundColor.p, fieldName: "backgroundColor", required: true, type: UnityEngine_Color.self)
    try _v.visit(field: VTOFFSET.isOrthographic.p, fieldName: "isOrthographic", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.orthographicHalfSize.p, fieldName: "orthographicHalfSize", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.aspectRatio.p, fieldName: "aspectRatio", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.fieldOfViewY.p, fieldName: "fieldOfViewY", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.focalLength.p, fieldName: "focalLength", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.nearClip.p, fieldName: "nearClip", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.farClip.p, fieldName: "farClip", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.cullingMask.p, fieldName: "cullingMask", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.clearFlags.p, fieldName: "clearFlags", required: false, type: Unity_PolySpatial_Internals_PolySpatialCameraClearFlags.self)
    try _v.visit(field: VTOFFSET.depth.p, fieldName: "depth", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.renderTextureId.p, fieldName: "renderTextureId", required: false, type: Unity_PolySpatial_Internals_PolySpatialAssetID.self)
    try _v.visit(field: VTOFFSET.universalCameraData.p, fieldName: "universalCameraData", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialUniversalCameraData>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialUniversalCameraData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case renderPostProcessing = 4
    case renderType = 6
    case cameraStack = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var renderPostProcessing: Bool { let o = _accessor.offset(VTOFFSET.renderPostProcessing.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var renderType: Unity_PolySpatial_Internals_PolySpatialCameraRenderType { let o = _accessor.offset(VTOFFSET.renderType.v); return o == 0 ? .base : Unity_PolySpatial_Internals_PolySpatialCameraRenderType(rawValue: _accessor.readBuffer(of: Int16.self, at: o)) ?? .base }
  internal var hasCameraStack: Bool { let o = _accessor.offset(VTOFFSET.cameraStack.v); return o == 0 ? false : true }
  internal var cameraStackCount: Int32 { let o = _accessor.offset(VTOFFSET.cameraStack.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func cameraStack(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialInstanceID? { let o = _accessor.offset(VTOFFSET.cameraStack.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialInstanceID.self, offset: _accessor.vector(at: o) + index * 16) }
  internal var cameraStackAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialInstanceID>? { return _accessor.getBufferPointer(at: VTOFFSET.cameraStack.v) }
  internal func mutableCameraStack(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable? { let o = _accessor.offset(VTOFFSET.cameraStack.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 16) }
  internal static func startPolySpatialUniversalCameraData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  internal static func add(renderPostProcessing: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: renderPostProcessing, def: false,
   at: VTOFFSET.renderPostProcessing.p) }
  internal static func add(renderType: Unity_PolySpatial_Internals_PolySpatialCameraRenderType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: renderType.rawValue, def: 0, at: VTOFFSET.renderType.p) }
  internal static func addVectorOf(cameraStack: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: cameraStack, at: VTOFFSET.cameraStack.p) }
  internal static func startVectorOfCameraStack(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialInstanceID>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialInstanceID>.alignment)
  }
  internal static func endPolySpatialUniversalCameraData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialUniversalCameraData(
    _ fbb: inout FlatBufferBuilder,
    renderPostProcessing: Bool = false,
    renderType: Unity_PolySpatial_Internals_PolySpatialCameraRenderType = .base,
    cameraStackVectorOffset cameraStack: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialUniversalCameraData.startPolySpatialUniversalCameraData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialUniversalCameraData.add(renderPostProcessing: renderPostProcessing, &fbb)
    Unity_PolySpatial_Internals_PolySpatialUniversalCameraData.add(renderType: renderType, &fbb)
    Unity_PolySpatial_Internals_PolySpatialUniversalCameraData.addVectorOf(cameraStack: cameraStack, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialUniversalCameraData.endPolySpatialUniversalCameraData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.renderPostProcessing.p, fieldName: "renderPostProcessing", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.renderType.p, fieldName: "renderType", required: false, type: Unity_PolySpatial_Internals_PolySpatialCameraRenderType.self)
    try _v.visit(field: VTOFFSET.cameraStack.p, fieldName: "cameraStack", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialInstanceID, Unity_PolySpatial_Internals_PolySpatialInstanceID>>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialScreenshotRequest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case camera = 6
    case resolution = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var id: Unity_PolySpatial_Internals_PolySpatialAssetID? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, at: o) }
  internal var mutableId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var camera: Unity_PolySpatial_Internals_PolySpatialCameraData? { let o = _accessor.offset(VTOFFSET.camera.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialCameraData(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var resolution: UnityEngine_Vector2? { let o = _accessor.offset(VTOFFSET.resolution.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector2.self, at: o) }
  internal var mutableResolution: UnityEngine_Vector2_Mutable? { let o = _accessor.offset(VTOFFSET.resolution.v); return o == 0 ? nil : UnityEngine_Vector2_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal static func startPolySpatialScreenshotRequest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  internal static func add(id: Unity_PolySpatial_Internals_PolySpatialAssetID?, _ fbb: inout FlatBufferBuilder) { guard let id = id else { return }; fbb.create(struct: id, position: VTOFFSET.id.p) }
  internal static func add(camera: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: camera, at: VTOFFSET.camera.p) }
  internal static func add(resolution: UnityEngine_Vector2?, _ fbb: inout FlatBufferBuilder) { guard let resolution = resolution else { return }; fbb.create(struct: resolution, position: VTOFFSET.resolution.p) }
  internal static func endPolySpatialScreenshotRequest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialScreenshotRequest(
    _ fbb: inout FlatBufferBuilder,
    id: Unity_PolySpatial_Internals_PolySpatialAssetID? = nil,
    cameraOffset camera: Offset = Offset(),
    resolution: UnityEngine_Vector2? = nil
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialScreenshotRequest.startPolySpatialScreenshotRequest(&fbb)
    Unity_PolySpatial_Internals_PolySpatialScreenshotRequest.add(id: id, &fbb)
    Unity_PolySpatial_Internals_PolySpatialScreenshotRequest.add(camera: camera, &fbb)
    Unity_PolySpatial_Internals_PolySpatialScreenshotRequest.add(resolution: resolution, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialScreenshotRequest.endPolySpatialScreenshotRequest(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: Unity_PolySpatial_Internals_PolySpatialAssetID.self)
    try _v.visit(field: VTOFFSET.camera.p, fieldName: "camera", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialCameraData>.self)
    try _v.visit(field: VTOFFSET.resolution.p, fieldName: "resolution", required: false, type: UnityEngine_Vector2.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialScreenshotResult: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case data = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var id: Unity_PolySpatial_Internals_PolySpatialAssetID? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, at: o) }
  internal var mutableId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var hasData: Bool { let o = _accessor.offset(VTOFFSET.data.v); return o == 0 ? false : true }
  internal var dataCount: Int32 { let o = _accessor.offset(VTOFFSET.data.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func data(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.data.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  internal var data: [UInt8] { return _accessor.getVector(at: VTOFFSET.data.v) ?? [] }
  internal var dataAsBuffer: UnsafeBufferPointer<UInt8>? { return _accessor.getBufferPointer(at: VTOFFSET.data.v) }
  internal static func startPolySpatialScreenshotResult(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  internal static func add(id: Unity_PolySpatial_Internals_PolySpatialAssetID?, _ fbb: inout FlatBufferBuilder) { guard let id = id else { return }; fbb.create(struct: id, position: VTOFFSET.id.p) }
  internal static func addVectorOf(data: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: data, at: VTOFFSET.data.p) }
  internal static func endPolySpatialScreenshotResult(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialScreenshotResult(
    _ fbb: inout FlatBufferBuilder,
    id: Unity_PolySpatial_Internals_PolySpatialAssetID? = nil,
    dataVectorOffset data: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialScreenshotResult.startPolySpatialScreenshotResult(&fbb)
    Unity_PolySpatial_Internals_PolySpatialScreenshotResult.add(id: id, &fbb)
    Unity_PolySpatial_Internals_PolySpatialScreenshotResult.addVectorOf(data: data, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialScreenshotResult.endPolySpatialScreenshotResult(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: Unity_PolySpatial_Internals_PolySpatialAssetID.self)
    try _v.visit(field: VTOFFSET.data.p, fieldName: "data", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

///  A single set of texture coordinates within a mesh.
internal struct Unity_PolySpatial_Internals_PolySpatialTexCoords: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case data2 = 4
    case data3 = 6
    case data4 = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unity supports 2d, 3d, and 4d texture coordinates, so lists backed by
  ///  all three types are provided, but no more than one of these lists should
  ///  be non-null
  internal var hasData2: Bool { let o = _accessor.offset(VTOFFSET.data2.v); return o == 0 ? false : true }
  internal var data2Count: Int32 { let o = _accessor.offset(VTOFFSET.data2.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func data2(at index: Int32) -> UnityEngine_Vector2? { let o = _accessor.offset(VTOFFSET.data2.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector2.self, offset: _accessor.vector(at: o) + index * 8) }
  internal var data2AsBuffer: UnsafeBufferPointer<UnityEngine_Vector2>? { return _accessor.getBufferPointer(at: VTOFFSET.data2.v) }
  internal func mutableData2(at index: Int32) -> UnityEngine_Vector2_Mutable? { let o = _accessor.offset(VTOFFSET.data2.v); return o == 0 ? nil : UnityEngine_Vector2_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 8) }
  internal var hasData3: Bool { let o = _accessor.offset(VTOFFSET.data3.v); return o == 0 ? false : true }
  internal var data3Count: Int32 { let o = _accessor.offset(VTOFFSET.data3.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func data3(at index: Int32) -> UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.data3.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector3.self, offset: _accessor.vector(at: o) + index * 12) }
  internal var data3AsBuffer: UnsafeBufferPointer<UnityEngine_Vector3>? { return _accessor.getBufferPointer(at: VTOFFSET.data3.v) }
  internal func mutableData3(at index: Int32) -> UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.data3.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 12) }
  internal var hasData4: Bool { let o = _accessor.offset(VTOFFSET.data4.v); return o == 0 ? false : true }
  internal var data4Count: Int32 { let o = _accessor.offset(VTOFFSET.data4.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func data4(at index: Int32) -> UnityEngine_Vector4? { let o = _accessor.offset(VTOFFSET.data4.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector4.self, offset: _accessor.vector(at: o) + index * 16) }
  internal var data4AsBuffer: UnsafeBufferPointer<UnityEngine_Vector4>? { return _accessor.getBufferPointer(at: VTOFFSET.data4.v) }
  internal func mutableData4(at index: Int32) -> UnityEngine_Vector4_Mutable? { let o = _accessor.offset(VTOFFSET.data4.v); return o == 0 ? nil : UnityEngine_Vector4_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 16) }
  internal static func startPolySpatialTexCoords(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  internal static func addVectorOf(data2: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: data2, at: VTOFFSET.data2.p) }
  internal static func startVectorOfData2(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector2>.size, elementSize: MemoryLayout<UnityEngine_Vector2>.alignment)
  }
  internal static func addVectorOf(data3: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: data3, at: VTOFFSET.data3.p) }
  internal static func startVectorOfData3(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector3>.size, elementSize: MemoryLayout<UnityEngine_Vector3>.alignment)
  }
  internal static func addVectorOf(data4: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: data4, at: VTOFFSET.data4.p) }
  internal static func startVectorOfData4(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector4>.size, elementSize: MemoryLayout<UnityEngine_Vector4>.alignment)
  }
  internal static func endPolySpatialTexCoords(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialTexCoords(
    _ fbb: inout FlatBufferBuilder,
    data2VectorOffset data2: Offset = Offset(),
    data3VectorOffset data3: Offset = Offset(),
    data4VectorOffset data4: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialTexCoords.startPolySpatialTexCoords(&fbb)
    Unity_PolySpatial_Internals_PolySpatialTexCoords.addVectorOf(data2: data2, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTexCoords.addVectorOf(data3: data3, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTexCoords.addVectorOf(data4: data4, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialTexCoords.endPolySpatialTexCoords(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.data2.p, fieldName: "data2", required: false, type: ForwardOffset<Vector<UnityEngine_Vector2, UnityEngine_Vector2>>.self)
    try _v.visit(field: VTOFFSET.data3.p, fieldName: "data3", required: false, type: ForwardOffset<Vector<UnityEngine_Vector3, UnityEngine_Vector3>>.self)
    try _v.visit(field: VTOFFSET.data4.p, fieldName: "data4", required: false, type: ForwardOffset<Vector<UnityEngine_Vector4, UnityEngine_Vector4>>.self)
    _v.finish()
  }
}

///  A single frame within a blend shape.
internal struct Unity_PolySpatial_Internals_PolySpatialBlendShapeFrame: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case weight = 4
    case deltaVertices = 6
    case deltaNormals = 8
    case deltaTangents = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The weight of the frame.  When blend shapes are applied, either zero, one, or two frames will be scaled/added:
  ///  * If the target weight is zero, no frames will be added to the base vertices.
  ///  * If the target weight is less than or equal to the first frame's weight and/or there is only one frame, then
  ///  that frame will be scaled by the target weight over the frame weight and added to the result.
  ///  * Otherwise, the target weight will be between two frames, with the target weight being greater than or equal
  ///  to the first frame's weight.  The first frame will be scaled by (second weight - target weight) /
  ///  (second weight - first weight) and added to the result, and the second frame will be scaled by
  ///  (target weight - first weight) / (second weight - first weight) and added to the result.
  ///  Frames must be ordered by increasing weight, and the last frame must have weight 100.
  ///  See https://github.cds.internal.unity3d.com/unity/unity/blob/93a364f095f55c0e7616dc8d1638d6c6c37b5ad5/Runtime/Graphics/Mesh/MeshBlendShaping.cpp#L108
  internal var weight: Float32 { let o = _accessor.offset(VTOFFSET.weight.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  ///  Array of Vector3 vertex deltas, one for each vertex in the mesh.
  internal var hasDeltaVertices: Bool { let o = _accessor.offset(VTOFFSET.deltaVertices.v); return o == 0 ? false : true }
  internal var deltaVerticesCount: Int32 { let o = _accessor.offset(VTOFFSET.deltaVertices.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func deltaVertices(at index: Int32) -> UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.deltaVertices.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector3.self, offset: _accessor.vector(at: o) + index * 12) }
  internal var deltaVerticesAsBuffer: UnsafeBufferPointer<UnityEngine_Vector3>? { return _accessor.getBufferPointer(at: VTOFFSET.deltaVertices.v) }
  internal func mutableDeltaVertices(at index: Int32) -> UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.deltaVertices.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 12) }
  ///  Array of Vector3 normal deltas, one for each vertex in the mesh.
  internal var hasDeltaNormals: Bool { let o = _accessor.offset(VTOFFSET.deltaNormals.v); return o == 0 ? false : true }
  internal var deltaNormalsCount: Int32 { let o = _accessor.offset(VTOFFSET.deltaNormals.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func deltaNormals(at index: Int32) -> UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.deltaNormals.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector3.self, offset: _accessor.vector(at: o) + index * 12) }
  internal var deltaNormalsAsBuffer: UnsafeBufferPointer<UnityEngine_Vector3>? { return _accessor.getBufferPointer(at: VTOFFSET.deltaNormals.v) }
  internal func mutableDeltaNormals(at index: Int32) -> UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.deltaNormals.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 12) }
  ///  Array of Vector3 tangent deltas, one for each vertex in the mesh.
  internal var hasDeltaTangents: Bool { let o = _accessor.offset(VTOFFSET.deltaTangents.v); return o == 0 ? false : true }
  internal var deltaTangentsCount: Int32 { let o = _accessor.offset(VTOFFSET.deltaTangents.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func deltaTangents(at index: Int32) -> UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.deltaTangents.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector3.self, offset: _accessor.vector(at: o) + index * 12) }
  internal var deltaTangentsAsBuffer: UnsafeBufferPointer<UnityEngine_Vector3>? { return _accessor.getBufferPointer(at: VTOFFSET.deltaTangents.v) }
  internal func mutableDeltaTangents(at index: Int32) -> UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.deltaTangents.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 12) }
  internal static func startPolySpatialBlendShapeFrame(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  internal static func add(weight: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: weight, def: 0.0, at: VTOFFSET.weight.p) }
  internal static func addVectorOf(deltaVertices: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: deltaVertices, at: VTOFFSET.deltaVertices.p) }
  internal static func startVectorOfDeltaVertices(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector3>.size, elementSize: MemoryLayout<UnityEngine_Vector3>.alignment)
  }
  internal static func addVectorOf(deltaNormals: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: deltaNormals, at: VTOFFSET.deltaNormals.p) }
  internal static func startVectorOfDeltaNormals(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector3>.size, elementSize: MemoryLayout<UnityEngine_Vector3>.alignment)
  }
  internal static func addVectorOf(deltaTangents: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: deltaTangents, at: VTOFFSET.deltaTangents.p) }
  internal static func startVectorOfDeltaTangents(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector3>.size, elementSize: MemoryLayout<UnityEngine_Vector3>.alignment)
  }
  internal static func endPolySpatialBlendShapeFrame(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [6, 8, 10]); return end }
  internal static func createPolySpatialBlendShapeFrame(
    _ fbb: inout FlatBufferBuilder,
    weight: Float32 = 0.0,
    deltaVerticesVectorOffset deltaVertices: Offset,
    deltaNormalsVectorOffset deltaNormals: Offset,
    deltaTangentsVectorOffset deltaTangents: Offset
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialBlendShapeFrame.startPolySpatialBlendShapeFrame(&fbb)
    Unity_PolySpatial_Internals_PolySpatialBlendShapeFrame.add(weight: weight, &fbb)
    Unity_PolySpatial_Internals_PolySpatialBlendShapeFrame.addVectorOf(deltaVertices: deltaVertices, &fbb)
    Unity_PolySpatial_Internals_PolySpatialBlendShapeFrame.addVectorOf(deltaNormals: deltaNormals, &fbb)
    Unity_PolySpatial_Internals_PolySpatialBlendShapeFrame.addVectorOf(deltaTangents: deltaTangents, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialBlendShapeFrame.endPolySpatialBlendShapeFrame(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.weight.p, fieldName: "weight", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.deltaVertices.p, fieldName: "deltaVertices", required: true, type: ForwardOffset<Vector<UnityEngine_Vector3, UnityEngine_Vector3>>.self)
    try _v.visit(field: VTOFFSET.deltaNormals.p, fieldName: "deltaNormals", required: true, type: ForwardOffset<Vector<UnityEngine_Vector3, UnityEngine_Vector3>>.self)
    try _v.visit(field: VTOFFSET.deltaTangents.p, fieldName: "deltaTangents", required: true, type: ForwardOffset<Vector<UnityEngine_Vector3, UnityEngine_Vector3>>.self)
    _v.finish()
  }
}

///  A single blend shape within a mesh.
internal struct Unity_PolySpatial_Internals_PolySpatialBlendShape: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case name = 4
    case frames = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The name of the blend shape.
  internal var name: String! { let o = _accessor.offset(VTOFFSET.name.v); return _accessor.string(at: o) }
  internal var nameSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.name.v) }
  ///  The frames representing the blend shape at different weight levels.  Typical blend shapes have a single frame
  ///  with weight 100, but the range of blending may be split into multiple frames with increasing weights.
  internal var hasFrames: Bool { let o = _accessor.offset(VTOFFSET.frames.v); return o == 0 ? false : true }
  internal var framesCount: Int32 { let o = _accessor.offset(VTOFFSET.frames.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func frames(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialBlendShapeFrame? { let o = _accessor.offset(VTOFFSET.frames.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialBlendShapeFrame(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  internal static func startPolySpatialBlendShape(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  internal static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  internal static func addVectorOf(frames: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: frames, at: VTOFFSET.frames.p) }
  internal static func endPolySpatialBlendShape(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6]); return end }
  internal static func createPolySpatialBlendShape(
    _ fbb: inout FlatBufferBuilder,
    nameOffset name: Offset,
    framesVectorOffset frames: Offset
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialBlendShape.startPolySpatialBlendShape(&fbb)
    Unity_PolySpatial_Internals_PolySpatialBlendShape.add(name: name, &fbb)
    Unity_PolySpatial_Internals_PolySpatialBlendShape.addVectorOf(frames: frames, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialBlendShape.endPolySpatialBlendShape(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.frames.p, fieldName: "frames", required: true, type: ForwardOffset<Vector<ForwardOffset<Unity_PolySpatial_Internals_PolySpatialBlendShapeFrame>, Unity_PolySpatial_Internals_PolySpatialBlendShapeFrame>>.self)
    _v.finish()
  }
}

///  The fulle description of a mesh tracked by the PolySpatial system.
internal struct Unity_PolySpatial_Internals_PolySpatialMesh: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case vertices = 4
    case normals = 6
    case tangents = 8
    case colors = 10
    case texCoords = 12
    case indices16 = 14
    case indices32 = 16
    case bonesPerVertex = 18
    case boneWeights = 20
    case bindPoses = 22
    case subMeshes = 24
    case blendShapes = 26
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Array of Vector3 values, one for each vertex in this mesh.
  internal var hasVertices: Bool { let o = _accessor.offset(VTOFFSET.vertices.v); return o == 0 ? false : true }
  internal var verticesCount: Int32 { let o = _accessor.offset(VTOFFSET.vertices.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func vertices(at index: Int32) -> UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.vertices.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector3.self, offset: _accessor.vector(at: o) + index * 12) }
  internal var verticesAsBuffer: UnsafeBufferPointer<UnityEngine_Vector3>? { return _accessor.getBufferPointer(at: VTOFFSET.vertices.v) }
  internal func mutableVertices(at index: Int32) -> UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.vertices.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 12) }
  ///  Array of Vector3 values, one for each vertex normal in this mesh.
  ///  If available, assumed to be the same length as vertices.
  internal var hasNormals: Bool { let o = _accessor.offset(VTOFFSET.normals.v); return o == 0 ? false : true }
  internal var normalsCount: Int32 { let o = _accessor.offset(VTOFFSET.normals.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func normals(at index: Int32) -> UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.normals.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector3.self, offset: _accessor.vector(at: o) + index * 12) }
  internal var normalsAsBuffer: UnsafeBufferPointer<UnityEngine_Vector3>? { return _accessor.getBufferPointer(at: VTOFFSET.normals.v) }
  internal func mutableNormals(at index: Int32) -> UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.normals.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 12) }
  ///  Array of Vector4 values, one for each vertex tangent in this mesh.
  ///  If available, assumed to be the same length as vertices.
  internal var hasTangents: Bool { let o = _accessor.offset(VTOFFSET.tangents.v); return o == 0 ? false : true }
  internal var tangentsCount: Int32 { let o = _accessor.offset(VTOFFSET.tangents.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func tangents(at index: Int32) -> UnityEngine_Vector4? { let o = _accessor.offset(VTOFFSET.tangents.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector4.self, offset: _accessor.vector(at: o) + index * 16) }
  internal var tangentsAsBuffer: UnsafeBufferPointer<UnityEngine_Vector4>? { return _accessor.getBufferPointer(at: VTOFFSET.tangents.v) }
  internal func mutableTangents(at index: Int32) -> UnityEngine_Vector4_Mutable? { let o = _accessor.offset(VTOFFSET.tangents.v); return o == 0 ? nil : UnityEngine_Vector4_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 16) }
  ///  Array of Color32 values, one for each vertex color in this mesh.
  ///  If available, assumed to be the same length as vertices.
  internal var hasColors: Bool { let o = _accessor.offset(VTOFFSET.colors.v); return o == 0 ? false : true }
  internal var colorsCount: Int32 { let o = _accessor.offset(VTOFFSET.colors.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func colors(at index: Int32) -> UnityEngine_Color32? { let o = _accessor.offset(VTOFFSET.colors.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Color32.self, offset: _accessor.vector(at: o) + index * 4) }
  internal var colorsAsBuffer: UnsafeBufferPointer<UnityEngine_Color32>? { return _accessor.getBufferPointer(at: VTOFFSET.colors.v) }
  internal func mutableColors(at index: Int32) -> UnityEngine_Color32_Mutable? { let o = _accessor.offset(VTOFFSET.colors.v); return o == 0 ? nil : UnityEngine_Color32_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 4) }
  ///  Sets of texture coordinates (UV0, UV1, ..., up to UV7).
  internal var hasTexCoords: Bool { let o = _accessor.offset(VTOFFSET.texCoords.v); return o == 0 ? false : true }
  internal var texCoordsCount: Int32 { let o = _accessor.offset(VTOFFSET.texCoords.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func texCoords(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialTexCoords? { let o = _accessor.offset(VTOFFSET.texCoords.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialTexCoords(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  The index buffer (with 16-bit indices)
  internal var hasIndices16: Bool { let o = _accessor.offset(VTOFFSET.indices16.v); return o == 0 ? false : true }
  internal var indices16Count: Int32 { let o = _accessor.offset(VTOFFSET.indices16.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func indices16(at index: Int32) -> UInt16 { let o = _accessor.offset(VTOFFSET.indices16.v); return o == 0 ? 0 : _accessor.directRead(of: UInt16.self, offset: _accessor.vector(at: o) + index * 2) }
  internal var indices16: [UInt16] { return _accessor.getVector(at: VTOFFSET.indices16.v) ?? [] }
  internal var indices16AsBuffer: UnsafeBufferPointer<UInt16>? { return _accessor.getBufferPointer(at: VTOFFSET.indices16.v) }
  ///  The index buffer (with 32-bit indices)
  internal var hasIndices32: Bool { let o = _accessor.offset(VTOFFSET.indices32.v); return o == 0 ? false : true }
  internal var indices32Count: Int32 { let o = _accessor.offset(VTOFFSET.indices32.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func indices32(at index: Int32) -> UInt32 { let o = _accessor.offset(VTOFFSET.indices32.v); return o == 0 ? 0 : _accessor.directRead(of: UInt32.self, offset: _accessor.vector(at: o) + index * 4) }
  internal var indices32: [UInt32] { return _accessor.getVector(at: VTOFFSET.indices32.v) ?? [] }
  internal var indices32AsBuffer: UnsafeBufferPointer<UInt32>? { return _accessor.getBufferPointer(at: VTOFFSET.indices32.v) }
  ///  Array of 8bit unsigned values, each being the count of bones for
  ///  a given vertex.
  ///  If available, assumed to be the same length as vertices.
  internal var hasBonesPerVertex: Bool { let o = _accessor.offset(VTOFFSET.bonesPerVertex.v); return o == 0 ? false : true }
  internal var bonesPerVertexCount: Int32 { let o = _accessor.offset(VTOFFSET.bonesPerVertex.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func bonesPerVertex(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.bonesPerVertex.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  internal var bonesPerVertex: [UInt8] { return _accessor.getVector(at: VTOFFSET.bonesPerVertex.v) ?? [] }
  internal var bonesPerVertexAsBuffer: UnsafeBufferPointer<UInt8>? { return _accessor.getBufferPointer(at: VTOFFSET.bonesPerVertex.v) }
  ///  The bone weights for a given bone.
  internal var hasBoneWeights: Bool { let o = _accessor.offset(VTOFFSET.boneWeights.v); return o == 0 ? false : true }
  internal var boneWeightsCount: Int32 { let o = _accessor.offset(VTOFFSET.boneWeights.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func boneWeights(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialBoneWeight? { let o = _accessor.offset(VTOFFSET.boneWeights.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialBoneWeight.self, offset: _accessor.vector(at: o) + index * 8) }
  internal var boneWeightsAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialBoneWeight>? { return _accessor.getBufferPointer(at: VTOFFSET.boneWeights.v) }
  internal func mutableBoneWeights(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialBoneWeight_Mutable? { let o = _accessor.offset(VTOFFSET.boneWeights.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialBoneWeight_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 8) }
  internal var hasBindPoses: Bool { let o = _accessor.offset(VTOFFSET.bindPoses.v); return o == 0 ? false : true }
  internal var bindPosesCount: Int32 { let o = _accessor.offset(VTOFFSET.bindPoses.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func bindPoses(at index: Int32) -> UnityEngine_Matrix4x4? { let o = _accessor.offset(VTOFFSET.bindPoses.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Matrix4x4.self, offset: _accessor.vector(at: o) + index * 64) }
  internal var bindPosesAsBuffer: UnsafeBufferPointer<UnityEngine_Matrix4x4>? { return _accessor.getBufferPointer(at: VTOFFSET.bindPoses.v) }
  internal func mutableBindPoses(at index: Int32) -> UnityEngine_Matrix4x4_Mutable? { let o = _accessor.offset(VTOFFSET.bindPoses.v); return o == 0 ? nil : UnityEngine_Matrix4x4_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 64) }
  ///  An array of sub meshes that describe this mesh.
  internal var hasSubMeshes: Bool { let o = _accessor.offset(VTOFFSET.subMeshes.v); return o == 0 ? false : true }
  internal var subMeshesCount: Int32 { let o = _accessor.offset(VTOFFSET.subMeshes.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func subMeshes(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialSubMesh? { let o = _accessor.offset(VTOFFSET.subMeshes.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialSubMesh.self, offset: _accessor.vector(at: o) + index * 48) }
  internal var subMeshesAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialSubMesh>? { return _accessor.getBufferPointer(at: VTOFFSET.subMeshes.v) }
  internal func mutableSubMeshes(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialSubMesh_Mutable? { let o = _accessor.offset(VTOFFSET.subMeshes.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialSubMesh_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 48) }
  ///  The blend shapes contained within this mesh.
  internal var hasBlendShapes: Bool { let o = _accessor.offset(VTOFFSET.blendShapes.v); return o == 0 ? false : true }
  internal var blendShapesCount: Int32 { let o = _accessor.offset(VTOFFSET.blendShapes.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func blendShapes(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialBlendShape? { let o = _accessor.offset(VTOFFSET.blendShapes.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialBlendShape(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  internal static func startPolySpatialMesh(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 12) }
  internal static func addVectorOf(vertices: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vertices, at: VTOFFSET.vertices.p) }
  internal static func startVectorOfVertices(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector3>.size, elementSize: MemoryLayout<UnityEngine_Vector3>.alignment)
  }
  internal static func addVectorOf(normals: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: normals, at: VTOFFSET.normals.p) }
  internal static func startVectorOfNormals(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector3>.size, elementSize: MemoryLayout<UnityEngine_Vector3>.alignment)
  }
  internal static func addVectorOf(tangents: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tangents, at: VTOFFSET.tangents.p) }
  internal static func startVectorOfTangents(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector4>.size, elementSize: MemoryLayout<UnityEngine_Vector4>.alignment)
  }
  internal static func addVectorOf(colors: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: colors, at: VTOFFSET.colors.p) }
  internal static func startVectorOfColors(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Color32>.size, elementSize: MemoryLayout<UnityEngine_Color32>.alignment)
  }
  internal static func addVectorOf(texCoords: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: texCoords, at: VTOFFSET.texCoords.p) }
  internal static func addVectorOf(indices16: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: indices16, at: VTOFFSET.indices16.p) }
  internal static func addVectorOf(indices32: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: indices32, at: VTOFFSET.indices32.p) }
  internal static func addVectorOf(bonesPerVertex: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: bonesPerVertex, at: VTOFFSET.bonesPerVertex.p) }
  internal static func addVectorOf(boneWeights: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: boneWeights, at: VTOFFSET.boneWeights.p) }
  internal static func startVectorOfBoneWeights(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialBoneWeight>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialBoneWeight>.alignment)
  }
  internal static func addVectorOf(bindPoses: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: bindPoses, at: VTOFFSET.bindPoses.p) }
  internal static func startVectorOfBindPoses(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Matrix4x4>.size, elementSize: MemoryLayout<UnityEngine_Matrix4x4>.alignment)
  }
  internal static func addVectorOf(subMeshes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: subMeshes, at: VTOFFSET.subMeshes.p) }
  internal static func startVectorOfSubMeshes(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialSubMesh>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialSubMesh>.alignment)
  }
  internal static func addVectorOf(blendShapes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: blendShapes, at: VTOFFSET.blendShapes.p) }
  internal static func endPolySpatialMesh(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialMesh(
    _ fbb: inout FlatBufferBuilder,
    verticesVectorOffset vertices: Offset = Offset(),
    normalsVectorOffset normals: Offset = Offset(),
    tangentsVectorOffset tangents: Offset = Offset(),
    colorsVectorOffset colors: Offset = Offset(),
    texCoordsVectorOffset texCoords: Offset = Offset(),
    indices16VectorOffset indices16: Offset = Offset(),
    indices32VectorOffset indices32: Offset = Offset(),
    bonesPerVertexVectorOffset bonesPerVertex: Offset = Offset(),
    boneWeightsVectorOffset boneWeights: Offset = Offset(),
    bindPosesVectorOffset bindPoses: Offset = Offset(),
    subMeshesVectorOffset subMeshes: Offset = Offset(),
    blendShapesVectorOffset blendShapes: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialMesh.startPolySpatialMesh(&fbb)
    Unity_PolySpatial_Internals_PolySpatialMesh.addVectorOf(vertices: vertices, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMesh.addVectorOf(normals: normals, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMesh.addVectorOf(tangents: tangents, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMesh.addVectorOf(colors: colors, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMesh.addVectorOf(texCoords: texCoords, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMesh.addVectorOf(indices16: indices16, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMesh.addVectorOf(indices32: indices32, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMesh.addVectorOf(bonesPerVertex: bonesPerVertex, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMesh.addVectorOf(boneWeights: boneWeights, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMesh.addVectorOf(bindPoses: bindPoses, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMesh.addVectorOf(subMeshes: subMeshes, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMesh.addVectorOf(blendShapes: blendShapes, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialMesh.endPolySpatialMesh(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.vertices.p, fieldName: "vertices", required: false, type: ForwardOffset<Vector<UnityEngine_Vector3, UnityEngine_Vector3>>.self)
    try _v.visit(field: VTOFFSET.normals.p, fieldName: "normals", required: false, type: ForwardOffset<Vector<UnityEngine_Vector3, UnityEngine_Vector3>>.self)
    try _v.visit(field: VTOFFSET.tangents.p, fieldName: "tangents", required: false, type: ForwardOffset<Vector<UnityEngine_Vector4, UnityEngine_Vector4>>.self)
    try _v.visit(field: VTOFFSET.colors.p, fieldName: "colors", required: false, type: ForwardOffset<Vector<UnityEngine_Color32, UnityEngine_Color32>>.self)
    try _v.visit(field: VTOFFSET.texCoords.p, fieldName: "texCoords", required: false, type: ForwardOffset<Vector<ForwardOffset<Unity_PolySpatial_Internals_PolySpatialTexCoords>, Unity_PolySpatial_Internals_PolySpatialTexCoords>>.self)
    try _v.visit(field: VTOFFSET.indices16.p, fieldName: "indices16", required: false, type: ForwardOffset<Vector<UInt16, UInt16>>.self)
    try _v.visit(field: VTOFFSET.indices32.p, fieldName: "indices32", required: false, type: ForwardOffset<Vector<UInt32, UInt32>>.self)
    try _v.visit(field: VTOFFSET.bonesPerVertex.p, fieldName: "bonesPerVertex", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.boneWeights.p, fieldName: "boneWeights", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialBoneWeight, Unity_PolySpatial_Internals_PolySpatialBoneWeight>>.self)
    try _v.visit(field: VTOFFSET.bindPoses.p, fieldName: "bindPoses", required: false, type: ForwardOffset<Vector<UnityEngine_Matrix4x4, UnityEngine_Matrix4x4>>.self)
    try _v.visit(field: VTOFFSET.subMeshes.p, fieldName: "subMeshes", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialSubMesh, Unity_PolySpatial_Internals_PolySpatialSubMesh>>.self)
    try _v.visit(field: VTOFFSET.blendShapes.p, fieldName: "blendShapes", required: false, type: ForwardOffset<Vector<ForwardOffset<Unity_PolySpatial_Internals_PolySpatialBlendShape>, Unity_PolySpatial_Internals_PolySpatialBlendShape>>.self)
    _v.finish()
  }
}

///  Describes a mesh that has already been uploaded to the GPU (and thus has native vertex and index buffer
///  pointers--e.g., id<MTLBuffer>).
internal struct Unity_PolySpatial_Internals_PolySpatialNativeMesh: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case indexFormat = 4
    case nativeIndexBufferPtr = 6
    case vertexCount = 8
    case vertexAttributeDescriptors = 10
    case nativeVertexBufferPtrs = 12
    case subMeshes = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The format of the indices.
  internal var indexFormat: Unity_PolySpatial_Internals_PolySpatialIndexFormat { let o = _accessor.offset(VTOFFSET.indexFormat.v); return o == 0 ? .uint16 : Unity_PolySpatial_Internals_PolySpatialIndexFormat(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .uint16 }
  ///  The native index buffer pointer.
  internal var nativeIndexBufferPtr: UInt64 { let o = _accessor.offset(VTOFFSET.nativeIndexBufferPtr.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  ///  The total number of vertices.
  internal var vertexCount: Int32 { let o = _accessor.offset(VTOFFSET.vertexCount.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The vertex attributes contained in the mesh.
  internal var hasVertexAttributeDescriptors: Bool { let o = _accessor.offset(VTOFFSET.vertexAttributeDescriptors.v); return o == 0 ? false : true }
  internal var vertexAttributeDescriptorsCount: Int32 { let o = _accessor.offset(VTOFFSET.vertexAttributeDescriptors.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func vertexAttributeDescriptors(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialVertexAttributeDescriptor? { let o = _accessor.offset(VTOFFSET.vertexAttributeDescriptors.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialVertexAttributeDescriptor.self, offset: _accessor.vector(at: o) + index * 16) }
  internal var vertexAttributeDescriptorsAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialVertexAttributeDescriptor>? { return _accessor.getBufferPointer(at: VTOFFSET.vertexAttributeDescriptors.v) }
  internal func mutableVertexAttributeDescriptors(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialVertexAttributeDescriptor_Mutable? { let o = _accessor.offset(VTOFFSET.vertexAttributeDescriptors.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialVertexAttributeDescriptor_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 16) }
  ///  The native vertex buffer pointers.
  internal var hasNativeVertexBufferPtrs: Bool { let o = _accessor.offset(VTOFFSET.nativeVertexBufferPtrs.v); return o == 0 ? false : true }
  internal var nativeVertexBufferPtrsCount: Int32 { let o = _accessor.offset(VTOFFSET.nativeVertexBufferPtrs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func nativeVertexBufferPtrs(at index: Int32) -> UInt64 { let o = _accessor.offset(VTOFFSET.nativeVertexBufferPtrs.v); return o == 0 ? 0 : _accessor.directRead(of: UInt64.self, offset: _accessor.vector(at: o) + index * 8) }
  internal var nativeVertexBufferPtrs: [UInt64] { return _accessor.getVector(at: VTOFFSET.nativeVertexBufferPtrs.v) ?? [] }
  internal var nativeVertexBufferPtrsAsBuffer: UnsafeBufferPointer<UInt64>? { return _accessor.getBufferPointer(at: VTOFFSET.nativeVertexBufferPtrs.v) }
  ///  An array of sub meshes that describe this mesh.
  internal var hasSubMeshes: Bool { let o = _accessor.offset(VTOFFSET.subMeshes.v); return o == 0 ? false : true }
  internal var subMeshesCount: Int32 { let o = _accessor.offset(VTOFFSET.subMeshes.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func subMeshes(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialSubMesh? { let o = _accessor.offset(VTOFFSET.subMeshes.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialSubMesh.self, offset: _accessor.vector(at: o) + index * 48) }
  internal var subMeshesAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialSubMesh>? { return _accessor.getBufferPointer(at: VTOFFSET.subMeshes.v) }
  internal func mutableSubMeshes(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialSubMesh_Mutable? { let o = _accessor.offset(VTOFFSET.subMeshes.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialSubMesh_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 48) }
  internal static func startPolySpatialNativeMesh(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  internal static func add(indexFormat: Unity_PolySpatial_Internals_PolySpatialIndexFormat, _ fbb: inout FlatBufferBuilder) { fbb.add(element: indexFormat.rawValue, def: 0, at: VTOFFSET.indexFormat.p) }
  internal static func add(nativeIndexBufferPtr: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: nativeIndexBufferPtr, def: 0, at: VTOFFSET.nativeIndexBufferPtr.p) }
  internal static func add(vertexCount: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: vertexCount, def: 0, at: VTOFFSET.vertexCount.p) }
  internal static func addVectorOf(vertexAttributeDescriptors: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vertexAttributeDescriptors, at: VTOFFSET.vertexAttributeDescriptors.p) }
  internal static func startVectorOfVertexAttributeDescriptors(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialVertexAttributeDescriptor>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialVertexAttributeDescriptor>.alignment)
  }
  internal static func addVectorOf(nativeVertexBufferPtrs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: nativeVertexBufferPtrs, at: VTOFFSET.nativeVertexBufferPtrs.p) }
  internal static func addVectorOf(subMeshes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: subMeshes, at: VTOFFSET.subMeshes.p) }
  internal static func startVectorOfSubMeshes(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialSubMesh>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialSubMesh>.alignment)
  }
  internal static func endPolySpatialNativeMesh(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [10, 12, 14]); return end }
  internal static func createPolySpatialNativeMesh(
    _ fbb: inout FlatBufferBuilder,
    indexFormat: Unity_PolySpatial_Internals_PolySpatialIndexFormat = .uint16,
    nativeIndexBufferPtr: UInt64 = 0,
    vertexCount: Int32 = 0,
    vertexAttributeDescriptorsVectorOffset vertexAttributeDescriptors: Offset,
    nativeVertexBufferPtrsVectorOffset nativeVertexBufferPtrs: Offset,
    subMeshesVectorOffset subMeshes: Offset
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialNativeMesh.startPolySpatialNativeMesh(&fbb)
    Unity_PolySpatial_Internals_PolySpatialNativeMesh.add(indexFormat: indexFormat, &fbb)
    Unity_PolySpatial_Internals_PolySpatialNativeMesh.add(nativeIndexBufferPtr: nativeIndexBufferPtr, &fbb)
    Unity_PolySpatial_Internals_PolySpatialNativeMesh.add(vertexCount: vertexCount, &fbb)
    Unity_PolySpatial_Internals_PolySpatialNativeMesh.addVectorOf(vertexAttributeDescriptors: vertexAttributeDescriptors, &fbb)
    Unity_PolySpatial_Internals_PolySpatialNativeMesh.addVectorOf(nativeVertexBufferPtrs: nativeVertexBufferPtrs, &fbb)
    Unity_PolySpatial_Internals_PolySpatialNativeMesh.addVectorOf(subMeshes: subMeshes, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialNativeMesh.endPolySpatialNativeMesh(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.indexFormat.p, fieldName: "indexFormat", required: false, type: Unity_PolySpatial_Internals_PolySpatialIndexFormat.self)
    try _v.visit(field: VTOFFSET.nativeIndexBufferPtr.p, fieldName: "nativeIndexBufferPtr", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.vertexCount.p, fieldName: "vertexCount", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.vertexAttributeDescriptors.p, fieldName: "vertexAttributeDescriptors", required: true, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialVertexAttributeDescriptor, Unity_PolySpatial_Internals_PolySpatialVertexAttributeDescriptor>>.self)
    try _v.visit(field: VTOFFSET.nativeVertexBufferPtrs.p, fieldName: "nativeVertexBufferPtrs", required: true, type: ForwardOffset<Vector<UInt64, UInt64>>.self)
    try _v.visit(field: VTOFFSET.subMeshes.p, fieldName: "subMeshes", required: true, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialSubMesh, Unity_PolySpatial_Internals_PolySpatialSubMesh>>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialTextureData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case shape = 4
    case width = 6
    case height = 8
    case depth = 10
    case filterMode = 12
    case wrapModeU = 14
    case wrapModeV = 16
    case wrapModeW = 18
    case imageSize = 20
    case mipCount = 22
    case fallbackMode = 24
    case unityGraphicsFormat = 26
    case depthStencilFormat = 28
    case mips = 30
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var shape: Unity_PolySpatial_Internals_PolySpatialTextureShape { let o = _accessor.offset(VTOFFSET.shape.v); return o == 0 ? .texture2D : Unity_PolySpatial_Internals_PolySpatialTextureShape(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .texture2D }
  internal var width: Int32 { let o = _accessor.offset(VTOFFSET.width.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var height: Int32 { let o = _accessor.offset(VTOFFSET.height.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var depth: Int32 { let o = _accessor.offset(VTOFFSET.depth.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var filterMode: Unity_PolySpatial_Internals_PolySpatialTextureFilterMode { let o = _accessor.offset(VTOFFSET.filterMode.v); return o == 0 ? .point : Unity_PolySpatial_Internals_PolySpatialTextureFilterMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .point }
  internal var wrapModeU: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode { let o = _accessor.offset(VTOFFSET.wrapModeU.v); return o == 0 ? .repeat_ : Unity_PolySpatial_Internals_PolySpatialTextureWrapMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .repeat_ }
  internal var wrapModeV: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode { let o = _accessor.offset(VTOFFSET.wrapModeV.v); return o == 0 ? .repeat_ : Unity_PolySpatial_Internals_PolySpatialTextureWrapMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .repeat_ }
  internal var wrapModeW: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode { let o = _accessor.offset(VTOFFSET.wrapModeW.v); return o == 0 ? .repeat_ : Unity_PolySpatial_Internals_PolySpatialTextureWrapMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .repeat_ }
  internal var imageSize: UInt64 { let o = _accessor.offset(VTOFFSET.imageSize.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  internal var mipCount: Int32 { let o = _accessor.offset(VTOFFSET.mipCount.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var fallbackMode: Unity_PolySpatial_Internals_PolySpatialTextureFallbackMode { let o = _accessor.offset(VTOFFSET.fallbackMode.v); return o == 0 ? .none_ : Unity_PolySpatial_Internals_PolySpatialTextureFallbackMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .none_ }
  internal var unityGraphicsFormat: UInt32 { let o = _accessor.offset(VTOFFSET.unityGraphicsFormat.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  internal var depthStencilFormat: UInt32 { let o = _accessor.offset(VTOFFSET.depthStencilFormat.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  internal var hasMips: Bool { let o = _accessor.offset(VTOFFSET.mips.v); return o == 0 ? false : true }
  internal var mipsCount: Int32 { let o = _accessor.offset(VTOFFSET.mips.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func mips(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialTextureMipData? { let o = _accessor.offset(VTOFFSET.mips.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialTextureMipData.self, offset: _accessor.vector(at: o) + index * 32) }
  internal var mipsAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialTextureMipData>? { return _accessor.getBufferPointer(at: VTOFFSET.mips.v) }
  internal func mutableMips(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialTextureMipData_Mutable? { let o = _accessor.offset(VTOFFSET.mips.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialTextureMipData_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 32) }
  internal static func startPolySpatialTextureData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 14) }
  internal static func add(shape: Unity_PolySpatial_Internals_PolySpatialTextureShape, _ fbb: inout FlatBufferBuilder) { fbb.add(element: shape.rawValue, def: 0, at: VTOFFSET.shape.p) }
  internal static func add(width: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: width, def: 0, at: VTOFFSET.width.p) }
  internal static func add(height: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: height, def: 0, at: VTOFFSET.height.p) }
  internal static func add(depth: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: depth, def: 0, at: VTOFFSET.depth.p) }
  internal static func add(filterMode: Unity_PolySpatial_Internals_PolySpatialTextureFilterMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: filterMode.rawValue, def: 0, at: VTOFFSET.filterMode.p) }
  internal static func add(wrapModeU: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: wrapModeU.rawValue, def: 0, at: VTOFFSET.wrapModeU.p) }
  internal static func add(wrapModeV: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: wrapModeV.rawValue, def: 0, at: VTOFFSET.wrapModeV.p) }
  internal static func add(wrapModeW: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: wrapModeW.rawValue, def: 0, at: VTOFFSET.wrapModeW.p) }
  internal static func add(imageSize: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: imageSize, def: 0, at: VTOFFSET.imageSize.p) }
  internal static func add(mipCount: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mipCount, def: 0, at: VTOFFSET.mipCount.p) }
  internal static func add(fallbackMode: Unity_PolySpatial_Internals_PolySpatialTextureFallbackMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fallbackMode.rawValue, def: 0, at: VTOFFSET.fallbackMode.p) }
  internal static func add(unityGraphicsFormat: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: unityGraphicsFormat, def: 0, at: VTOFFSET.unityGraphicsFormat.p) }
  internal static func add(depthStencilFormat: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: depthStencilFormat, def: 0, at: VTOFFSET.depthStencilFormat.p) }
  internal static func addVectorOf(mips: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: mips, at: VTOFFSET.mips.p) }
  internal static func startVectorOfMips(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialTextureMipData>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialTextureMipData>.alignment)
  }
  internal static func endPolySpatialTextureData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialTextureData(
    _ fbb: inout FlatBufferBuilder,
    shape: Unity_PolySpatial_Internals_PolySpatialTextureShape = .texture2D,
    width: Int32 = 0,
    height: Int32 = 0,
    depth: Int32 = 0,
    filterMode: Unity_PolySpatial_Internals_PolySpatialTextureFilterMode = .point,
    wrapModeU: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode = .repeat_,
    wrapModeV: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode = .repeat_,
    wrapModeW: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode = .repeat_,
    imageSize: UInt64 = 0,
    mipCount: Int32 = 0,
    fallbackMode: Unity_PolySpatial_Internals_PolySpatialTextureFallbackMode = .none_,
    unityGraphicsFormat: UInt32 = 0,
    depthStencilFormat: UInt32 = 0,
    mipsVectorOffset mips: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialTextureData.startPolySpatialTextureData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialTextureData.add(shape: shape, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTextureData.add(width: width, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTextureData.add(height: height, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTextureData.add(depth: depth, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTextureData.add(filterMode: filterMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTextureData.add(wrapModeU: wrapModeU, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTextureData.add(wrapModeV: wrapModeV, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTextureData.add(wrapModeW: wrapModeW, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTextureData.add(imageSize: imageSize, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTextureData.add(mipCount: mipCount, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTextureData.add(fallbackMode: fallbackMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTextureData.add(unityGraphicsFormat: unityGraphicsFormat, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTextureData.add(depthStencilFormat: depthStencilFormat, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTextureData.addVectorOf(mips: mips, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialTextureData.endPolySpatialTextureData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.shape.p, fieldName: "shape", required: false, type: Unity_PolySpatial_Internals_PolySpatialTextureShape.self)
    try _v.visit(field: VTOFFSET.width.p, fieldName: "width", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.height.p, fieldName: "height", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.depth.p, fieldName: "depth", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.filterMode.p, fieldName: "filterMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialTextureFilterMode.self)
    try _v.visit(field: VTOFFSET.wrapModeU.p, fieldName: "wrapModeU", required: false, type: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode.self)
    try _v.visit(field: VTOFFSET.wrapModeV.p, fieldName: "wrapModeV", required: false, type: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode.self)
    try _v.visit(field: VTOFFSET.wrapModeW.p, fieldName: "wrapModeW", required: false, type: Unity_PolySpatial_Internals_PolySpatialTextureWrapMode.self)
    try _v.visit(field: VTOFFSET.imageSize.p, fieldName: "imageSize", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.mipCount.p, fieldName: "mipCount", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.fallbackMode.p, fieldName: "fallbackMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialTextureFallbackMode.self)
    try _v.visit(field: VTOFFSET.unityGraphicsFormat.p, fieldName: "unityGraphicsFormat", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.depthStencilFormat.p, fieldName: "depthStencilFormat", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.mips.p, fieldName: "mips", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialTextureMipData, Unity_PolySpatial_Internals_PolySpatialTextureMipData>>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialBufferData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case encoding = 4
    case description = 6
    case buffer = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var encoding: Unity_PolySpatial_Internals_PolySpatialEncoding { let o = _accessor.offset(VTOFFSET.encoding.v); return o == 0 ? .binary : Unity_PolySpatial_Internals_PolySpatialEncoding(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .binary }
  internal var description: Unity_PolySpatial_Internals_PolySpatialBufferDescription { let o = _accessor.offset(VTOFFSET.description.v); return o == 0 ? .materialX : Unity_PolySpatial_Internals_PolySpatialBufferDescription(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .materialX }
  internal var hasBuffer: Bool { let o = _accessor.offset(VTOFFSET.buffer.v); return o == 0 ? false : true }
  internal var bufferCount: Int32 { let o = _accessor.offset(VTOFFSET.buffer.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func buffer(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.buffer.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  internal var buffer: [UInt8] { return _accessor.getVector(at: VTOFFSET.buffer.v) ?? [] }
  internal var bufferAsBuffer: UnsafeBufferPointer<UInt8>? { return _accessor.getBufferPointer(at: VTOFFSET.buffer.v) }
  internal static func startPolySpatialBufferData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  internal static func add(encoding: Unity_PolySpatial_Internals_PolySpatialEncoding, _ fbb: inout FlatBufferBuilder) { fbb.add(element: encoding.rawValue, def: 0, at: VTOFFSET.encoding.p) }
  internal static func add(description: Unity_PolySpatial_Internals_PolySpatialBufferDescription, _ fbb: inout FlatBufferBuilder) { fbb.add(element: description.rawValue, def: 0, at: VTOFFSET.description.p) }
  internal static func addVectorOf(buffer: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: buffer, at: VTOFFSET.buffer.p) }
  internal static func endPolySpatialBufferData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialBufferData(
    _ fbb: inout FlatBufferBuilder,
    encoding: Unity_PolySpatial_Internals_PolySpatialEncoding = .binary,
    description: Unity_PolySpatial_Internals_PolySpatialBufferDescription = .materialX,
    bufferVectorOffset buffer: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialBufferData.startPolySpatialBufferData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialBufferData.add(encoding: encoding, &fbb)
    Unity_PolySpatial_Internals_PolySpatialBufferData.add(description: description, &fbb)
    Unity_PolySpatial_Internals_PolySpatialBufferData.addVectorOf(buffer: buffer, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialBufferData.endPolySpatialBufferData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.encoding.p, fieldName: "encoding", required: false, type: Unity_PolySpatial_Internals_PolySpatialEncoding.self)
    try _v.visit(field: VTOFFSET.description.p, fieldName: "description", required: false, type: Unity_PolySpatial_Internals_PolySpatialBufferDescription.self)
    try _v.visit(field: VTOFFSET.buffer.p, fieldName: "buffer", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

///  A simple material definition.  Can be expanded as needed.
internal struct Unity_PolySpatial_Internals_PolySpatialMaterialData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case materialType = 4
    case shaderId = 6
    case shaderPropertyMapId = 8
    case shaderFlags = 10
    case baseColorMap = 12
    case specularMap = 14
    case roughnessMap = 16
    case metallicMap = 18
    case normalMap = 20
    case transparencyMap = 22
    case emissiveColor = 24
    case emissiveIntensity = 26
    case ambientOcclusion = 28
    case clearcoatMap = 30
    case clearcoatRoughnessMap = 32
    case cullMode = 34
    case isTransparent = 36
    case shouldPreserveSpecularHighlights = 38
    case priority = 40
    case opacity = 42
    case opacityThreshold = 44
    case blendingMode = 46
    case particleColorMode = 48
    case scale = 50
    case offset = 52
    case workflow = 54
    case floatProperties = 56
    case intProperties = 58
    case vector4Properties = 60
    case colorProperties = 62
    case matrix4x4Properties = 64
    case textureProperties = 66
    case textureTransformProperties = 68
    case hasProperties = 70
    case keywordValues = 72
    case enableInstancing = 74
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Defines the type of this material description.
  internal var materialType: Unity_PolySpatial_Internals_PolySpatialMaterialType { let o = _accessor.offset(VTOFFSET.materialType.v); return o == 0 ? .none_ : Unity_PolySpatial_Internals_PolySpatialMaterialType(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .none_ }
  ///  Defines the assetID referencing the material's custom shader for materials that support custom shaders;
  internal var shaderId: Unity_PolySpatial_Internals_PolySpatialAssetID! { let o = _accessor.offset(VTOFFSET.shaderId.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, at: o) }
  internal var mutableShaderId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable! { let o = _accessor.offset(VTOFFSET.shaderId.v); return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Defines the assetID for the shader property map, which maps from property names to canonical indices
  internal var shaderPropertyMapId: Unity_PolySpatial_Internals_PolySpatialAssetID! { let o = _accessor.offset(VTOFFSET.shaderPropertyMapId.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, at: o) }
  internal var mutableShaderPropertyMapId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable! { let o = _accessor.offset(VTOFFSET.shaderPropertyMapId.v); return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Stores information about the features used by the shader.
  internal var shaderFlags: Unity_PolySpatial_Internals_PolySpatialShaderFlags { let o = _accessor.offset(VTOFFSET.shaderFlags.v); return o == 0 ? .usesLightProbes : Unity_PolySpatial_Internals_PolySpatialShaderFlags(rawValue: _accessor.readBuffer(of: UInt32.self, at: o))  }
  ///  Defines the basic diffuse color map for this material.
  internal var baseColorMap: Unity_PolySpatial_Internals_PolySpatialColorTextureMapData! { let o = _accessor.offset(VTOFFSET.baseColorMap.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialColorTextureMapData.self, at: o) }
  internal var mutableBaseColorMap: Unity_PolySpatial_Internals_PolySpatialColorTextureMapData_Mutable! { let o = _accessor.offset(VTOFFSET.baseColorMap.v); return Unity_PolySpatial_Internals_PolySpatialColorTextureMapData_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Defines the specular highlight map for this material.
  internal var specularMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData! { let o = _accessor.offset(VTOFFSET.specularMap.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData.self, at: o) }
  internal var mutableSpecularMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData_Mutable! { let o = _accessor.offset(VTOFFSET.specularMap.v); return Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Defines how rough the surface of the material is.
  internal var roughnessMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData! { let o = _accessor.offset(VTOFFSET.roughnessMap.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData.self, at: o) }
  internal var mutableRoughnessMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData_Mutable! { let o = _accessor.offset(VTOFFSET.roughnessMap.v); return Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Defines the amount of metallicity in the surface of the material.
  internal var metallicMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData! { let o = _accessor.offset(VTOFFSET.metallicMap.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData.self, at: o) }
  internal var mutableMetallicMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData_Mutable! { let o = _accessor.offset(VTOFFSET.metallicMap.v); return Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Normal map for surface rendering and blending.
  internal var normalMap: Unity_PolySpatial_Internals_PolySpatialTextureMapData! { let o = _accessor.offset(VTOFFSET.normalMap.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialTextureMapData.self, at: o) }
  internal var mutableNormalMap: Unity_PolySpatial_Internals_PolySpatialTextureMapData_Mutable! { let o = _accessor.offset(VTOFFSET.normalMap.v); return Unity_PolySpatial_Internals_PolySpatialTextureMapData_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Transparency map for settings how see through the surface of the material is.
  internal var transparencyMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData! { let o = _accessor.offset(VTOFFSET.transparencyMap.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData.self, at: o) }
  internal var mutableTransparencyMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData_Mutable! { let o = _accessor.offset(VTOFFSET.transparencyMap.v); return Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The color of the light emitted by this material.
  internal var emissiveColor: Unity_PolySpatial_Internals_PolySpatialColorTextureMapData! { let o = _accessor.offset(VTOFFSET.emissiveColor.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialColorTextureMapData.self, at: o) }
  internal var mutableEmissiveColor: Unity_PolySpatial_Internals_PolySpatialColorTextureMapData_Mutable! { let o = _accessor.offset(VTOFFSET.emissiveColor.v); return Unity_PolySpatial_Internals_PolySpatialColorTextureMapData_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The intensity of the light emitted by this material.
  internal var emissiveIntensity: Float32 { let o = _accessor.offset(VTOFFSET.emissiveIntensity.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  ///  A map that determines occlusion areas of the surface.
  internal var ambientOcclusion: Unity_PolySpatial_Internals_PolySpatialTextureMapData! { let o = _accessor.offset(VTOFFSET.ambientOcclusion.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialTextureMapData.self, at: o) }
  internal var mutableAmbientOcclusion: Unity_PolySpatial_Internals_PolySpatialTextureMapData_Mutable! { let o = _accessor.offset(VTOFFSET.ambientOcclusion.v); return Unity_PolySpatial_Internals_PolySpatialTextureMapData_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Defines the clearcoat level for the material.
  internal var clearcoatMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData! { let o = _accessor.offset(VTOFFSET.clearcoatMap.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData.self, at: o) }
  internal var mutableClearcoatMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData_Mutable! { let o = _accessor.offset(VTOFFSET.clearcoatMap.v); return Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Defines the clearcoat roughness level for the material.
  internal var clearcoatRoughnessMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData! { let o = _accessor.offset(VTOFFSET.clearcoatRoughnessMap.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData.self, at: o) }
  internal var mutableClearcoatRoughnessMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData_Mutable! { let o = _accessor.offset(VTOFFSET.clearcoatRoughnessMap.v); return Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Determines how faces of meshes with this material are to be culled.
  internal var cullMode: Unity_PolySpatial_Internals_PolySpatialCullMode { let o = _accessor.offset(VTOFFSET.cullMode.v); return o == 0 ? .none_ : Unity_PolySpatial_Internals_PolySpatialCullMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .none_ }
  ///  Determines if the material is supposed to be rendered transparent or opaque.
  internal var isTransparent: Bool { let o = _accessor.offset(VTOFFSET.isTransparent.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  ///  Determines if we preserve specular highlights for a transparent material.
  internal var shouldPreserveSpecularHighlights: Bool { let o = _accessor.offset(VTOFFSET.shouldPreserveSpecularHighlights.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  ///  Rendering priority for this material.
  internal var priority: Int32 { let o = _accessor.offset(VTOFFSET.priority.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The opacity level for this material.
  internal var opacity: Float32 { let o = _accessor.offset(VTOFFSET.opacity.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  ///  The opacity threshold for this material.
  internal var opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold! { let o = _accessor.offset(VTOFFSET.opacityThreshold.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold.self, at: o) }
  internal var mutableOpacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold_Mutable! { let o = _accessor.offset(VTOFFSET.opacityThreshold.v); return Unity_PolySpatial_Internals_PolySpatialOpacityThreshold_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The blending mode for this material.
  internal var blendingMode: Unity_PolySpatial_Internals_PolySpatialBlendingMode { let o = _accessor.offset(VTOFFSET.blendingMode.v); return o == 0 ? .alpha : Unity_PolySpatial_Internals_PolySpatialBlendingMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .alpha }
  ///  Color mode for particle material.
  internal var particleColorMode: Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode { let o = _accessor.offset(VTOFFSET.particleColorMode.v); return o == 0 ? .multiply : Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .multiply }
  ///   Scaling value for this material.
  internal var scale: UnityEngine_Vector2! { let o = _accessor.offset(VTOFFSET.scale.v); return _accessor.readBuffer(of: UnityEngine_Vector2.self, at: o) }
  internal var mutableScale: UnityEngine_Vector2_Mutable! { let o = _accessor.offset(VTOFFSET.scale.v); return UnityEngine_Vector2_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Placement offset for this material.
  internal var offset: UnityEngine_Vector2! { let o = _accessor.offset(VTOFFSET.offset.v); return _accessor.readBuffer(of: UnityEngine_Vector2.self, at: o) }
  internal var mutableOffset: UnityEngine_Vector2_Mutable! { let o = _accessor.offset(VTOFFSET.offset.v); return UnityEngine_Vector2_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Determines the workflow model to use to render
  ///  this material in.
  internal var workflow: Unity_PolySpatial_Internals_PolySpatialMaterialWorkflow { let o = _accessor.offset(VTOFFSET.workflow.v); return o == 0 ? .polySpatialSpecularWorkflow : Unity_PolySpatial_Internals_PolySpatialMaterialWorkflow(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .polySpatialSpecularWorkflow }
  ///  The set of float properties that are to be mapped to the shader
  ///  that is used to render this material.
  internal var hasFloatProperties: Bool { let o = _accessor.offset(VTOFFSET.floatProperties.v); return o == 0 ? false : true }
  internal var floatPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.floatProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func floatProperties(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.floatProperties.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  internal var floatProperties: [Float32] { return _accessor.getVector(at: VTOFFSET.floatProperties.v) ?? [] }
  internal var floatPropertiesAsBuffer: UnsafeBufferPointer<Float32>? { return _accessor.getBufferPointer(at: VTOFFSET.floatProperties.v) }
  ///  The set of int properties that are to be mapped to the shader
  ///  that is used to render this material.
  internal var hasIntProperties: Bool { let o = _accessor.offset(VTOFFSET.intProperties.v); return o == 0 ? false : true }
  internal var intPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.intProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func intProperties(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.intProperties.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  internal var intProperties: [Int32] { return _accessor.getVector(at: VTOFFSET.intProperties.v) ?? [] }
  internal var intPropertiesAsBuffer: UnsafeBufferPointer<Int32>? { return _accessor.getBufferPointer(at: VTOFFSET.intProperties.v) }
  ///  The set of Vector4 properties that are to be mapped to the shader
  ///  that is used to render this material.
  internal var hasVector4Properties: Bool { let o = _accessor.offset(VTOFFSET.vector4Properties.v); return o == 0 ? false : true }
  internal var vector4PropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.vector4Properties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func vector4Properties(at index: Int32) -> UnityEngine_Vector4? { let o = _accessor.offset(VTOFFSET.vector4Properties.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector4.self, offset: _accessor.vector(at: o) + index * 16) }
  internal var vector4PropertiesAsBuffer: UnsafeBufferPointer<UnityEngine_Vector4>? { return _accessor.getBufferPointer(at: VTOFFSET.vector4Properties.v) }
  internal func mutableVector4Properties(at index: Int32) -> UnityEngine_Vector4_Mutable? { let o = _accessor.offset(VTOFFSET.vector4Properties.v); return o == 0 ? nil : UnityEngine_Vector4_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 16) }
  ///  The set of Color properties that are to be mapped to the shader
  ///  that is used to render this material.
  internal var hasColorProperties: Bool { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? false : true }
  internal var colorPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func colorProperties(at index: Int32) -> UnityEngine_Color32? { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Color32.self, offset: _accessor.vector(at: o) + index * 4) }
  internal var colorPropertiesAsBuffer: UnsafeBufferPointer<UnityEngine_Color32>? { return _accessor.getBufferPointer(at: VTOFFSET.colorProperties.v) }
  internal func mutableColorProperties(at index: Int32) -> UnityEngine_Color32_Mutable? { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? nil : UnityEngine_Color32_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 4) }
  ///  The set of Matrix4xc4 properties that are to be mapped to the shader
  ///  that is used to render this material.
  internal var hasMatrix4x4Properties: Bool { let o = _accessor.offset(VTOFFSET.matrix4x4Properties.v); return o == 0 ? false : true }
  internal var matrix4x4PropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.matrix4x4Properties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func matrix4x4Properties(at index: Int32) -> UnityEngine_Matrix4x4? { let o = _accessor.offset(VTOFFSET.matrix4x4Properties.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Matrix4x4.self, offset: _accessor.vector(at: o) + index * 64) }
  internal var matrix4x4PropertiesAsBuffer: UnsafeBufferPointer<UnityEngine_Matrix4x4>? { return _accessor.getBufferPointer(at: VTOFFSET.matrix4x4Properties.v) }
  internal func mutableMatrix4x4Properties(at index: Int32) -> UnityEngine_Matrix4x4_Mutable? { let o = _accessor.offset(VTOFFSET.matrix4x4Properties.v); return o == 0 ? nil : UnityEngine_Matrix4x4_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 64) }
  ///  The set of Texture ID properties that are to be mapped to the shader
  ///  that is used to render this material.
  internal var hasTextureProperties: Bool { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? false : true }
  internal var texturePropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func textureProperties(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialAssetID? { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, offset: _accessor.vector(at: o) + index * 24) }
  internal var texturePropertiesAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialAssetID>? { return _accessor.getBufferPointer(at: VTOFFSET.textureProperties.v) }
  internal func mutableTextureProperties(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable? { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 24) }
  ///  The set of Texture transform vector properties (scale in xy, offset in zw) to be mapped to the shader.
  internal var hasTextureTransformProperties: Bool { let o = _accessor.offset(VTOFFSET.textureTransformProperties.v); return o == 0 ? false : true }
  internal var textureTransformPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.textureTransformProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func textureTransformProperties(at index: Int32) -> UnityEngine_Vector4? { let o = _accessor.offset(VTOFFSET.textureTransformProperties.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector4.self, offset: _accessor.vector(at: o) + index * 16) }
  internal var textureTransformPropertiesAsBuffer: UnsafeBufferPointer<UnityEngine_Vector4>? { return _accessor.getBufferPointer(at: VTOFFSET.textureTransformProperties.v) }
  internal func mutableTextureTransformProperties(at index: Int32) -> UnityEngine_Vector4_Mutable? { let o = _accessor.offset(VTOFFSET.textureTransformProperties.v); return o == 0 ? nil : UnityEngine_Vector4_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 16) }
  ///  For each property in all the lists, whether that property is actually set.
  internal var hasHasProperties: Bool { let o = _accessor.offset(VTOFFSET.hasProperties.v); return o == 0 ? false : true }
  internal var hasPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.hasProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func hasProperties(at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.hasProperties.v); return o == 0 ? true : _accessor.directRead(of: Bool.self, offset: _accessor.vector(at: o) + index * 1) }
  internal var hasProperties: [Bool] { return _accessor.getVector(at: VTOFFSET.hasProperties.v) ?? [] }
  internal var hasPropertiesAsBuffer: UnsafeBufferPointer<Bool>? { return _accessor.getBufferPointer(at: VTOFFSET.hasProperties.v) }
  ///  The set of keyword values properties that are to be enabled/disabled for
  ///  the shader used to render this material.
  internal var hasKeywordValues: Bool { let o = _accessor.offset(VTOFFSET.keywordValues.v); return o == 0 ? false : true }
  internal var keywordValuesCount: Int32 { let o = _accessor.offset(VTOFFSET.keywordValues.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func keywordValues(at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.keywordValues.v); return o == 0 ? true : _accessor.directRead(of: Bool.self, offset: _accessor.vector(at: o) + index * 1) }
  internal var keywordValues: [Bool] { return _accessor.getVector(at: VTOFFSET.keywordValues.v) ?? [] }
  internal var keywordValuesAsBuffer: UnsafeBufferPointer<Bool>? { return _accessor.getBufferPointer(at: VTOFFSET.keywordValues.v) }
  ///  Should GPU instancing be enabled or not.
  internal var enableInstancing: Bool { let o = _accessor.offset(VTOFFSET.enableInstancing.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal static func startPolySpatialMaterialData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 36) }
  internal static func add(materialType: Unity_PolySpatial_Internals_PolySpatialMaterialType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: materialType.rawValue, def: 0, at: VTOFFSET.materialType.p) }
  internal static func add(shaderId: Unity_PolySpatial_Internals_PolySpatialAssetID?, _ fbb: inout FlatBufferBuilder) { guard let shaderId = shaderId else { return }; fbb.create(struct: shaderId, position: VTOFFSET.shaderId.p) }
  internal static func add(shaderPropertyMapId: Unity_PolySpatial_Internals_PolySpatialAssetID?, _ fbb: inout FlatBufferBuilder) { guard let shaderPropertyMapId = shaderPropertyMapId else { return }; fbb.create(struct: shaderPropertyMapId, position: VTOFFSET.shaderPropertyMapId.p) }
  internal static func add(shaderFlags: Unity_PolySpatial_Internals_PolySpatialShaderFlags, _ fbb: inout FlatBufferBuilder) { fbb.add(element: shaderFlags.rawValue, def: 0, at: VTOFFSET.shaderFlags.p) }
  internal static func add(baseColorMap: Unity_PolySpatial_Internals_PolySpatialColorTextureMapData?, _ fbb: inout FlatBufferBuilder) { guard let baseColorMap = baseColorMap else { return }; fbb.create(struct: baseColorMap, position: VTOFFSET.baseColorMap.p) }
  internal static func add(specularMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData?, _ fbb: inout FlatBufferBuilder) { guard let specularMap = specularMap else { return }; fbb.create(struct: specularMap, position: VTOFFSET.specularMap.p) }
  internal static func add(roughnessMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData?, _ fbb: inout FlatBufferBuilder) { guard let roughnessMap = roughnessMap else { return }; fbb.create(struct: roughnessMap, position: VTOFFSET.roughnessMap.p) }
  internal static func add(metallicMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData?, _ fbb: inout FlatBufferBuilder) { guard let metallicMap = metallicMap else { return }; fbb.create(struct: metallicMap, position: VTOFFSET.metallicMap.p) }
  internal static func add(normalMap: Unity_PolySpatial_Internals_PolySpatialTextureMapData?, _ fbb: inout FlatBufferBuilder) { guard let normalMap = normalMap else { return }; fbb.create(struct: normalMap, position: VTOFFSET.normalMap.p) }
  internal static func add(transparencyMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData?, _ fbb: inout FlatBufferBuilder) { guard let transparencyMap = transparencyMap else { return }; fbb.create(struct: transparencyMap, position: VTOFFSET.transparencyMap.p) }
  internal static func add(emissiveColor: Unity_PolySpatial_Internals_PolySpatialColorTextureMapData?, _ fbb: inout FlatBufferBuilder) { guard let emissiveColor = emissiveColor else { return }; fbb.create(struct: emissiveColor, position: VTOFFSET.emissiveColor.p) }
  internal static func add(emissiveIntensity: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: emissiveIntensity, def: 0.0, at: VTOFFSET.emissiveIntensity.p) }
  internal static func add(ambientOcclusion: Unity_PolySpatial_Internals_PolySpatialTextureMapData?, _ fbb: inout FlatBufferBuilder) { guard let ambientOcclusion = ambientOcclusion else { return }; fbb.create(struct: ambientOcclusion, position: VTOFFSET.ambientOcclusion.p) }
  internal static func add(clearcoatMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData?, _ fbb: inout FlatBufferBuilder) { guard let clearcoatMap = clearcoatMap else { return }; fbb.create(struct: clearcoatMap, position: VTOFFSET.clearcoatMap.p) }
  internal static func add(clearcoatRoughnessMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData?, _ fbb: inout FlatBufferBuilder) { guard let clearcoatRoughnessMap = clearcoatRoughnessMap else { return }; fbb.create(struct: clearcoatRoughnessMap, position: VTOFFSET.clearcoatRoughnessMap.p) }
  internal static func add(cullMode: Unity_PolySpatial_Internals_PolySpatialCullMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: cullMode.rawValue, def: 0, at: VTOFFSET.cullMode.p) }
  internal static func add(isTransparent: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isTransparent, def: false,
   at: VTOFFSET.isTransparent.p) }
  internal static func add(shouldPreserveSpecularHighlights: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: shouldPreserveSpecularHighlights, def: false,
   at: VTOFFSET.shouldPreserveSpecularHighlights.p) }
  internal static func add(priority: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: priority, def: 0, at: VTOFFSET.priority.p) }
  internal static func add(opacity: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: opacity, def: 0.0, at: VTOFFSET.opacity.p) }
  internal static func add(opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold?, _ fbb: inout FlatBufferBuilder) { guard let opacityThreshold = opacityThreshold else { return }; fbb.create(struct: opacityThreshold, position: VTOFFSET.opacityThreshold.p) }
  internal static func add(blendingMode: Unity_PolySpatial_Internals_PolySpatialBlendingMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: blendingMode.rawValue, def: 0, at: VTOFFSET.blendingMode.p) }
  internal static func add(particleColorMode: Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: particleColorMode.rawValue, def: 0, at: VTOFFSET.particleColorMode.p) }
  internal static func add(scale: UnityEngine_Vector2?, _ fbb: inout FlatBufferBuilder) { guard let scale = scale else { return }; fbb.create(struct: scale, position: VTOFFSET.scale.p) }
  internal static func add(offset: UnityEngine_Vector2?, _ fbb: inout FlatBufferBuilder) { guard let offset = offset else { return }; fbb.create(struct: offset, position: VTOFFSET.offset.p) }
  internal static func add(workflow: Unity_PolySpatial_Internals_PolySpatialMaterialWorkflow, _ fbb: inout FlatBufferBuilder) { fbb.add(element: workflow.rawValue, def: 0, at: VTOFFSET.workflow.p) }
  internal static func addVectorOf(floatProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: floatProperties, at: VTOFFSET.floatProperties.p) }
  internal static func addVectorOf(intProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: intProperties, at: VTOFFSET.intProperties.p) }
  internal static func addVectorOf(vector4Properties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vector4Properties, at: VTOFFSET.vector4Properties.p) }
  internal static func startVectorOfVector4Properties(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector4>.size, elementSize: MemoryLayout<UnityEngine_Vector4>.alignment)
  }
  internal static func addVectorOf(colorProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: colorProperties, at: VTOFFSET.colorProperties.p) }
  internal static func startVectorOfColorProperties(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Color32>.size, elementSize: MemoryLayout<UnityEngine_Color32>.alignment)
  }
  internal static func addVectorOf(matrix4x4Properties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: matrix4x4Properties, at: VTOFFSET.matrix4x4Properties.p) }
  internal static func startVectorOfMatrix4x4Properties(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Matrix4x4>.size, elementSize: MemoryLayout<UnityEngine_Matrix4x4>.alignment)
  }
  internal static func addVectorOf(textureProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: textureProperties, at: VTOFFSET.textureProperties.p) }
  internal static func startVectorOfTextureProperties(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialAssetID>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialAssetID>.alignment)
  }
  internal static func addVectorOf(textureTransformProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: textureTransformProperties, at: VTOFFSET.textureTransformProperties.p) }
  internal static func startVectorOfTextureTransformProperties(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector4>.size, elementSize: MemoryLayout<UnityEngine_Vector4>.alignment)
  }
  internal static func addVectorOf(hasProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: hasProperties, at: VTOFFSET.hasProperties.p) }
  internal static func addVectorOf(keywordValues: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: keywordValues, at: VTOFFSET.keywordValues.p) }
  internal static func add(enableInstancing: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: enableInstancing, def: false,
   at: VTOFFSET.enableInstancing.p) }
  internal static func endPolySpatialMaterialData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [6, 8, 12, 14, 16, 18, 20, 22, 24, 28, 30, 32, 44, 50, 52]); return end }
  internal static func createPolySpatialMaterialData(
    _ fbb: inout FlatBufferBuilder,
    materialType: Unity_PolySpatial_Internals_PolySpatialMaterialType = .none_,
    shaderId: Unity_PolySpatial_Internals_PolySpatialAssetID,
    shaderPropertyMapId: Unity_PolySpatial_Internals_PolySpatialAssetID,
    shaderFlags: Unity_PolySpatial_Internals_PolySpatialShaderFlags = .usesLightProbes,
    baseColorMap: Unity_PolySpatial_Internals_PolySpatialColorTextureMapData,
    specularMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData,
    roughnessMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData,
    metallicMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData,
    normalMap: Unity_PolySpatial_Internals_PolySpatialTextureMapData,
    transparencyMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData,
    emissiveColor: Unity_PolySpatial_Internals_PolySpatialColorTextureMapData,
    emissiveIntensity: Float32 = 0.0,
    ambientOcclusion: Unity_PolySpatial_Internals_PolySpatialTextureMapData,
    clearcoatMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData,
    clearcoatRoughnessMap: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData,
    cullMode: Unity_PolySpatial_Internals_PolySpatialCullMode = .none_,
    isTransparent: Bool = false,
    shouldPreserveSpecularHighlights: Bool = false,
    priority: Int32 = 0,
    opacity: Float32 = 0.0,
    opacityThreshold: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold,
    blendingMode: Unity_PolySpatial_Internals_PolySpatialBlendingMode = .alpha,
    particleColorMode: Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode = .multiply,
    scale: UnityEngine_Vector2,
    offset: UnityEngine_Vector2,
    workflow: Unity_PolySpatial_Internals_PolySpatialMaterialWorkflow = .polySpatialSpecularWorkflow,
    floatPropertiesVectorOffset floatProperties: Offset = Offset(),
    intPropertiesVectorOffset intProperties: Offset = Offset(),
    vector4PropertiesVectorOffset vector4Properties: Offset = Offset(),
    colorPropertiesVectorOffset colorProperties: Offset = Offset(),
    matrix4x4PropertiesVectorOffset matrix4x4Properties: Offset = Offset(),
    texturePropertiesVectorOffset textureProperties: Offset = Offset(),
    textureTransformPropertiesVectorOffset textureTransformProperties: Offset = Offset(),
    hasPropertiesVectorOffset hasProperties: Offset = Offset(),
    keywordValuesVectorOffset keywordValues: Offset = Offset(),
    enableInstancing: Bool = false
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialMaterialData.startPolySpatialMaterialData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(materialType: materialType, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(shaderId: shaderId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(shaderPropertyMapId: shaderPropertyMapId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(shaderFlags: shaderFlags, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(baseColorMap: baseColorMap, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(specularMap: specularMap, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(roughnessMap: roughnessMap, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(metallicMap: metallicMap, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(normalMap: normalMap, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(transparencyMap: transparencyMap, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(emissiveColor: emissiveColor, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(emissiveIntensity: emissiveIntensity, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(ambientOcclusion: ambientOcclusion, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(clearcoatMap: clearcoatMap, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(clearcoatRoughnessMap: clearcoatRoughnessMap, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(cullMode: cullMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(isTransparent: isTransparent, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(shouldPreserveSpecularHighlights: shouldPreserveSpecularHighlights, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(priority: priority, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(opacity: opacity, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(opacityThreshold: opacityThreshold, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(blendingMode: blendingMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(particleColorMode: particleColorMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(scale: scale, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(offset: offset, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(workflow: workflow, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.addVectorOf(floatProperties: floatProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.addVectorOf(intProperties: intProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.addVectorOf(vector4Properties: vector4Properties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.addVectorOf(colorProperties: colorProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.addVectorOf(matrix4x4Properties: matrix4x4Properties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.addVectorOf(textureProperties: textureProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.addVectorOf(textureTransformProperties: textureTransformProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.addVectorOf(hasProperties: hasProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.addVectorOf(keywordValues: keywordValues, &fbb)
    Unity_PolySpatial_Internals_PolySpatialMaterialData.add(enableInstancing: enableInstancing, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialMaterialData.endPolySpatialMaterialData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.materialType.p, fieldName: "materialType", required: false, type: Unity_PolySpatial_Internals_PolySpatialMaterialType.self)
    try _v.visit(field: VTOFFSET.shaderId.p, fieldName: "shaderId", required: true, type: Unity_PolySpatial_Internals_PolySpatialAssetID.self)
    try _v.visit(field: VTOFFSET.shaderPropertyMapId.p, fieldName: "shaderPropertyMapId", required: true, type: Unity_PolySpatial_Internals_PolySpatialAssetID.self)
    try _v.visit(field: VTOFFSET.shaderFlags.p, fieldName: "shaderFlags", required: false, type: Unity_PolySpatial_Internals_PolySpatialShaderFlags.self)
    try _v.visit(field: VTOFFSET.baseColorMap.p, fieldName: "baseColorMap", required: true, type: Unity_PolySpatial_Internals_PolySpatialColorTextureMapData.self)
    try _v.visit(field: VTOFFSET.specularMap.p, fieldName: "specularMap", required: true, type: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData.self)
    try _v.visit(field: VTOFFSET.roughnessMap.p, fieldName: "roughnessMap", required: true, type: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData.self)
    try _v.visit(field: VTOFFSET.metallicMap.p, fieldName: "metallicMap", required: true, type: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData.self)
    try _v.visit(field: VTOFFSET.normalMap.p, fieldName: "normalMap", required: true, type: Unity_PolySpatial_Internals_PolySpatialTextureMapData.self)
    try _v.visit(field: VTOFFSET.transparencyMap.p, fieldName: "transparencyMap", required: true, type: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData.self)
    try _v.visit(field: VTOFFSET.emissiveColor.p, fieldName: "emissiveColor", required: true, type: Unity_PolySpatial_Internals_PolySpatialColorTextureMapData.self)
    try _v.visit(field: VTOFFSET.emissiveIntensity.p, fieldName: "emissiveIntensity", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.ambientOcclusion.p, fieldName: "ambientOcclusion", required: true, type: Unity_PolySpatial_Internals_PolySpatialTextureMapData.self)
    try _v.visit(field: VTOFFSET.clearcoatMap.p, fieldName: "clearcoatMap", required: true, type: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData.self)
    try _v.visit(field: VTOFFSET.clearcoatRoughnessMap.p, fieldName: "clearcoatRoughnessMap", required: true, type: Unity_PolySpatial_Internals_PolySpatialScalarTextureMapData.self)
    try _v.visit(field: VTOFFSET.cullMode.p, fieldName: "cullMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialCullMode.self)
    try _v.visit(field: VTOFFSET.isTransparent.p, fieldName: "isTransparent", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.shouldPreserveSpecularHighlights.p, fieldName: "shouldPreserveSpecularHighlights", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.priority.p, fieldName: "priority", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.opacity.p, fieldName: "opacity", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.opacityThreshold.p, fieldName: "opacityThreshold", required: true, type: Unity_PolySpatial_Internals_PolySpatialOpacityThreshold.self)
    try _v.visit(field: VTOFFSET.blendingMode.p, fieldName: "blendingMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialBlendingMode.self)
    try _v.visit(field: VTOFFSET.particleColorMode.p, fieldName: "particleColorMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleMaterialColorMode.self)
    try _v.visit(field: VTOFFSET.scale.p, fieldName: "scale", required: true, type: UnityEngine_Vector2.self)
    try _v.visit(field: VTOFFSET.offset.p, fieldName: "offset", required: true, type: UnityEngine_Vector2.self)
    try _v.visit(field: VTOFFSET.workflow.p, fieldName: "workflow", required: false, type: Unity_PolySpatial_Internals_PolySpatialMaterialWorkflow.self)
    try _v.visit(field: VTOFFSET.floatProperties.p, fieldName: "floatProperties", required: false, type: ForwardOffset<Vector<Float32, Float32>>.self)
    try _v.visit(field: VTOFFSET.intProperties.p, fieldName: "intProperties", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.vector4Properties.p, fieldName: "vector4Properties", required: false, type: ForwardOffset<Vector<UnityEngine_Vector4, UnityEngine_Vector4>>.self)
    try _v.visit(field: VTOFFSET.colorProperties.p, fieldName: "colorProperties", required: false, type: ForwardOffset<Vector<UnityEngine_Color32, UnityEngine_Color32>>.self)
    try _v.visit(field: VTOFFSET.matrix4x4Properties.p, fieldName: "matrix4x4Properties", required: false, type: ForwardOffset<Vector<UnityEngine_Matrix4x4, UnityEngine_Matrix4x4>>.self)
    try _v.visit(field: VTOFFSET.textureProperties.p, fieldName: "textureProperties", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialAssetID, Unity_PolySpatial_Internals_PolySpatialAssetID>>.self)
    try _v.visit(field: VTOFFSET.textureTransformProperties.p, fieldName: "textureTransformProperties", required: false, type: ForwardOffset<Vector<UnityEngine_Vector4, UnityEngine_Vector4>>.self)
    try _v.visit(field: VTOFFSET.hasProperties.p, fieldName: "hasProperties", required: false, type: ForwardOffset<Vector<Bool, Bool>>.self)
    try _v.visit(field: VTOFFSET.keywordValues.p, fieldName: "keywordValues", required: false, type: ForwardOffset<Vector<Bool, Bool>>.self)
    try _v.visit(field: VTOFFSET.enableInstancing.p, fieldName: "enableInstancing", required: false, type: Bool.self)
    _v.finish()
  }
}

///  https://docs.unity3d.com/6000.0/Documentation/ScriptReference/LightmapSettings.html
internal struct Unity_PolySpatial_Internals_PolySpatialLightmapSettingsData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case lightmaps = 4
    case lightmapsMode = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var hasLightmaps: Bool { let o = _accessor.offset(VTOFFSET.lightmaps.v); return o == 0 ? false : true }
  internal var lightmapsCount: Int32 { let o = _accessor.offset(VTOFFSET.lightmaps.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func lightmaps(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialLightmapData? { let o = _accessor.offset(VTOFFSET.lightmaps.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialLightmapData.self, offset: _accessor.vector(at: o) + index * 72) }
  internal var lightmapsAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialLightmapData>? { return _accessor.getBufferPointer(at: VTOFFSET.lightmaps.v) }
  internal func mutableLightmaps(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialLightmapData_Mutable? { let o = _accessor.offset(VTOFFSET.lightmaps.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialLightmapData_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 72) }
  internal var lightmapsMode: Unity_PolySpatial_Internals_PolySpatialLightmapsMode { let o = _accessor.offset(VTOFFSET.lightmapsMode.v); return o == 0 ? .nonDirectional : Unity_PolySpatial_Internals_PolySpatialLightmapsMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .nonDirectional }
  internal static func startPolySpatialLightmapSettingsData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  internal static func addVectorOf(lightmaps: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: lightmaps, at: VTOFFSET.lightmaps.p) }
  internal static func startVectorOfLightmaps(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialLightmapData>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialLightmapData>.alignment)
  }
  internal static func add(lightmapsMode: Unity_PolySpatial_Internals_PolySpatialLightmapsMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lightmapsMode.rawValue, def: 0, at: VTOFFSET.lightmapsMode.p) }
  internal static func endPolySpatialLightmapSettingsData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  internal static func createPolySpatialLightmapSettingsData(
    _ fbb: inout FlatBufferBuilder,
    lightmapsVectorOffset lightmaps: Offset,
    lightmapsMode: Unity_PolySpatial_Internals_PolySpatialLightmapsMode = .nonDirectional
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialLightmapSettingsData.startPolySpatialLightmapSettingsData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialLightmapSettingsData.addVectorOf(lightmaps: lightmaps, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLightmapSettingsData.add(lightmapsMode: lightmapsMode, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialLightmapSettingsData.endPolySpatialLightmapSettingsData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.lightmaps.p, fieldName: "lightmaps", required: true, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialLightmapData, Unity_PolySpatial_Internals_PolySpatialLightmapData>>.self)
    try _v.visit(field: VTOFFSET.lightmapsMode.p, fieldName: "lightmapsMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialLightmapsMode.self)
    _v.finish()
  }
}

///  A description of the render data, bones (a skeleton), and skin quality in a skinned mesh, used for a skinned mesh renderer.
internal struct Unity_PolySpatial_Internals_PolySpatialSkinnedRendererData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case renderData = 4
    case rootBoneId = 6
    case skeletonBoneIds = 8
    case skeletonBonesChanged = 10
    case skinWeight = 12
    case localBounds = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The render data for this skinned mesh renderer - data on mesh and materials.
  internal var renderData: Unity_PolySpatial_Internals_PolySpatialRenderData! { let o = _accessor.offset(VTOFFSET.renderData.v); return Unity_PolySpatial_Internals_PolySpatialRenderData(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  An instance id for a game object that is considered the root bone of the skeleton.
  ///  Used in determining things like root motion.
  internal var rootBoneId: Unity_PolySpatial_Internals_PolySpatialInstanceID! { let o = _accessor.offset(VTOFFSET.rootBoneId.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialInstanceID.self, at: o) }
  internal var mutableRootBoneId: Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable! { let o = _accessor.offset(VTOFFSET.rootBoneId.v); return Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  A list of instance ids that are associated with the game objects that comprise the bones in this skeleton.
  internal var hasSkeletonBoneIds: Bool { let o = _accessor.offset(VTOFFSET.skeletonBoneIds.v); return o == 0 ? false : true }
  internal var skeletonBoneIdsCount: Int32 { let o = _accessor.offset(VTOFFSET.skeletonBoneIds.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func skeletonBoneIds(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialInstanceID? { let o = _accessor.offset(VTOFFSET.skeletonBoneIds.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialInstanceID.self, offset: _accessor.vector(at: o) + index * 16) }
  internal var skeletonBoneIdsAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialInstanceID>? { return _accessor.getBufferPointer(at: VTOFFSET.skeletonBoneIds.v) }
  internal func mutableSkeletonBoneIds(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable? { let o = _accessor.offset(VTOFFSET.skeletonBoneIds.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 16) }
  ///  Whether the skinned mesh has had its skeleton changed during runtime.
  internal var skeletonBonesChanged: Bool { let o = _accessor.offset(VTOFFSET.skeletonBonesChanged.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  ///  Maximum number of bones affecting a single vertex.
  internal var skinWeight: Int32 { let o = _accessor.offset(VTOFFSET.skinWeight.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The local bounds of the renderer.  Unlike the mesh bounds, these incorporate the animated deformations.
  internal var localBounds: UnityEngine_Bounds! { let o = _accessor.offset(VTOFFSET.localBounds.v); return _accessor.readBuffer(of: UnityEngine_Bounds.self, at: o) }
  internal var mutableLocalBounds: UnityEngine_Bounds_Mutable! { let o = _accessor.offset(VTOFFSET.localBounds.v); return UnityEngine_Bounds_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal static func startPolySpatialSkinnedRendererData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  internal static func add(renderData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: renderData, at: VTOFFSET.renderData.p) }
  internal static func add(rootBoneId: Unity_PolySpatial_Internals_PolySpatialInstanceID?, _ fbb: inout FlatBufferBuilder) { guard let rootBoneId = rootBoneId else { return }; fbb.create(struct: rootBoneId, position: VTOFFSET.rootBoneId.p) }
  internal static func addVectorOf(skeletonBoneIds: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: skeletonBoneIds, at: VTOFFSET.skeletonBoneIds.p) }
  internal static func startVectorOfSkeletonBoneIds(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialInstanceID>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialInstanceID>.alignment)
  }
  internal static func add(skeletonBonesChanged: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: skeletonBonesChanged, def: false,
   at: VTOFFSET.skeletonBonesChanged.p) }
  internal static func add(skinWeight: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: skinWeight, def: 0, at: VTOFFSET.skinWeight.p) }
  internal static func add(localBounds: UnityEngine_Bounds?, _ fbb: inout FlatBufferBuilder) { guard let localBounds = localBounds else { return }; fbb.create(struct: localBounds, position: VTOFFSET.localBounds.p) }
  internal static func endPolySpatialSkinnedRendererData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6, 8, 14]); return end }
  internal static func createPolySpatialSkinnedRendererData(
    _ fbb: inout FlatBufferBuilder,
    renderDataOffset renderData: Offset,
    rootBoneId: Unity_PolySpatial_Internals_PolySpatialInstanceID,
    skeletonBoneIdsVectorOffset skeletonBoneIds: Offset,
    skeletonBonesChanged: Bool = false,
    skinWeight: Int32 = 0,
    localBounds: UnityEngine_Bounds
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialSkinnedRendererData.startPolySpatialSkinnedRendererData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialSkinnedRendererData.add(renderData: renderData, &fbb)
    Unity_PolySpatial_Internals_PolySpatialSkinnedRendererData.add(rootBoneId: rootBoneId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialSkinnedRendererData.addVectorOf(skeletonBoneIds: skeletonBoneIds, &fbb)
    Unity_PolySpatial_Internals_PolySpatialSkinnedRendererData.add(skeletonBonesChanged: skeletonBonesChanged, &fbb)
    Unity_PolySpatial_Internals_PolySpatialSkinnedRendererData.add(skinWeight: skinWeight, &fbb)
    Unity_PolySpatial_Internals_PolySpatialSkinnedRendererData.add(localBounds: localBounds, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialSkinnedRendererData.endPolySpatialSkinnedRendererData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.renderData.p, fieldName: "renderData", required: true, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialRenderData>.self)
    try _v.visit(field: VTOFFSET.rootBoneId.p, fieldName: "rootBoneId", required: true, type: Unity_PolySpatial_Internals_PolySpatialInstanceID.self)
    try _v.visit(field: VTOFFSET.skeletonBoneIds.p, fieldName: "skeletonBoneIds", required: true, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialInstanceID, Unity_PolySpatial_Internals_PolySpatialInstanceID>>.self)
    try _v.visit(field: VTOFFSET.skeletonBonesChanged.p, fieldName: "skeletonBonesChanged", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.skinWeight.p, fieldName: "skinWeight", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.localBounds.p, fieldName: "localBounds", required: true, type: UnityEngine_Bounds.self)
    _v.finish()
  }
}

///  Contains the blend shape weights for a skinned mesh.  These are transmitted separately since we expect
///  them to change more often than the information in PolySpatialSkinnedRendererData.
internal struct Unity_PolySpatial_Internals_PolySpatialSkinnedBlendShapeData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case weights = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The weights to apply to each of the skinned mesh's blend shapes.
  internal var hasWeights: Bool { let o = _accessor.offset(VTOFFSET.weights.v); return o == 0 ? false : true }
  internal var weightsCount: Int32 { let o = _accessor.offset(VTOFFSET.weights.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func weights(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.weights.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  internal var weights: [Float32] { return _accessor.getVector(at: VTOFFSET.weights.v) ?? [] }
  internal var weightsAsBuffer: UnsafeBufferPointer<Float32>? { return _accessor.getBufferPointer(at: VTOFFSET.weights.v) }
  internal static func startPolySpatialSkinnedBlendShapeData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  internal static func addVectorOf(weights: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: weights, at: VTOFFSET.weights.p) }
  internal static func endPolySpatialSkinnedBlendShapeData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  internal static func createPolySpatialSkinnedBlendShapeData(
    _ fbb: inout FlatBufferBuilder,
    weightsVectorOffset weights: Offset
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialSkinnedBlendShapeData.startPolySpatialSkinnedBlendShapeData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialSkinnedBlendShapeData.addVectorOf(weights: weights, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialSkinnedBlendShapeData.endPolySpatialSkinnedBlendShapeData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.weights.p, fieldName: "weights", required: true, type: ForwardOffset<Vector<Float32, Float32>>.self)
    _v.finish()
  }
}

///  Defines text data needed to display PolySpatial text.
internal struct Unity_PolySpatial_Internals_PolySpatialPlatformTextData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case tmProFontAssetId = 4
    case fontAssetId = 6
    case fontName = 8
    case canvasBackgroundColor = 10
    case canvasSize = 12
    case canvasCornerRadius = 14
    case text = 16
    case textSize = 18
    case justification = 20
    case textColor = 22
    case textEdgeInsets = 24
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var tmProFontAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID? { let o = _accessor.offset(VTOFFSET.tmProFontAssetId.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, at: o) }
  internal var mutableTmProFontAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable? { let o = _accessor.offset(VTOFFSET.tmProFontAssetId.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var fontAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID? { let o = _accessor.offset(VTOFFSET.fontAssetId.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, at: o) }
  internal var mutableFontAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable? { let o = _accessor.offset(VTOFFSET.fontAssetId.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var fontName: String? { let o = _accessor.offset(VTOFFSET.fontName.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var fontNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.fontName.v) }
  internal var canvasBackgroundColor: UnityEngine_Color32? { let o = _accessor.offset(VTOFFSET.canvasBackgroundColor.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Color32.self, at: o) }
  internal var mutableCanvasBackgroundColor: UnityEngine_Color32_Mutable? { let o = _accessor.offset(VTOFFSET.canvasBackgroundColor.v); return o == 0 ? nil : UnityEngine_Color32_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var canvasSize: UnityEngine_Vector2? { let o = _accessor.offset(VTOFFSET.canvasSize.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector2.self, at: o) }
  internal var mutableCanvasSize: UnityEngine_Vector2_Mutable? { let o = _accessor.offset(VTOFFSET.canvasSize.v); return o == 0 ? nil : UnityEngine_Vector2_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var canvasCornerRadius: Int32 { let o = _accessor.offset(VTOFFSET.canvasCornerRadius.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var text: String? { let o = _accessor.offset(VTOFFSET.text.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var textSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.text.v) }
  internal var textSize: Int32 { let o = _accessor.offset(VTOFFSET.textSize.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var justification: Unity_PolySpatial_Internals_PolySpatialHorizontalTextJustification { let o = _accessor.offset(VTOFFSET.justification.v); return o == 0 ? .left_ : Unity_PolySpatial_Internals_PolySpatialHorizontalTextJustification(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .left_ }
  internal var textColor: UnityEngine_Color32? { let o = _accessor.offset(VTOFFSET.textColor.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Color32.self, at: o) }
  internal var mutableTextColor: UnityEngine_Color32_Mutable? { let o = _accessor.offset(VTOFFSET.textColor.v); return o == 0 ? nil : UnityEngine_Color32_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var textEdgeInsets: UnityEngine_Vector4? { let o = _accessor.offset(VTOFFSET.textEdgeInsets.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector4.self, at: o) }
  internal var mutableTextEdgeInsets: UnityEngine_Vector4_Mutable? { let o = _accessor.offset(VTOFFSET.textEdgeInsets.v); return o == 0 ? nil : UnityEngine_Vector4_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal static func startPolySpatialPlatformTextData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 11) }
  internal static func add(tmProFontAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID?, _ fbb: inout FlatBufferBuilder) { guard let tmProFontAssetId = tmProFontAssetId else { return }; fbb.create(struct: tmProFontAssetId, position: VTOFFSET.tmProFontAssetId.p) }
  internal static func add(fontAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID?, _ fbb: inout FlatBufferBuilder) { guard let fontAssetId = fontAssetId else { return }; fbb.create(struct: fontAssetId, position: VTOFFSET.fontAssetId.p) }
  internal static func add(fontName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: fontName, at: VTOFFSET.fontName.p) }
  internal static func add(canvasBackgroundColor: UnityEngine_Color32?, _ fbb: inout FlatBufferBuilder) { guard let canvasBackgroundColor = canvasBackgroundColor else { return }; fbb.create(struct: canvasBackgroundColor, position: VTOFFSET.canvasBackgroundColor.p) }
  internal static func add(canvasSize: UnityEngine_Vector2?, _ fbb: inout FlatBufferBuilder) { guard let canvasSize = canvasSize else { return }; fbb.create(struct: canvasSize, position: VTOFFSET.canvasSize.p) }
  internal static func add(canvasCornerRadius: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: canvasCornerRadius, def: 0, at: VTOFFSET.canvasCornerRadius.p) }
  internal static func add(text: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: text, at: VTOFFSET.text.p) }
  internal static func add(textSize: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: textSize, def: 0, at: VTOFFSET.textSize.p) }
  internal static func add(justification: Unity_PolySpatial_Internals_PolySpatialHorizontalTextJustification, _ fbb: inout FlatBufferBuilder) { fbb.add(element: justification.rawValue, def: 0, at: VTOFFSET.justification.p) }
  internal static func add(textColor: UnityEngine_Color32?, _ fbb: inout FlatBufferBuilder) { guard let textColor = textColor else { return }; fbb.create(struct: textColor, position: VTOFFSET.textColor.p) }
  internal static func add(textEdgeInsets: UnityEngine_Vector4?, _ fbb: inout FlatBufferBuilder) { guard let textEdgeInsets = textEdgeInsets else { return }; fbb.create(struct: textEdgeInsets, position: VTOFFSET.textEdgeInsets.p) }
  internal static func endPolySpatialPlatformTextData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialPlatformTextData(
    _ fbb: inout FlatBufferBuilder,
    tmProFontAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID? = nil,
    fontAssetId: Unity_PolySpatial_Internals_PolySpatialAssetID? = nil,
    fontNameOffset fontName: Offset = Offset(),
    canvasBackgroundColor: UnityEngine_Color32? = nil,
    canvasSize: UnityEngine_Vector2? = nil,
    canvasCornerRadius: Int32 = 0,
    textOffset text: Offset = Offset(),
    textSize: Int32 = 0,
    justification: Unity_PolySpatial_Internals_PolySpatialHorizontalTextJustification = .left_,
    textColor: UnityEngine_Color32? = nil,
    textEdgeInsets: UnityEngine_Vector4? = nil
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialPlatformTextData.startPolySpatialPlatformTextData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialPlatformTextData.add(tmProFontAssetId: tmProFontAssetId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialPlatformTextData.add(fontAssetId: fontAssetId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialPlatformTextData.add(fontName: fontName, &fbb)
    Unity_PolySpatial_Internals_PolySpatialPlatformTextData.add(canvasBackgroundColor: canvasBackgroundColor, &fbb)
    Unity_PolySpatial_Internals_PolySpatialPlatformTextData.add(canvasSize: canvasSize, &fbb)
    Unity_PolySpatial_Internals_PolySpatialPlatformTextData.add(canvasCornerRadius: canvasCornerRadius, &fbb)
    Unity_PolySpatial_Internals_PolySpatialPlatformTextData.add(text: text, &fbb)
    Unity_PolySpatial_Internals_PolySpatialPlatformTextData.add(textSize: textSize, &fbb)
    Unity_PolySpatial_Internals_PolySpatialPlatformTextData.add(justification: justification, &fbb)
    Unity_PolySpatial_Internals_PolySpatialPlatformTextData.add(textColor: textColor, &fbb)
    Unity_PolySpatial_Internals_PolySpatialPlatformTextData.add(textEdgeInsets: textEdgeInsets, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialPlatformTextData.endPolySpatialPlatformTextData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.tmProFontAssetId.p, fieldName: "tmProFontAssetId", required: false, type: Unity_PolySpatial_Internals_PolySpatialAssetID.self)
    try _v.visit(field: VTOFFSET.fontAssetId.p, fieldName: "fontAssetId", required: false, type: Unity_PolySpatial_Internals_PolySpatialAssetID.self)
    try _v.visit(field: VTOFFSET.fontName.p, fieldName: "fontName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.canvasBackgroundColor.p, fieldName: "canvasBackgroundColor", required: false, type: UnityEngine_Color32.self)
    try _v.visit(field: VTOFFSET.canvasSize.p, fieldName: "canvasSize", required: false, type: UnityEngine_Vector2.self)
    try _v.visit(field: VTOFFSET.canvasCornerRadius.p, fieldName: "canvasCornerRadius", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.text.p, fieldName: "text", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.textSize.p, fieldName: "textSize", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.justification.p, fieldName: "justification", required: false, type: Unity_PolySpatial_Internals_PolySpatialHorizontalTextJustification.self)
    try _v.visit(field: VTOFFSET.textColor.p, fieldName: "textColor", required: false, type: UnityEngine_Color32.self)
    try _v.visit(field: VTOFFSET.textEdgeInsets.p, fieldName: "textEdgeInsets", required: false, type: UnityEngine_Vector4.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialTmpFontAsset: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case serializedFontAsset = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var serializedFontAsset: String? { let o = _accessor.offset(VTOFFSET.serializedFontAsset.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var serializedFontAssetSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.serializedFontAsset.v) }
  internal static func startPolySpatialTmpFontAsset(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  internal static func add(serializedFontAsset: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: serializedFontAsset, at: VTOFFSET.serializedFontAsset.p) }
  internal static func endPolySpatialTmpFontAsset(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialTmpFontAsset(
    _ fbb: inout FlatBufferBuilder,
    serializedFontAssetOffset serializedFontAsset: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialTmpFontAsset.startPolySpatialTmpFontAsset(&fbb)
    Unity_PolySpatial_Internals_PolySpatialTmpFontAsset.add(serializedFontAsset: serializedFontAsset, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialTmpFontAsset.endPolySpatialTmpFontAsset(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.serializedFontAsset.p, fieldName: "serializedFontAsset", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialFontAsset: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case fontName = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var fontName: String? { let o = _accessor.offset(VTOFFSET.fontName.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var fontNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.fontName.v) }
  internal static func startPolySpatialFontAsset(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  internal static func add(fontName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: fontName, at: VTOFFSET.fontName.p) }
  internal static func endPolySpatialFontAsset(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialFontAsset(
    _ fbb: inout FlatBufferBuilder,
    fontNameOffset fontName: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialFontAsset.startPolySpatialFontAsset(&fbb)
    Unity_PolySpatial_Internals_PolySpatialFontAsset.add(fontName: fontName, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialFontAsset.endPolySpatialFontAsset(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.fontName.p, fieldName: "fontName", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Defines the information needed to set up a sprite mask in PolySpatial.
internal struct Unity_PolySpatial_Internals_PolySpatialSpriteMaskData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case spriteMaskTextureId = 4
    case alphaOpacityCutoff = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The texture to be used to define the mask.
  internal var spriteMaskTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID? { let o = _accessor.offset(VTOFFSET.spriteMaskTextureId.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, at: o) }
  internal var mutableSpriteMaskTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable? { let o = _accessor.offset(VTOFFSET.spriteMaskTextureId.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The alpha cutoff value. This determines what parts of the texture mask
  ///  and what parts don't. Anything below the cutoff value will be masked.
  internal var alphaOpacityCutoff: Float32 { let o = _accessor.offset(VTOFFSET.alphaOpacityCutoff.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal static func startPolySpatialSpriteMaskData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  internal static func add(spriteMaskTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID?, _ fbb: inout FlatBufferBuilder) { guard let spriteMaskTextureId = spriteMaskTextureId else { return }; fbb.create(struct: spriteMaskTextureId, position: VTOFFSET.spriteMaskTextureId.p) }
  internal static func add(alphaOpacityCutoff: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: alphaOpacityCutoff, def: 0.0, at: VTOFFSET.alphaOpacityCutoff.p) }
  internal static func endPolySpatialSpriteMaskData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialSpriteMaskData(
    _ fbb: inout FlatBufferBuilder,
    spriteMaskTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID? = nil,
    alphaOpacityCutoff: Float32 = 0.0
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialSpriteMaskData.startPolySpatialSpriteMaskData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialSpriteMaskData.add(spriteMaskTextureId: spriteMaskTextureId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialSpriteMaskData.add(alphaOpacityCutoff: alphaOpacityCutoff, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialSpriteMaskData.endPolySpatialSpriteMaskData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.spriteMaskTextureId.p, fieldName: "spriteMaskTextureId", required: false, type: Unity_PolySpatial_Internals_PolySpatialAssetID.self)
    try _v.visit(field: VTOFFSET.alphaOpacityCutoff.p, fieldName: "alphaOpacityCutoff", required: false, type: Float32.self)
    _v.finish()
  }
}

///  Defines the information needed to render a sprite withing the PolySpatial system.
internal struct Unity_PolySpatial_Internals_PolySpatialSpriteRenderData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case renderData = 4
    case color = 6
    case mainTextureId = 8
    case maskTextureId = 10
    case maskUvtransform = 12
    case maskingOperation = 14
    case maskAlphaCutoff = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The render data for this sprite renderer - data on mesh and materials.
  internal var renderData: Unity_PolySpatial_Internals_PolySpatialRenderData! { let o = _accessor.offset(VTOFFSET.renderData.v); return Unity_PolySpatial_Internals_PolySpatialRenderData(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  The color to apply to the renderer material.
  internal var color: UnityEngine_Color! { let o = _accessor.offset(VTOFFSET.color.v); return _accessor.readBuffer(of: UnityEngine_Color.self, at: o) }
  internal var mutableColor: UnityEngine_Color_Mutable! { let o = _accessor.offset(VTOFFSET.color.v); return UnityEngine_Color_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The main texture to apply to the renderer material.
  internal var mainTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID! { let o = _accessor.offset(VTOFFSET.mainTextureId.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, at: o) }
  internal var mutableMainTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable! { let o = _accessor.offset(VTOFFSET.mainTextureId.v); return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The id of the mask texture to apply to the renderer material.
  internal var maskTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID! { let o = _accessor.offset(VTOFFSET.maskTextureId.v); return _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, at: o) }
  internal var mutableMaskTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable! { let o = _accessor.offset(VTOFFSET.maskTextureId.v); return Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The UV transform for the sprite mask.
  internal var maskUvtransform: UnityEngine_Matrix4x4! { let o = _accessor.offset(VTOFFSET.maskUvtransform.v); return _accessor.readBuffer(of: UnityEngine_Matrix4x4.self, at: o) }
  internal var mutableMaskUvtransform: UnityEngine_Matrix4x4_Mutable! { let o = _accessor.offset(VTOFFSET.maskUvtransform.v); return UnityEngine_Matrix4x4_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Defines how any mask is to be applied to this sprite.
  internal var maskingOperation: Unity_PolySpatial_Internals_PolySpatialMaskingOperation { let o = _accessor.offset(VTOFFSET.maskingOperation.v); return o == 0 ? .none_ : Unity_PolySpatial_Internals_PolySpatialMaskingOperation(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .none_ }
  ///  The alpha cutoff to use for the mask.
  internal var maskAlphaCutoff: Float32 { let o = _accessor.offset(VTOFFSET.maskAlphaCutoff.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal static func startPolySpatialSpriteRenderData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  internal static func add(renderData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: renderData, at: VTOFFSET.renderData.p) }
  internal static func add(color: UnityEngine_Color?, _ fbb: inout FlatBufferBuilder) { guard let color = color else { return }; fbb.create(struct: color, position: VTOFFSET.color.p) }
  internal static func add(mainTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID?, _ fbb: inout FlatBufferBuilder) { guard let mainTextureId = mainTextureId else { return }; fbb.create(struct: mainTextureId, position: VTOFFSET.mainTextureId.p) }
  internal static func add(maskTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID?, _ fbb: inout FlatBufferBuilder) { guard let maskTextureId = maskTextureId else { return }; fbb.create(struct: maskTextureId, position: VTOFFSET.maskTextureId.p) }
  internal static func add(maskUvtransform: UnityEngine_Matrix4x4?, _ fbb: inout FlatBufferBuilder) { guard let maskUvtransform = maskUvtransform else { return }; fbb.create(struct: maskUvtransform, position: VTOFFSET.maskUvtransform.p) }
  internal static func add(maskingOperation: Unity_PolySpatial_Internals_PolySpatialMaskingOperation, _ fbb: inout FlatBufferBuilder) { fbb.add(element: maskingOperation.rawValue, def: 0, at: VTOFFSET.maskingOperation.p) }
  internal static func add(maskAlphaCutoff: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: maskAlphaCutoff, def: 0.0, at: VTOFFSET.maskAlphaCutoff.p) }
  internal static func endPolySpatialSpriteRenderData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6, 8, 10, 12]); return end }
  internal static func createPolySpatialSpriteRenderData(
    _ fbb: inout FlatBufferBuilder,
    renderDataOffset renderData: Offset,
    color: UnityEngine_Color,
    mainTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID,
    maskTextureId: Unity_PolySpatial_Internals_PolySpatialAssetID,
    maskUvtransform: UnityEngine_Matrix4x4,
    maskingOperation: Unity_PolySpatial_Internals_PolySpatialMaskingOperation = .none_,
    maskAlphaCutoff: Float32 = 0.0
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialSpriteRenderData.startPolySpatialSpriteRenderData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialSpriteRenderData.add(renderData: renderData, &fbb)
    Unity_PolySpatial_Internals_PolySpatialSpriteRenderData.add(color: color, &fbb)
    Unity_PolySpatial_Internals_PolySpatialSpriteRenderData.add(mainTextureId: mainTextureId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialSpriteRenderData.add(maskTextureId: maskTextureId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialSpriteRenderData.add(maskUvtransform: maskUvtransform, &fbb)
    Unity_PolySpatial_Internals_PolySpatialSpriteRenderData.add(maskingOperation: maskingOperation, &fbb)
    Unity_PolySpatial_Internals_PolySpatialSpriteRenderData.add(maskAlphaCutoff: maskAlphaCutoff, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialSpriteRenderData.endPolySpatialSpriteRenderData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.renderData.p, fieldName: "renderData", required: true, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialRenderData>.self)
    try _v.visit(field: VTOFFSET.color.p, fieldName: "color", required: true, type: UnityEngine_Color.self)
    try _v.visit(field: VTOFFSET.mainTextureId.p, fieldName: "mainTextureId", required: true, type: Unity_PolySpatial_Internals_PolySpatialAssetID.self)
    try _v.visit(field: VTOFFSET.maskTextureId.p, fieldName: "maskTextureId", required: true, type: Unity_PolySpatial_Internals_PolySpatialAssetID.self)
    try _v.visit(field: VTOFFSET.maskUvtransform.p, fieldName: "maskUvtransform", required: true, type: UnityEngine_Matrix4x4.self)
    try _v.visit(field: VTOFFSET.maskingOperation.p, fieldName: "maskingOperation", required: false, type: Unity_PolySpatial_Internals_PolySpatialMaskingOperation.self)
    try _v.visit(field: VTOFFSET.maskAlphaCutoff.p, fieldName: "maskAlphaCutoff", required: false, type: Float32.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialSortingGroupData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case depthPass = 4
    case members = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Defines when the depth of the models in this group are drawn relative to their color.
  internal var depthPass: Unity_PolySpatial_Internals_PolySpatialSortingDepthPass { let o = _accessor.offset(VTOFFSET.depthPass.v); return o == 0 ? .postPass : Unity_PolySpatial_Internals_PolySpatialSortingDepthPass(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .postPass }
  ///  List of renderers that are members of this sorting group.
  internal var hasMembers: Bool { let o = _accessor.offset(VTOFFSET.members.v); return o == 0 ? false : true }
  internal var membersCount: Int32 { let o = _accessor.offset(VTOFFSET.members.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func members(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialSortingOrder? { let o = _accessor.offset(VTOFFSET.members.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialSortingOrder.self, offset: _accessor.vector(at: o) + index * 24) }
  internal var membersAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialSortingOrder>? { return _accessor.getBufferPointer(at: VTOFFSET.members.v) }
  internal func mutableMembers(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialSortingOrder_Mutable? { let o = _accessor.offset(VTOFFSET.members.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialSortingOrder_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 24) }
  internal static func startPolySpatialSortingGroupData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  internal static func add(depthPass: Unity_PolySpatial_Internals_PolySpatialSortingDepthPass, _ fbb: inout FlatBufferBuilder) { fbb.add(element: depthPass.rawValue, def: 0, at: VTOFFSET.depthPass.p) }
  internal static func addVectorOf(members: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: members, at: VTOFFSET.members.p) }
  internal static func startVectorOfMembers(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialSortingOrder>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialSortingOrder>.alignment)
  }
  internal static func endPolySpatialSortingGroupData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [6]); return end }
  internal static func createPolySpatialSortingGroupData(
    _ fbb: inout FlatBufferBuilder,
    depthPass: Unity_PolySpatial_Internals_PolySpatialSortingDepthPass = .postPass,
    membersVectorOffset members: Offset
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialSortingGroupData.startPolySpatialSortingGroupData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialSortingGroupData.add(depthPass: depthPass, &fbb)
    Unity_PolySpatial_Internals_PolySpatialSortingGroupData.addVectorOf(members: members, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialSortingGroupData.endPolySpatialSortingGroupData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.depthPass.p, fieldName: "depthPass", required: false, type: Unity_PolySpatial_Internals_PolySpatialSortingDepthPass.self)
    try _v.visit(field: VTOFFSET.members.p, fieldName: "members", required: true, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialSortingOrder, Unity_PolySpatial_Internals_PolySpatialSortingOrder>>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceEvent: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case deviceName = 4
    case deviceLayout = 6
    case deviceBaseLayouts = 8
    case deviceVariants = 10
    case deviceId = 12
    case deviceStatus = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var deviceName: String? { let o = _accessor.offset(VTOFFSET.deviceName.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var deviceNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.deviceName.v) }
  internal var deviceLayout: String? { let o = _accessor.offset(VTOFFSET.deviceLayout.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var deviceLayoutSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.deviceLayout.v) }
  internal var hasDeviceBaseLayouts: Bool { let o = _accessor.offset(VTOFFSET.deviceBaseLayouts.v); return o == 0 ? false : true }
  internal var deviceBaseLayoutsCount: Int32 { let o = _accessor.offset(VTOFFSET.deviceBaseLayouts.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func deviceBaseLayouts(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.deviceBaseLayouts.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  internal var deviceVariants: String? { let o = _accessor.offset(VTOFFSET.deviceVariants.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var deviceVariantsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.deviceVariants.v) }
  internal var deviceId: Int32 { let o = _accessor.offset(VTOFFSET.deviceId.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var deviceStatus: Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceStatus { let o = _accessor.offset(VTOFFSET.deviceStatus.v); return o == 0 ? .added : Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceStatus(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .added }
  internal static func startPolySpatialInputSystemDeviceEvent(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  internal static func add(deviceName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: deviceName, at: VTOFFSET.deviceName.p) }
  internal static func add(deviceLayout: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: deviceLayout, at: VTOFFSET.deviceLayout.p) }
  internal static func addVectorOf(deviceBaseLayouts: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: deviceBaseLayouts, at: VTOFFSET.deviceBaseLayouts.p) }
  internal static func add(deviceVariants: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: deviceVariants, at: VTOFFSET.deviceVariants.p) }
  internal static func add(deviceId: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: deviceId, def: 0, at: VTOFFSET.deviceId.p) }
  internal static func add(deviceStatus: Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceStatus, _ fbb: inout FlatBufferBuilder) { fbb.add(element: deviceStatus.rawValue, def: 0, at: VTOFFSET.deviceStatus.p) }
  internal static func endPolySpatialInputSystemDeviceEvent(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialInputSystemDeviceEvent(
    _ fbb: inout FlatBufferBuilder,
    deviceNameOffset deviceName: Offset = Offset(),
    deviceLayoutOffset deviceLayout: Offset = Offset(),
    deviceBaseLayoutsVectorOffset deviceBaseLayouts: Offset = Offset(),
    deviceVariantsOffset deviceVariants: Offset = Offset(),
    deviceId: Int32 = 0,
    deviceStatus: Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceStatus = .added
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceEvent.startPolySpatialInputSystemDeviceEvent(&fbb)
    Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceEvent.add(deviceName: deviceName, &fbb)
    Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceEvent.add(deviceLayout: deviceLayout, &fbb)
    Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceEvent.addVectorOf(deviceBaseLayouts: deviceBaseLayouts, &fbb)
    Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceEvent.add(deviceVariants: deviceVariants, &fbb)
    Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceEvent.add(deviceId: deviceId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceEvent.add(deviceStatus: deviceStatus, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceEvent.endPolySpatialInputSystemDeviceEvent(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.deviceName.p, fieldName: "deviceName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.deviceLayout.p, fieldName: "deviceLayout", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.deviceBaseLayouts.p, fieldName: "deviceBaseLayouts", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.deviceVariants.p, fieldName: "deviceVariants", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.deviceId.p, fieldName: "deviceId", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.deviceStatus.p, fieldName: "deviceStatus", required: false, type: Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceStatus.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceConnectionEvent: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case deviceName = 4
    case deviceId = 6
    case connectedDeviceLayout = 8
    case isConnected = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var deviceName: String? { let o = _accessor.offset(VTOFFSET.deviceName.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var deviceNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.deviceName.v) }
  internal var deviceId: Int32 { let o = _accessor.offset(VTOFFSET.deviceId.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var connectedDeviceLayout: String? { let o = _accessor.offset(VTOFFSET.connectedDeviceLayout.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var connectedDeviceLayoutSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.connectedDeviceLayout.v) }
  internal var isConnected: Bool { let o = _accessor.offset(VTOFFSET.isConnected.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal static func startPolySpatialInputSystemDeviceConnectionEvent(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  internal static func add(deviceName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: deviceName, at: VTOFFSET.deviceName.p) }
  internal static func add(deviceId: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: deviceId, def: 0, at: VTOFFSET.deviceId.p) }
  internal static func add(connectedDeviceLayout: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: connectedDeviceLayout, at: VTOFFSET.connectedDeviceLayout.p) }
  internal static func add(isConnected: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isConnected, def: false,
   at: VTOFFSET.isConnected.p) }
  internal static func endPolySpatialInputSystemDeviceConnectionEvent(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialInputSystemDeviceConnectionEvent(
    _ fbb: inout FlatBufferBuilder,
    deviceNameOffset deviceName: Offset = Offset(),
    deviceId: Int32 = 0,
    connectedDeviceLayoutOffset connectedDeviceLayout: Offset = Offset(),
    isConnected: Bool = false
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceConnectionEvent.startPolySpatialInputSystemDeviceConnectionEvent(&fbb)
    Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceConnectionEvent.add(deviceName: deviceName, &fbb)
    Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceConnectionEvent.add(deviceId: deviceId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceConnectionEvent.add(connectedDeviceLayout: connectedDeviceLayout, &fbb)
    Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceConnectionEvent.add(isConnected: isConnected, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialInputSystemDeviceConnectionEvent.endPolySpatialInputSystemDeviceConnectionEvent(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.deviceName.p, fieldName: "deviceName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.deviceId.p, fieldName: "deviceId", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.connectedDeviceLayout.p, fieldName: "connectedDeviceLayout", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.isConnected.p, fieldName: "isConnected", required: false, type: Bool.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialShaderPropertyMapData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case name = 4
    case floatProperties = 6
    case intProperties = 8
    case vector4Properties = 10
    case colorProperties = 12
    case matrix4x4Properties = 14
    case textureProperties = 16
    case texturePropertyTransformsEnabled = 18
    case keywords = 20
    case cullMode = 22
    case zTestMode = 24
    case zWriteControl = 26
    case castShadows = 28
    case allowMaterialOverride = 30
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  internal var hasFloatProperties: Bool { let o = _accessor.offset(VTOFFSET.floatProperties.v); return o == 0 ? false : true }
  internal var floatPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.floatProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func floatProperties(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.floatProperties.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  internal var hasIntProperties: Bool { let o = _accessor.offset(VTOFFSET.intProperties.v); return o == 0 ? false : true }
  internal var intPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.intProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func intProperties(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.intProperties.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  internal var hasVector4Properties: Bool { let o = _accessor.offset(VTOFFSET.vector4Properties.v); return o == 0 ? false : true }
  internal var vector4PropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.vector4Properties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func vector4Properties(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.vector4Properties.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  internal var hasColorProperties: Bool { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? false : true }
  internal var colorPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func colorProperties(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  internal var hasMatrix4x4Properties: Bool { let o = _accessor.offset(VTOFFSET.matrix4x4Properties.v); return o == 0 ? false : true }
  internal var matrix4x4PropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.matrix4x4Properties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func matrix4x4Properties(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.matrix4x4Properties.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  internal var hasTextureProperties: Bool { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? false : true }
  internal var texturePropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func textureProperties(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  internal var hasTexturePropertyTransformsEnabled: Bool { let o = _accessor.offset(VTOFFSET.texturePropertyTransformsEnabled.v); return o == 0 ? false : true }
  internal var texturePropertyTransformsEnabledCount: Int32 { let o = _accessor.offset(VTOFFSET.texturePropertyTransformsEnabled.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func texturePropertyTransformsEnabled(at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.texturePropertyTransformsEnabled.v); return o == 0 ? true : _accessor.directRead(of: Bool.self, offset: _accessor.vector(at: o) + index * 1) }
  internal var texturePropertyTransformsEnabled: [Bool] { return _accessor.getVector(at: VTOFFSET.texturePropertyTransformsEnabled.v) ?? [] }
  internal var texturePropertyTransformsEnabledAsBuffer: UnsafeBufferPointer<Bool>? { return _accessor.getBufferPointer(at: VTOFFSET.texturePropertyTransformsEnabled.v) }
  internal var hasKeywords: Bool { let o = _accessor.offset(VTOFFSET.keywords.v); return o == 0 ? false : true }
  internal var keywordsCount: Int32 { let o = _accessor.offset(VTOFFSET.keywords.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func keywords(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.keywords.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  internal var cullMode: Unity_PolySpatial_Internals_PolySpatialCullMode { let o = _accessor.offset(VTOFFSET.cullMode.v); return o == 0 ? .none_ : Unity_PolySpatial_Internals_PolySpatialCullMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .none_ }
  internal var zTestMode: Unity_PolySpatial_Internals_PolySpatialCompareFunction { let o = _accessor.offset(VTOFFSET.zTestMode.v); return o == 0 ? .disabled : Unity_PolySpatial_Internals_PolySpatialCompareFunction(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .disabled }
  internal var zWriteControl: Unity_PolySpatial_Internals_PolySpatialZWriteControl { let o = _accessor.offset(VTOFFSET.zWriteControl.v); return o == 0 ? .auto : Unity_PolySpatial_Internals_PolySpatialZWriteControl(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .auto }
  internal var castShadows: Bool { let o = _accessor.offset(VTOFFSET.castShadows.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var allowMaterialOverride: Bool { let o = _accessor.offset(VTOFFSET.allowMaterialOverride.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal static func startPolySpatialShaderPropertyMapData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 14) }
  internal static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  internal static func addVectorOf(floatProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: floatProperties, at: VTOFFSET.floatProperties.p) }
  internal static func addVectorOf(intProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: intProperties, at: VTOFFSET.intProperties.p) }
  internal static func addVectorOf(vector4Properties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vector4Properties, at: VTOFFSET.vector4Properties.p) }
  internal static func addVectorOf(colorProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: colorProperties, at: VTOFFSET.colorProperties.p) }
  internal static func addVectorOf(matrix4x4Properties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: matrix4x4Properties, at: VTOFFSET.matrix4x4Properties.p) }
  internal static func addVectorOf(textureProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: textureProperties, at: VTOFFSET.textureProperties.p) }
  internal static func addVectorOf(texturePropertyTransformsEnabled: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: texturePropertyTransformsEnabled, at: VTOFFSET.texturePropertyTransformsEnabled.p) }
  internal static func addVectorOf(keywords: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: keywords, at: VTOFFSET.keywords.p) }
  internal static func add(cullMode: Unity_PolySpatial_Internals_PolySpatialCullMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: cullMode.rawValue, def: 0, at: VTOFFSET.cullMode.p) }
  internal static func add(zTestMode: Unity_PolySpatial_Internals_PolySpatialCompareFunction, _ fbb: inout FlatBufferBuilder) { fbb.add(element: zTestMode.rawValue, def: 0, at: VTOFFSET.zTestMode.p) }
  internal static func add(zWriteControl: Unity_PolySpatial_Internals_PolySpatialZWriteControl, _ fbb: inout FlatBufferBuilder) { fbb.add(element: zWriteControl.rawValue, def: 0, at: VTOFFSET.zWriteControl.p) }
  internal static func add(castShadows: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: castShadows, def: false,
   at: VTOFFSET.castShadows.p) }
  internal static func add(allowMaterialOverride: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: allowMaterialOverride, def: false,
   at: VTOFFSET.allowMaterialOverride.p) }
  internal static func endPolySpatialShaderPropertyMapData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialShaderPropertyMapData(
    _ fbb: inout FlatBufferBuilder,
    nameOffset name: Offset = Offset(),
    floatPropertiesVectorOffset floatProperties: Offset = Offset(),
    intPropertiesVectorOffset intProperties: Offset = Offset(),
    vector4PropertiesVectorOffset vector4Properties: Offset = Offset(),
    colorPropertiesVectorOffset colorProperties: Offset = Offset(),
    matrix4x4PropertiesVectorOffset matrix4x4Properties: Offset = Offset(),
    texturePropertiesVectorOffset textureProperties: Offset = Offset(),
    texturePropertyTransformsEnabledVectorOffset texturePropertyTransformsEnabled: Offset = Offset(),
    keywordsVectorOffset keywords: Offset = Offset(),
    cullMode: Unity_PolySpatial_Internals_PolySpatialCullMode = .none_,
    zTestMode: Unity_PolySpatial_Internals_PolySpatialCompareFunction = .disabled,
    zWriteControl: Unity_PolySpatial_Internals_PolySpatialZWriteControl = .auto,
    castShadows: Bool = false,
    allowMaterialOverride: Bool = false
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialShaderPropertyMapData.startPolySpatialShaderPropertyMapData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderPropertyMapData.add(name: name, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderPropertyMapData.addVectorOf(floatProperties: floatProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderPropertyMapData.addVectorOf(intProperties: intProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderPropertyMapData.addVectorOf(vector4Properties: vector4Properties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderPropertyMapData.addVectorOf(colorProperties: colorProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderPropertyMapData.addVectorOf(matrix4x4Properties: matrix4x4Properties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderPropertyMapData.addVectorOf(textureProperties: textureProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderPropertyMapData.addVectorOf(texturePropertyTransformsEnabled: texturePropertyTransformsEnabled, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderPropertyMapData.addVectorOf(keywords: keywords, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderPropertyMapData.add(cullMode: cullMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderPropertyMapData.add(zTestMode: zTestMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderPropertyMapData.add(zWriteControl: zWriteControl, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderPropertyMapData.add(castShadows: castShadows, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderPropertyMapData.add(allowMaterialOverride: allowMaterialOverride, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialShaderPropertyMapData.endPolySpatialShaderPropertyMapData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.floatProperties.p, fieldName: "floatProperties", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.intProperties.p, fieldName: "intProperties", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.vector4Properties.p, fieldName: "vector4Properties", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.colorProperties.p, fieldName: "colorProperties", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.matrix4x4Properties.p, fieldName: "matrix4x4Properties", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.textureProperties.p, fieldName: "textureProperties", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.texturePropertyTransformsEnabled.p, fieldName: "texturePropertyTransformsEnabled", required: false, type: ForwardOffset<Vector<Bool, Bool>>.self)
    try _v.visit(field: VTOFFSET.keywords.p, fieldName: "keywords", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.cullMode.p, fieldName: "cullMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialCullMode.self)
    try _v.visit(field: VTOFFSET.zTestMode.p, fieldName: "zTestMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialCompareFunction.self)
    try _v.visit(field: VTOFFSET.zWriteControl.p, fieldName: "zWriteControl", required: false, type: Unity_PolySpatial_Internals_PolySpatialZWriteControl.self)
    try _v.visit(field: VTOFFSET.castShadows.p, fieldName: "castShadows", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.allowMaterialOverride.p, fieldName: "allowMaterialOverride", required: false, type: Bool.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialBuildTargetShader: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case buildTarget = 4
    case compiledData = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var buildTarget: Unity_PolySpatial_Internals_PolySpatialBuildTarget { let o = _accessor.offset(VTOFFSET.buildTarget.v); return o == 0 ? .unused : Unity_PolySpatial_Internals_PolySpatialBuildTarget(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .unused }
  internal var hasCompiledData: Bool { let o = _accessor.offset(VTOFFSET.compiledData.v); return o == 0 ? false : true }
  internal var compiledDataCount: Int32 { let o = _accessor.offset(VTOFFSET.compiledData.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func compiledData(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.compiledData.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  internal var compiledData: [UInt8] { return _accessor.getVector(at: VTOFFSET.compiledData.v) ?? [] }
  internal var compiledDataAsBuffer: UnsafeBufferPointer<UInt8>? { return _accessor.getBufferPointer(at: VTOFFSET.compiledData.v) }
  internal static func startPolySpatialBuildTargetShader(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  internal static func add(buildTarget: Unity_PolySpatial_Internals_PolySpatialBuildTarget, _ fbb: inout FlatBufferBuilder) { fbb.add(element: buildTarget.rawValue, def: 0, at: VTOFFSET.buildTarget.p) }
  internal static func addVectorOf(compiledData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: compiledData, at: VTOFFSET.compiledData.p) }
  internal static func endPolySpatialBuildTargetShader(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [6]); return end }
  internal static func createPolySpatialBuildTargetShader(
    _ fbb: inout FlatBufferBuilder,
    buildTarget: Unity_PolySpatial_Internals_PolySpatialBuildTarget = .unused,
    compiledDataVectorOffset compiledData: Offset
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialBuildTargetShader.startPolySpatialBuildTargetShader(&fbb)
    Unity_PolySpatial_Internals_PolySpatialBuildTargetShader.add(buildTarget: buildTarget, &fbb)
    Unity_PolySpatial_Internals_PolySpatialBuildTargetShader.addVectorOf(compiledData: compiledData, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialBuildTargetShader.endPolySpatialBuildTargetShader(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.buildTarget.p, fieldName: "buildTarget", required: false, type: Unity_PolySpatial_Internals_PolySpatialBuildTarget.self)
    try _v.visit(field: VTOFFSET.compiledData.p, fieldName: "compiledData", required: true, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialShaderData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case name = 4
    case streamingPath = 6
    case materialXencoding = 8
    case materialXprimPath = 10
    case targetShaders = 12
    case dependencies = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  internal var streamingPath: String? { let o = _accessor.offset(VTOFFSET.streamingPath.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var streamingPathSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.streamingPath.v) }
  internal var materialXencoding: String? { let o = _accessor.offset(VTOFFSET.materialXencoding.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var materialXencodingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.materialXencoding.v) }
  internal var materialXprimPath: String? { let o = _accessor.offset(VTOFFSET.materialXprimPath.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var materialXprimPathSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.materialXprimPath.v) }
  internal var hasTargetShaders: Bool { let o = _accessor.offset(VTOFFSET.targetShaders.v); return o == 0 ? false : true }
  internal var targetShadersCount: Int32 { let o = _accessor.offset(VTOFFSET.targetShaders.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func targetShaders(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialBuildTargetShader? { let o = _accessor.offset(VTOFFSET.targetShaders.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialBuildTargetShader(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  internal var hasDependencies: Bool { let o = _accessor.offset(VTOFFSET.dependencies.v); return o == 0 ? false : true }
  internal var dependenciesCount: Int32 { let o = _accessor.offset(VTOFFSET.dependencies.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func dependencies(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialAssetID? { let o = _accessor.offset(VTOFFSET.dependencies.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, offset: _accessor.vector(at: o) + index * 24) }
  internal var dependenciesAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialAssetID>? { return _accessor.getBufferPointer(at: VTOFFSET.dependencies.v) }
  internal func mutableDependencies(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable? { let o = _accessor.offset(VTOFFSET.dependencies.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 24) }
  internal static func startPolySpatialShaderData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  internal static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  internal static func add(streamingPath: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: streamingPath, at: VTOFFSET.streamingPath.p) }
  internal static func add(materialXencoding: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: materialXencoding, at: VTOFFSET.materialXencoding.p) }
  internal static func add(materialXprimPath: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: materialXprimPath, at: VTOFFSET.materialXprimPath.p) }
  internal static func addVectorOf(targetShaders: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: targetShaders, at: VTOFFSET.targetShaders.p) }
  internal static func addVectorOf(dependencies: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: dependencies, at: VTOFFSET.dependencies.p) }
  internal static func startVectorOfDependencies(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialAssetID>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialAssetID>.alignment)
  }
  internal static func endPolySpatialShaderData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialShaderData(
    _ fbb: inout FlatBufferBuilder,
    nameOffset name: Offset = Offset(),
    streamingPathOffset streamingPath: Offset = Offset(),
    materialXencodingOffset materialXencoding: Offset = Offset(),
    materialXprimPathOffset materialXprimPath: Offset = Offset(),
    targetShadersVectorOffset targetShaders: Offset = Offset(),
    dependenciesVectorOffset dependencies: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialShaderData.startPolySpatialShaderData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderData.add(name: name, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderData.add(streamingPath: streamingPath, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderData.add(materialXencoding: materialXencoding, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderData.add(materialXprimPath: materialXprimPath, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderData.addVectorOf(targetShaders: targetShaders, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderData.addVectorOf(dependencies: dependencies, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialShaderData.endPolySpatialShaderData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.streamingPath.p, fieldName: "streamingPath", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.materialXencoding.p, fieldName: "materialXencoding", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.materialXprimPath.p, fieldName: "materialXprimPath", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.targetShaders.p, fieldName: "targetShaders", required: false, type: ForwardOffset<Vector<ForwardOffset<Unity_PolySpatial_Internals_PolySpatialBuildTargetShader>, Unity_PolySpatial_Internals_PolySpatialBuildTargetShader>>.self)
    try _v.visit(field: VTOFFSET.dependencies.p, fieldName: "dependencies", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialAssetID, Unity_PolySpatial_Internals_PolySpatialAssetID>>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialShaderMaterial: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case shaderId = 4
    case shaderPropertyMapId = 6
    case floatProperties = 8
    case intProperties = 10
    case vector4Properties = 12
    case colorProperties = 14
    case matrix4x4Properties = 16
    case textureProperties = 18
    case textureTransformProperties = 20
    case hasProperties = 22
    case keywordValues = 24
    case enableInstancing = 26
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var shaderId: Unity_PolySpatial_Internals_PolySpatialAssetID? { let o = _accessor.offset(VTOFFSET.shaderId.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, at: o) }
  internal var mutableShaderId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable? { let o = _accessor.offset(VTOFFSET.shaderId.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var shaderPropertyMapId: Unity_PolySpatial_Internals_PolySpatialAssetID? { let o = _accessor.offset(VTOFFSET.shaderPropertyMapId.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, at: o) }
  internal var mutableShaderPropertyMapId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable? { let o = _accessor.offset(VTOFFSET.shaderPropertyMapId.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var hasFloatProperties: Bool { let o = _accessor.offset(VTOFFSET.floatProperties.v); return o == 0 ? false : true }
  internal var floatPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.floatProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func floatProperties(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.floatProperties.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  internal var floatProperties: [Float32] { return _accessor.getVector(at: VTOFFSET.floatProperties.v) ?? [] }
  internal var floatPropertiesAsBuffer: UnsafeBufferPointer<Float32>? { return _accessor.getBufferPointer(at: VTOFFSET.floatProperties.v) }
  internal var hasIntProperties: Bool { let o = _accessor.offset(VTOFFSET.intProperties.v); return o == 0 ? false : true }
  internal var intPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.intProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func intProperties(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.intProperties.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  internal var intProperties: [Int32] { return _accessor.getVector(at: VTOFFSET.intProperties.v) ?? [] }
  internal var intPropertiesAsBuffer: UnsafeBufferPointer<Int32>? { return _accessor.getBufferPointer(at: VTOFFSET.intProperties.v) }
  internal var hasVector4Properties: Bool { let o = _accessor.offset(VTOFFSET.vector4Properties.v); return o == 0 ? false : true }
  internal var vector4PropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.vector4Properties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func vector4Properties(at index: Int32) -> UnityEngine_Vector4? { let o = _accessor.offset(VTOFFSET.vector4Properties.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector4.self, offset: _accessor.vector(at: o) + index * 16) }
  internal var vector4PropertiesAsBuffer: UnsafeBufferPointer<UnityEngine_Vector4>? { return _accessor.getBufferPointer(at: VTOFFSET.vector4Properties.v) }
  internal func mutableVector4Properties(at index: Int32) -> UnityEngine_Vector4_Mutable? { let o = _accessor.offset(VTOFFSET.vector4Properties.v); return o == 0 ? nil : UnityEngine_Vector4_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 16) }
  internal var hasColorProperties: Bool { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? false : true }
  internal var colorPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func colorProperties(at index: Int32) -> UnityEngine_Color32? { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Color32.self, offset: _accessor.vector(at: o) + index * 4) }
  internal var colorPropertiesAsBuffer: UnsafeBufferPointer<UnityEngine_Color32>? { return _accessor.getBufferPointer(at: VTOFFSET.colorProperties.v) }
  internal func mutableColorProperties(at index: Int32) -> UnityEngine_Color32_Mutable? { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? nil : UnityEngine_Color32_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 4) }
  internal var hasMatrix4x4Properties: Bool { let o = _accessor.offset(VTOFFSET.matrix4x4Properties.v); return o == 0 ? false : true }
  internal var matrix4x4PropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.matrix4x4Properties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func matrix4x4Properties(at index: Int32) -> UnityEngine_Matrix4x4? { let o = _accessor.offset(VTOFFSET.matrix4x4Properties.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Matrix4x4.self, offset: _accessor.vector(at: o) + index * 64) }
  internal var matrix4x4PropertiesAsBuffer: UnsafeBufferPointer<UnityEngine_Matrix4x4>? { return _accessor.getBufferPointer(at: VTOFFSET.matrix4x4Properties.v) }
  internal func mutableMatrix4x4Properties(at index: Int32) -> UnityEngine_Matrix4x4_Mutable? { let o = _accessor.offset(VTOFFSET.matrix4x4Properties.v); return o == 0 ? nil : UnityEngine_Matrix4x4_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 64) }
  internal var hasTextureProperties: Bool { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? false : true }
  internal var texturePropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func textureProperties(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialAssetID? { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, offset: _accessor.vector(at: o) + index * 24) }
  internal var texturePropertiesAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialAssetID>? { return _accessor.getBufferPointer(at: VTOFFSET.textureProperties.v) }
  internal func mutableTextureProperties(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable? { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 24) }
  internal var hasTextureTransformProperties: Bool { let o = _accessor.offset(VTOFFSET.textureTransformProperties.v); return o == 0 ? false : true }
  internal var textureTransformPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.textureTransformProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func textureTransformProperties(at index: Int32) -> UnityEngine_Vector4? { let o = _accessor.offset(VTOFFSET.textureTransformProperties.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector4.self, offset: _accessor.vector(at: o) + index * 16) }
  internal var textureTransformPropertiesAsBuffer: UnsafeBufferPointer<UnityEngine_Vector4>? { return _accessor.getBufferPointer(at: VTOFFSET.textureTransformProperties.v) }
  internal func mutableTextureTransformProperties(at index: Int32) -> UnityEngine_Vector4_Mutable? { let o = _accessor.offset(VTOFFSET.textureTransformProperties.v); return o == 0 ? nil : UnityEngine_Vector4_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 16) }
  internal var hasHasProperties: Bool { let o = _accessor.offset(VTOFFSET.hasProperties.v); return o == 0 ? false : true }
  internal var hasPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.hasProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func hasProperties(at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.hasProperties.v); return o == 0 ? true : _accessor.directRead(of: Bool.self, offset: _accessor.vector(at: o) + index * 1) }
  internal var hasProperties: [Bool] { return _accessor.getVector(at: VTOFFSET.hasProperties.v) ?? [] }
  internal var hasPropertiesAsBuffer: UnsafeBufferPointer<Bool>? { return _accessor.getBufferPointer(at: VTOFFSET.hasProperties.v) }
  internal var hasKeywordValues: Bool { let o = _accessor.offset(VTOFFSET.keywordValues.v); return o == 0 ? false : true }
  internal var keywordValuesCount: Int32 { let o = _accessor.offset(VTOFFSET.keywordValues.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func keywordValues(at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.keywordValues.v); return o == 0 ? true : _accessor.directRead(of: Bool.self, offset: _accessor.vector(at: o) + index * 1) }
  internal var keywordValues: [Bool] { return _accessor.getVector(at: VTOFFSET.keywordValues.v) ?? [] }
  internal var keywordValuesAsBuffer: UnsafeBufferPointer<Bool>? { return _accessor.getBufferPointer(at: VTOFFSET.keywordValues.v) }
  ///  Should GPU instancing be enabled or not.
  internal var enableInstancing: Bool { let o = _accessor.offset(VTOFFSET.enableInstancing.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal static func startPolySpatialShaderMaterial(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 12) }
  internal static func add(shaderId: Unity_PolySpatial_Internals_PolySpatialAssetID?, _ fbb: inout FlatBufferBuilder) { guard let shaderId = shaderId else { return }; fbb.create(struct: shaderId, position: VTOFFSET.shaderId.p) }
  internal static func add(shaderPropertyMapId: Unity_PolySpatial_Internals_PolySpatialAssetID?, _ fbb: inout FlatBufferBuilder) { guard let shaderPropertyMapId = shaderPropertyMapId else { return }; fbb.create(struct: shaderPropertyMapId, position: VTOFFSET.shaderPropertyMapId.p) }
  internal static func addVectorOf(floatProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: floatProperties, at: VTOFFSET.floatProperties.p) }
  internal static func addVectorOf(intProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: intProperties, at: VTOFFSET.intProperties.p) }
  internal static func addVectorOf(vector4Properties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vector4Properties, at: VTOFFSET.vector4Properties.p) }
  internal static func startVectorOfVector4Properties(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector4>.size, elementSize: MemoryLayout<UnityEngine_Vector4>.alignment)
  }
  internal static func addVectorOf(colorProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: colorProperties, at: VTOFFSET.colorProperties.p) }
  internal static func startVectorOfColorProperties(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Color32>.size, elementSize: MemoryLayout<UnityEngine_Color32>.alignment)
  }
  internal static func addVectorOf(matrix4x4Properties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: matrix4x4Properties, at: VTOFFSET.matrix4x4Properties.p) }
  internal static func startVectorOfMatrix4x4Properties(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Matrix4x4>.size, elementSize: MemoryLayout<UnityEngine_Matrix4x4>.alignment)
  }
  internal static func addVectorOf(textureProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: textureProperties, at: VTOFFSET.textureProperties.p) }
  internal static func startVectorOfTextureProperties(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialAssetID>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialAssetID>.alignment)
  }
  internal static func addVectorOf(textureTransformProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: textureTransformProperties, at: VTOFFSET.textureTransformProperties.p) }
  internal static func startVectorOfTextureTransformProperties(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector4>.size, elementSize: MemoryLayout<UnityEngine_Vector4>.alignment)
  }
  internal static func addVectorOf(hasProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: hasProperties, at: VTOFFSET.hasProperties.p) }
  internal static func addVectorOf(keywordValues: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: keywordValues, at: VTOFFSET.keywordValues.p) }
  internal static func add(enableInstancing: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: enableInstancing, def: false,
   at: VTOFFSET.enableInstancing.p) }
  internal static func endPolySpatialShaderMaterial(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialShaderMaterial(
    _ fbb: inout FlatBufferBuilder,
    shaderId: Unity_PolySpatial_Internals_PolySpatialAssetID? = nil,
    shaderPropertyMapId: Unity_PolySpatial_Internals_PolySpatialAssetID? = nil,
    floatPropertiesVectorOffset floatProperties: Offset = Offset(),
    intPropertiesVectorOffset intProperties: Offset = Offset(),
    vector4PropertiesVectorOffset vector4Properties: Offset = Offset(),
    colorPropertiesVectorOffset colorProperties: Offset = Offset(),
    matrix4x4PropertiesVectorOffset matrix4x4Properties: Offset = Offset(),
    texturePropertiesVectorOffset textureProperties: Offset = Offset(),
    textureTransformPropertiesVectorOffset textureTransformProperties: Offset = Offset(),
    hasPropertiesVectorOffset hasProperties: Offset = Offset(),
    keywordValuesVectorOffset keywordValues: Offset = Offset(),
    enableInstancing: Bool = false
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialShaderMaterial.startPolySpatialShaderMaterial(&fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderMaterial.add(shaderId: shaderId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderMaterial.add(shaderPropertyMapId: shaderPropertyMapId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderMaterial.addVectorOf(floatProperties: floatProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderMaterial.addVectorOf(intProperties: intProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderMaterial.addVectorOf(vector4Properties: vector4Properties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderMaterial.addVectorOf(colorProperties: colorProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderMaterial.addVectorOf(matrix4x4Properties: matrix4x4Properties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderMaterial.addVectorOf(textureProperties: textureProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderMaterial.addVectorOf(textureTransformProperties: textureTransformProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderMaterial.addVectorOf(hasProperties: hasProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderMaterial.addVectorOf(keywordValues: keywordValues, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderMaterial.add(enableInstancing: enableInstancing, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialShaderMaterial.endPolySpatialShaderMaterial(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.shaderId.p, fieldName: "shaderId", required: false, type: Unity_PolySpatial_Internals_PolySpatialAssetID.self)
    try _v.visit(field: VTOFFSET.shaderPropertyMapId.p, fieldName: "shaderPropertyMapId", required: false, type: Unity_PolySpatial_Internals_PolySpatialAssetID.self)
    try _v.visit(field: VTOFFSET.floatProperties.p, fieldName: "floatProperties", required: false, type: ForwardOffset<Vector<Float32, Float32>>.self)
    try _v.visit(field: VTOFFSET.intProperties.p, fieldName: "intProperties", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.vector4Properties.p, fieldName: "vector4Properties", required: false, type: ForwardOffset<Vector<UnityEngine_Vector4, UnityEngine_Vector4>>.self)
    try _v.visit(field: VTOFFSET.colorProperties.p, fieldName: "colorProperties", required: false, type: ForwardOffset<Vector<UnityEngine_Color32, UnityEngine_Color32>>.self)
    try _v.visit(field: VTOFFSET.matrix4x4Properties.p, fieldName: "matrix4x4Properties", required: false, type: ForwardOffset<Vector<UnityEngine_Matrix4x4, UnityEngine_Matrix4x4>>.self)
    try _v.visit(field: VTOFFSET.textureProperties.p, fieldName: "textureProperties", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialAssetID, Unity_PolySpatial_Internals_PolySpatialAssetID>>.self)
    try _v.visit(field: VTOFFSET.textureTransformProperties.p, fieldName: "textureTransformProperties", required: false, type: ForwardOffset<Vector<UnityEngine_Vector4, UnityEngine_Vector4>>.self)
    try _v.visit(field: VTOFFSET.hasProperties.p, fieldName: "hasProperties", required: false, type: ForwardOffset<Vector<Bool, Bool>>.self)
    try _v.visit(field: VTOFFSET.keywordValues.p, fieldName: "keywordValues", required: false, type: ForwardOffset<Vector<Bool, Bool>>.self)
    try _v.visit(field: VTOFFSET.enableInstancing.p, fieldName: "enableInstancing", required: false, type: Bool.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyMap: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case floatProperties = 4
    case integerProperties = 6
    case vectorProperties = 8
    case colorProperties = 10
    case matrixProperties = 12
    case textureProperties = 14
    case keywords = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var hasFloatProperties: Bool { let o = _accessor.offset(VTOFFSET.floatProperties.v); return o == 0 ? false : true }
  internal var floatPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.floatProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func floatProperties(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.floatProperties.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  internal var hasIntegerProperties: Bool { let o = _accessor.offset(VTOFFSET.integerProperties.v); return o == 0 ? false : true }
  internal var integerPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.integerProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func integerProperties(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.integerProperties.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  internal var hasVectorProperties: Bool { let o = _accessor.offset(VTOFFSET.vectorProperties.v); return o == 0 ? false : true }
  internal var vectorPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.vectorProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func vectorProperties(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.vectorProperties.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  internal var hasColorProperties: Bool { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? false : true }
  internal var colorPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func colorProperties(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  internal var hasMatrixProperties: Bool { let o = _accessor.offset(VTOFFSET.matrixProperties.v); return o == 0 ? false : true }
  internal var matrixPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.matrixProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func matrixProperties(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.matrixProperties.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  internal var hasTextureProperties: Bool { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? false : true }
  internal var texturePropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func textureProperties(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  internal var hasKeywords: Bool { let o = _accessor.offset(VTOFFSET.keywords.v); return o == 0 ? false : true }
  internal var keywordsCount: Int32 { let o = _accessor.offset(VTOFFSET.keywords.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func keywords(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.keywords.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  internal static func startPolySpatialShaderGlobalPropertyMap(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  internal static func addVectorOf(floatProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: floatProperties, at: VTOFFSET.floatProperties.p) }
  internal static func addVectorOf(integerProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: integerProperties, at: VTOFFSET.integerProperties.p) }
  internal static func addVectorOf(vectorProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vectorProperties, at: VTOFFSET.vectorProperties.p) }
  internal static func addVectorOf(colorProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: colorProperties, at: VTOFFSET.colorProperties.p) }
  internal static func addVectorOf(matrixProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: matrixProperties, at: VTOFFSET.matrixProperties.p) }
  internal static func addVectorOf(textureProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: textureProperties, at: VTOFFSET.textureProperties.p) }
  internal static func addVectorOf(keywords: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: keywords, at: VTOFFSET.keywords.p) }
  internal static func endPolySpatialShaderGlobalPropertyMap(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialShaderGlobalPropertyMap(
    _ fbb: inout FlatBufferBuilder,
    floatPropertiesVectorOffset floatProperties: Offset = Offset(),
    integerPropertiesVectorOffset integerProperties: Offset = Offset(),
    vectorPropertiesVectorOffset vectorProperties: Offset = Offset(),
    colorPropertiesVectorOffset colorProperties: Offset = Offset(),
    matrixPropertiesVectorOffset matrixProperties: Offset = Offset(),
    texturePropertiesVectorOffset textureProperties: Offset = Offset(),
    keywordsVectorOffset keywords: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyMap.startPolySpatialShaderGlobalPropertyMap(&fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyMap.addVectorOf(floatProperties: floatProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyMap.addVectorOf(integerProperties: integerProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyMap.addVectorOf(vectorProperties: vectorProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyMap.addVectorOf(colorProperties: colorProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyMap.addVectorOf(matrixProperties: matrixProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyMap.addVectorOf(textureProperties: textureProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyMap.addVectorOf(keywords: keywords, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyMap.endPolySpatialShaderGlobalPropertyMap(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.floatProperties.p, fieldName: "floatProperties", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.integerProperties.p, fieldName: "integerProperties", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.vectorProperties.p, fieldName: "vectorProperties", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.colorProperties.p, fieldName: "colorProperties", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.matrixProperties.p, fieldName: "matrixProperties", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.textureProperties.p, fieldName: "textureProperties", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.keywords.p, fieldName: "keywords", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyValues: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case floatProperties = 4
    case integerProperties = 6
    case vectorProperties = 8
    case colorProperties = 10
    case matrixProperties = 12
    case textureProperties = 14
    case keywordValues = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var hasFloatProperties: Bool { let o = _accessor.offset(VTOFFSET.floatProperties.v); return o == 0 ? false : true }
  internal var floatPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.floatProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func floatProperties(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.floatProperties.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  internal var floatProperties: [Float32] { return _accessor.getVector(at: VTOFFSET.floatProperties.v) ?? [] }
  internal var floatPropertiesAsBuffer: UnsafeBufferPointer<Float32>? { return _accessor.getBufferPointer(at: VTOFFSET.floatProperties.v) }
  internal var hasIntegerProperties: Bool { let o = _accessor.offset(VTOFFSET.integerProperties.v); return o == 0 ? false : true }
  internal var integerPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.integerProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func integerProperties(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.integerProperties.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  internal var integerProperties: [Int32] { return _accessor.getVector(at: VTOFFSET.integerProperties.v) ?? [] }
  internal var integerPropertiesAsBuffer: UnsafeBufferPointer<Int32>? { return _accessor.getBufferPointer(at: VTOFFSET.integerProperties.v) }
  internal var hasVectorProperties: Bool { let o = _accessor.offset(VTOFFSET.vectorProperties.v); return o == 0 ? false : true }
  internal var vectorPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.vectorProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func vectorProperties(at index: Int32) -> UnityEngine_Vector4? { let o = _accessor.offset(VTOFFSET.vectorProperties.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector4.self, offset: _accessor.vector(at: o) + index * 16) }
  internal var vectorPropertiesAsBuffer: UnsafeBufferPointer<UnityEngine_Vector4>? { return _accessor.getBufferPointer(at: VTOFFSET.vectorProperties.v) }
  internal func mutableVectorProperties(at index: Int32) -> UnityEngine_Vector4_Mutable? { let o = _accessor.offset(VTOFFSET.vectorProperties.v); return o == 0 ? nil : UnityEngine_Vector4_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 16) }
  internal var hasColorProperties: Bool { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? false : true }
  internal var colorPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func colorProperties(at index: Int32) -> UnityEngine_Color32? { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Color32.self, offset: _accessor.vector(at: o) + index * 4) }
  internal var colorPropertiesAsBuffer: UnsafeBufferPointer<UnityEngine_Color32>? { return _accessor.getBufferPointer(at: VTOFFSET.colorProperties.v) }
  internal func mutableColorProperties(at index: Int32) -> UnityEngine_Color32_Mutable? { let o = _accessor.offset(VTOFFSET.colorProperties.v); return o == 0 ? nil : UnityEngine_Color32_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 4) }
  internal var hasMatrixProperties: Bool { let o = _accessor.offset(VTOFFSET.matrixProperties.v); return o == 0 ? false : true }
  internal var matrixPropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.matrixProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func matrixProperties(at index: Int32) -> UnityEngine_Matrix4x4? { let o = _accessor.offset(VTOFFSET.matrixProperties.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Matrix4x4.self, offset: _accessor.vector(at: o) + index * 64) }
  internal var matrixPropertiesAsBuffer: UnsafeBufferPointer<UnityEngine_Matrix4x4>? { return _accessor.getBufferPointer(at: VTOFFSET.matrixProperties.v) }
  internal func mutableMatrixProperties(at index: Int32) -> UnityEngine_Matrix4x4_Mutable? { let o = _accessor.offset(VTOFFSET.matrixProperties.v); return o == 0 ? nil : UnityEngine_Matrix4x4_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 64) }
  internal var hasTextureProperties: Bool { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? false : true }
  internal var texturePropertiesCount: Int32 { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func textureProperties(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialAssetID? { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, offset: _accessor.vector(at: o) + index * 24) }
  internal var texturePropertiesAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialAssetID>? { return _accessor.getBufferPointer(at: VTOFFSET.textureProperties.v) }
  internal func mutableTextureProperties(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable? { let o = _accessor.offset(VTOFFSET.textureProperties.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 24) }
  internal var hasKeywordValues: Bool { let o = _accessor.offset(VTOFFSET.keywordValues.v); return o == 0 ? false : true }
  internal var keywordValuesCount: Int32 { let o = _accessor.offset(VTOFFSET.keywordValues.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func keywordValues(at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.keywordValues.v); return o == 0 ? true : _accessor.directRead(of: Bool.self, offset: _accessor.vector(at: o) + index * 1) }
  internal var keywordValues: [Bool] { return _accessor.getVector(at: VTOFFSET.keywordValues.v) ?? [] }
  internal var keywordValuesAsBuffer: UnsafeBufferPointer<Bool>? { return _accessor.getBufferPointer(at: VTOFFSET.keywordValues.v) }
  internal static func startPolySpatialShaderGlobalPropertyValues(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  internal static func addVectorOf(floatProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: floatProperties, at: VTOFFSET.floatProperties.p) }
  internal static func addVectorOf(integerProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: integerProperties, at: VTOFFSET.integerProperties.p) }
  internal static func addVectorOf(vectorProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vectorProperties, at: VTOFFSET.vectorProperties.p) }
  internal static func startVectorOfVectorProperties(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector4>.size, elementSize: MemoryLayout<UnityEngine_Vector4>.alignment)
  }
  internal static func addVectorOf(colorProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: colorProperties, at: VTOFFSET.colorProperties.p) }
  internal static func startVectorOfColorProperties(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Color32>.size, elementSize: MemoryLayout<UnityEngine_Color32>.alignment)
  }
  internal static func addVectorOf(matrixProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: matrixProperties, at: VTOFFSET.matrixProperties.p) }
  internal static func startVectorOfMatrixProperties(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Matrix4x4>.size, elementSize: MemoryLayout<UnityEngine_Matrix4x4>.alignment)
  }
  internal static func addVectorOf(textureProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: textureProperties, at: VTOFFSET.textureProperties.p) }
  internal static func startVectorOfTextureProperties(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialAssetID>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialAssetID>.alignment)
  }
  internal static func addVectorOf(keywordValues: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: keywordValues, at: VTOFFSET.keywordValues.p) }
  internal static func endPolySpatialShaderGlobalPropertyValues(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialShaderGlobalPropertyValues(
    _ fbb: inout FlatBufferBuilder,
    floatPropertiesVectorOffset floatProperties: Offset = Offset(),
    integerPropertiesVectorOffset integerProperties: Offset = Offset(),
    vectorPropertiesVectorOffset vectorProperties: Offset = Offset(),
    colorPropertiesVectorOffset colorProperties: Offset = Offset(),
    matrixPropertiesVectorOffset matrixProperties: Offset = Offset(),
    texturePropertiesVectorOffset textureProperties: Offset = Offset(),
    keywordValuesVectorOffset keywordValues: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyValues.startPolySpatialShaderGlobalPropertyValues(&fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyValues.addVectorOf(floatProperties: floatProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyValues.addVectorOf(integerProperties: integerProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyValues.addVectorOf(vectorProperties: vectorProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyValues.addVectorOf(colorProperties: colorProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyValues.addVectorOf(matrixProperties: matrixProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyValues.addVectorOf(textureProperties: textureProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyValues.addVectorOf(keywordValues: keywordValues, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialShaderGlobalPropertyValues.endPolySpatialShaderGlobalPropertyValues(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.floatProperties.p, fieldName: "floatProperties", required: false, type: ForwardOffset<Vector<Float32, Float32>>.self)
    try _v.visit(field: VTOFFSET.integerProperties.p, fieldName: "integerProperties", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.vectorProperties.p, fieldName: "vectorProperties", required: false, type: ForwardOffset<Vector<UnityEngine_Vector4, UnityEngine_Vector4>>.self)
    try _v.visit(field: VTOFFSET.colorProperties.p, fieldName: "colorProperties", required: false, type: ForwardOffset<Vector<UnityEngine_Color32, UnityEngine_Color32>>.self)
    try _v.visit(field: VTOFFSET.matrixProperties.p, fieldName: "matrixProperties", required: false, type: ForwardOffset<Vector<UnityEngine_Matrix4x4, UnityEngine_Matrix4x4>>.self)
    try _v.visit(field: VTOFFSET.textureProperties.p, fieldName: "textureProperties", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialAssetID, Unity_PolySpatial_Internals_PolySpatialAssetID>>.self)
    try _v.visit(field: VTOFFSET.keywordValues.p, fieldName: "keywordValues", required: false, type: ForwardOffset<Vector<Bool, Bool>>.self)
    _v.finish()
  }
}

///  Contains Project settings that need to be remapped on the host
internal struct Unity_PolySpatial_Internals_PolySpatialProjectSettingsData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case sortingLayerIds = 4
    case sortingLayerNames = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var hasSortingLayerIds: Bool { let o = _accessor.offset(VTOFFSET.sortingLayerIds.v); return o == 0 ? false : true }
  internal var sortingLayerIdsCount: Int32 { let o = _accessor.offset(VTOFFSET.sortingLayerIds.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func sortingLayerIds(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.sortingLayerIds.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  internal var sortingLayerIds: [Int32] { return _accessor.getVector(at: VTOFFSET.sortingLayerIds.v) ?? [] }
  internal var sortingLayerIdsAsBuffer: UnsafeBufferPointer<Int32>? { return _accessor.getBufferPointer(at: VTOFFSET.sortingLayerIds.v) }
  internal var hasSortingLayerNames: Bool { let o = _accessor.offset(VTOFFSET.sortingLayerNames.v); return o == 0 ? false : true }
  internal var sortingLayerNamesCount: Int32 { let o = _accessor.offset(VTOFFSET.sortingLayerNames.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func sortingLayerNames(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.sortingLayerNames.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  internal static func startPolySpatialProjectSettingsData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  internal static func addVectorOf(sortingLayerIds: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sortingLayerIds, at: VTOFFSET.sortingLayerIds.p) }
  internal static func addVectorOf(sortingLayerNames: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sortingLayerNames, at: VTOFFSET.sortingLayerNames.p) }
  internal static func endPolySpatialProjectSettingsData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialProjectSettingsData(
    _ fbb: inout FlatBufferBuilder,
    sortingLayerIdsVectorOffset sortingLayerIds: Offset = Offset(),
    sortingLayerNamesVectorOffset sortingLayerNames: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialProjectSettingsData.startPolySpatialProjectSettingsData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialProjectSettingsData.addVectorOf(sortingLayerIds: sortingLayerIds, &fbb)
    Unity_PolySpatial_Internals_PolySpatialProjectSettingsData.addVectorOf(sortingLayerNames: sortingLayerNames, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialProjectSettingsData.endPolySpatialProjectSettingsData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.sortingLayerIds.p, fieldName: "sortingLayerIds", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.sortingLayerNames.p, fieldName: "sortingLayerNames", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    _v.finish()
  }
}

///  Class that captures the possible inputs for many particle properties.
///  In the case that the curve mode is constant or constant curve, the values will be stored in minValue and minCurveStartIndex respectively.
///  maxValue and maxCurveStartIndex will be left blank.
///  The keys are stored in one big buffer attached to the particle change message. The indices and length are used to retrieve the keys.
internal struct Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case mode = 4
    case curveMultiplier = 6
    case minValue = 8
    case maxValue = 10
    case minCurveStartIndex = 12
    case minCurveLength = 14
    case maxCurveStartIndex = 16
    case maxCurveLength = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var mode: Unity_PolySpatial_Internals_PolySpatialParticleCurveMode { let o = _accessor.offset(VTOFFSET.mode.v); return o == 0 ? .constant : Unity_PolySpatial_Internals_PolySpatialParticleCurveMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .constant }
  internal var curveMultiplier: Float32 { let o = _accessor.offset(VTOFFSET.curveMultiplier.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var minValue: Float32 { let o = _accessor.offset(VTOFFSET.minValue.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var maxValue: Float32 { let o = _accessor.offset(VTOFFSET.maxValue.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var minCurveStartIndex: Int32 { let o = _accessor.offset(VTOFFSET.minCurveStartIndex.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var minCurveLength: Int32 { let o = _accessor.offset(VTOFFSET.minCurveLength.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var maxCurveStartIndex: Int32 { let o = _accessor.offset(VTOFFSET.maxCurveStartIndex.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var maxCurveLength: Int32 { let o = _accessor.offset(VTOFFSET.maxCurveLength.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal static func startPolySpatialParticleMinMaxCurve(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  internal static func add(mode: Unity_PolySpatial_Internals_PolySpatialParticleCurveMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mode.rawValue, def: 0, at: VTOFFSET.mode.p) }
  internal static func add(curveMultiplier: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: curveMultiplier, def: 0.0, at: VTOFFSET.curveMultiplier.p) }
  internal static func add(minValue: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: minValue, def: 0.0, at: VTOFFSET.minValue.p) }
  internal static func add(maxValue: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: maxValue, def: 0.0, at: VTOFFSET.maxValue.p) }
  internal static func add(minCurveStartIndex: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: minCurveStartIndex, def: 0, at: VTOFFSET.minCurveStartIndex.p) }
  internal static func add(minCurveLength: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: minCurveLength, def: 0, at: VTOFFSET.minCurveLength.p) }
  internal static func add(maxCurveStartIndex: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: maxCurveStartIndex, def: 0, at: VTOFFSET.maxCurveStartIndex.p) }
  internal static func add(maxCurveLength: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: maxCurveLength, def: 0, at: VTOFFSET.maxCurveLength.p) }
  internal static func endPolySpatialParticleMinMaxCurve(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialParticleMinMaxCurve(
    _ fbb: inout FlatBufferBuilder,
    mode: Unity_PolySpatial_Internals_PolySpatialParticleCurveMode = .constant,
    curveMultiplier: Float32 = 0.0,
    minValue: Float32 = 0.0,
    maxValue: Float32 = 0.0,
    minCurveStartIndex: Int32 = 0,
    minCurveLength: Int32 = 0,
    maxCurveStartIndex: Int32 = 0,
    maxCurveLength: Int32 = 0
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve.startPolySpatialParticleMinMaxCurve(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve.add(mode: mode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve.add(curveMultiplier: curveMultiplier, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve.add(minValue: minValue, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve.add(maxValue: maxValue, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve.add(minCurveStartIndex: minCurveStartIndex, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve.add(minCurveLength: minCurveLength, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve.add(maxCurveStartIndex: maxCurveStartIndex, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve.add(maxCurveLength: maxCurveLength, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve.endPolySpatialParticleMinMaxCurve(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.mode.p, fieldName: "mode", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleCurveMode.self)
    try _v.visit(field: VTOFFSET.curveMultiplier.p, fieldName: "curveMultiplier", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.minValue.p, fieldName: "minValue", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.maxValue.p, fieldName: "maxValue", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.minCurveStartIndex.p, fieldName: "minCurveStartIndex", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.minCurveLength.p, fieldName: "minCurveLength", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.maxCurveStartIndex.p, fieldName: "maxCurveStartIndex", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.maxCurveLength.p, fieldName: "maxCurveLength", required: false, type: Int32.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case x = 4
    case y = 6
    case z = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var x: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve? { let o = _accessor.offset(VTOFFSET.x.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var y: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve? { let o = _accessor.offset(VTOFFSET.y.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var z: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve? { let o = _accessor.offset(VTOFFSET.z.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal static func startPolySpatialParticleMinMaxCurveVector3(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  internal static func add(x: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: x, at: VTOFFSET.x.p) }
  internal static func add(y: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: y, at: VTOFFSET.y.p) }
  internal static func add(z: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: z, at: VTOFFSET.z.p) }
  internal static func endPolySpatialParticleMinMaxCurveVector3(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialParticleMinMaxCurveVector3(
    _ fbb: inout FlatBufferBuilder,
    xOffset x: Offset = Offset(),
    yOffset y: Offset = Offset(),
    zOffset z: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3.startPolySpatialParticleMinMaxCurveVector3(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3.add(x: x, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3.add(y: y, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3.add(z: z, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3.endPolySpatialParticleMinMaxCurveVector3(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.x.p, fieldName: "x", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    try _v.visit(field: VTOFFSET.y.p, fieldName: "y", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    try _v.visit(field: VTOFFSET.z.p, fieldName: "z", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    _v.finish()
  }
}

///  Table that describes a particle gradient.
internal struct Unity_PolySpatial_Internals_PolySpatialParticleGradient: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case mode = 4
    case alphaKeysStartIndex = 6
    case alphaKeysLength = 8
    case colorKeysStartIndex = 10
    case colorKeysLength = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var mode: Unity_PolySpatial_Internals_PolySpatialParticleGradientMode { let o = _accessor.offset(VTOFFSET.mode.v); return o == 0 ? .perceptualBlend : Unity_PolySpatial_Internals_PolySpatialParticleGradientMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .perceptualBlend }
  internal var alphaKeysStartIndex: Int32 { let o = _accessor.offset(VTOFFSET.alphaKeysStartIndex.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var alphaKeysLength: Int32 { let o = _accessor.offset(VTOFFSET.alphaKeysLength.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var colorKeysStartIndex: Int32 { let o = _accessor.offset(VTOFFSET.colorKeysStartIndex.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var colorKeysLength: Int32 { let o = _accessor.offset(VTOFFSET.colorKeysLength.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal static func startPolySpatialParticleGradient(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  internal static func add(mode: Unity_PolySpatial_Internals_PolySpatialParticleGradientMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mode.rawValue, def: 0, at: VTOFFSET.mode.p) }
  internal static func add(alphaKeysStartIndex: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: alphaKeysStartIndex, def: 0, at: VTOFFSET.alphaKeysStartIndex.p) }
  internal static func add(alphaKeysLength: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: alphaKeysLength, def: 0, at: VTOFFSET.alphaKeysLength.p) }
  internal static func add(colorKeysStartIndex: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: colorKeysStartIndex, def: 0, at: VTOFFSET.colorKeysStartIndex.p) }
  internal static func add(colorKeysLength: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: colorKeysLength, def: 0, at: VTOFFSET.colorKeysLength.p) }
  internal static func endPolySpatialParticleGradient(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialParticleGradient(
    _ fbb: inout FlatBufferBuilder,
    mode: Unity_PolySpatial_Internals_PolySpatialParticleGradientMode = .perceptualBlend,
    alphaKeysStartIndex: Int32 = 0,
    alphaKeysLength: Int32 = 0,
    colorKeysStartIndex: Int32 = 0,
    colorKeysLength: Int32 = 0
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleGradient.startPolySpatialParticleGradient(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleGradient.add(mode: mode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleGradient.add(alphaKeysStartIndex: alphaKeysStartIndex, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleGradient.add(alphaKeysLength: alphaKeysLength, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleGradient.add(colorKeysStartIndex: colorKeysStartIndex, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleGradient.add(colorKeysLength: colorKeysLength, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleGradient.endPolySpatialParticleGradient(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.mode.p, fieldName: "mode", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleGradientMode.self)
    try _v.visit(field: VTOFFSET.alphaKeysStartIndex.p, fieldName: "alphaKeysStartIndex", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.alphaKeysLength.p, fieldName: "alphaKeysLength", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.colorKeysStartIndex.p, fieldName: "colorKeysStartIndex", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.colorKeysLength.p, fieldName: "colorKeysLength", required: false, type: Int32.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleMinMaxGradient: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case mode = 4
    case minColor = 6
    case maxColor = 8
    case minGradient = 10
    case maxGradient = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var mode: Unity_PolySpatial_Internals_PolySpatialParticleColorMode { let o = _accessor.offset(VTOFFSET.mode.v); return o == 0 ? .color : Unity_PolySpatial_Internals_PolySpatialParticleColorMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .color }
  internal var minColor: UnityEngine_Color32? { let o = _accessor.offset(VTOFFSET.minColor.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Color32.self, at: o) }
  internal var mutableMinColor: UnityEngine_Color32_Mutable? { let o = _accessor.offset(VTOFFSET.minColor.v); return o == 0 ? nil : UnityEngine_Color32_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var maxColor: UnityEngine_Color32? { let o = _accessor.offset(VTOFFSET.maxColor.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Color32.self, at: o) }
  internal var mutableMaxColor: UnityEngine_Color32_Mutable? { let o = _accessor.offset(VTOFFSET.maxColor.v); return o == 0 ? nil : UnityEngine_Color32_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var minGradient: Unity_PolySpatial_Internals_PolySpatialParticleGradient? { let o = _accessor.offset(VTOFFSET.minGradient.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleGradient(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var maxGradient: Unity_PolySpatial_Internals_PolySpatialParticleGradient? { let o = _accessor.offset(VTOFFSET.maxGradient.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleGradient(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal static func startPolySpatialParticleMinMaxGradient(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  internal static func add(mode: Unity_PolySpatial_Internals_PolySpatialParticleColorMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mode.rawValue, def: 0, at: VTOFFSET.mode.p) }
  internal static func add(minColor: UnityEngine_Color32?, _ fbb: inout FlatBufferBuilder) { guard let minColor = minColor else { return }; fbb.create(struct: minColor, position: VTOFFSET.minColor.p) }
  internal static func add(maxColor: UnityEngine_Color32?, _ fbb: inout FlatBufferBuilder) { guard let maxColor = maxColor else { return }; fbb.create(struct: maxColor, position: VTOFFSET.maxColor.p) }
  internal static func add(minGradient: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: minGradient, at: VTOFFSET.minGradient.p) }
  internal static func add(maxGradient: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: maxGradient, at: VTOFFSET.maxGradient.p) }
  internal static func endPolySpatialParticleMinMaxGradient(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialParticleMinMaxGradient(
    _ fbb: inout FlatBufferBuilder,
    mode: Unity_PolySpatial_Internals_PolySpatialParticleColorMode = .color,
    minColor: UnityEngine_Color32? = nil,
    maxColor: UnityEngine_Color32? = nil,
    minGradientOffset minGradient: Offset = Offset(),
    maxGradientOffset maxGradient: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleMinMaxGradient.startPolySpatialParticleMinMaxGradient(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMinMaxGradient.add(mode: mode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMinMaxGradient.add(minColor: minColor, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMinMaxGradient.add(maxColor: maxColor, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMinMaxGradient.add(minGradient: minGradient, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMinMaxGradient.add(maxGradient: maxGradient, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleMinMaxGradient.endPolySpatialParticleMinMaxGradient(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.mode.p, fieldName: "mode", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleColorMode.self)
    try _v.visit(field: VTOFFSET.minColor.p, fieldName: "minColor", required: false, type: UnityEngine_Color32.self)
    try _v.visit(field: VTOFFSET.maxColor.p, fieldName: "maxColor", required: false, type: UnityEngine_Color32.self)
    try _v.visit(field: VTOFFSET.minGradient.p, fieldName: "minGradient", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleGradient>.self)
    try _v.visit(field: VTOFFSET.maxGradient.p, fieldName: "maxGradient", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleGradient>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleMain: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case duration = 4
    case looping = 6
    case prewarm = 8
    case startSpeed = 10
    case startLifetime = 12
    case startSize = 14
    case isStartRotation3D = 16
    case startRotation = 18
    case startColor = 20
    case gravitySource = 22
    case gravityModifier = 24
    case simulationSpace = 26
    case scalingMode = 28
    case playOnAwake = 30
    case maxParticles = 32
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var duration: Float32 { let o = _accessor.offset(VTOFFSET.duration.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var looping: Bool { let o = _accessor.offset(VTOFFSET.looping.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var prewarm: Bool { let o = _accessor.offset(VTOFFSET.prewarm.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var startSpeed: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve! { let o = _accessor.offset(VTOFFSET.startSpeed.v); return Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var startLifetime: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve! { let o = _accessor.offset(VTOFFSET.startLifetime.v); return Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var startSize: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve! { let o = _accessor.offset(VTOFFSET.startSize.v); return Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var isStartRotation3D: Bool { let o = _accessor.offset(VTOFFSET.isStartRotation3D.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var startRotation: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3! { let o = _accessor.offset(VTOFFSET.startRotation.v); return Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var startColor: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxGradient! { let o = _accessor.offset(VTOFFSET.startColor.v); return Unity_PolySpatial_Internals_PolySpatialParticleMinMaxGradient(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var gravitySource: Unity_PolySpatial_Internals_PolySpatialParticleGravityMode { let o = _accessor.offset(VTOFFSET.gravitySource.v); return o == 0 ? .physics3D : Unity_PolySpatial_Internals_PolySpatialParticleGravityMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .physics3D }
  internal var gravityModifier: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve! { let o = _accessor.offset(VTOFFSET.gravityModifier.v); return Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var simulationSpace: Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace { let o = _accessor.offset(VTOFFSET.simulationSpace.v); return o == 0 ? .local : Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .local }
  internal var scalingMode: Unity_PolySpatial_Internals_PolySpatialParticleScalingMode { let o = _accessor.offset(VTOFFSET.scalingMode.v); return o == 0 ? .hierarchy : Unity_PolySpatial_Internals_PolySpatialParticleScalingMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .hierarchy }
  internal var playOnAwake: Bool { let o = _accessor.offset(VTOFFSET.playOnAwake.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var maxParticles: Int32 { let o = _accessor.offset(VTOFFSET.maxParticles.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal static func startPolySpatialParticleMain(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 15) }
  internal static func add(duration: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: duration, def: 0.0, at: VTOFFSET.duration.p) }
  internal static func add(looping: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: looping, def: false,
   at: VTOFFSET.looping.p) }
  internal static func add(prewarm: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: prewarm, def: false,
   at: VTOFFSET.prewarm.p) }
  internal static func add(startSpeed: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: startSpeed, at: VTOFFSET.startSpeed.p) }
  internal static func add(startLifetime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: startLifetime, at: VTOFFSET.startLifetime.p) }
  internal static func add(startSize: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: startSize, at: VTOFFSET.startSize.p) }
  internal static func add(isStartRotation3D: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isStartRotation3D, def: false,
   at: VTOFFSET.isStartRotation3D.p) }
  internal static func add(startRotation: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: startRotation, at: VTOFFSET.startRotation.p) }
  internal static func add(startColor: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: startColor, at: VTOFFSET.startColor.p) }
  internal static func add(gravitySource: Unity_PolySpatial_Internals_PolySpatialParticleGravityMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: gravitySource.rawValue, def: 0, at: VTOFFSET.gravitySource.p) }
  internal static func add(gravityModifier: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: gravityModifier, at: VTOFFSET.gravityModifier.p) }
  internal static func add(simulationSpace: Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace, _ fbb: inout FlatBufferBuilder) { fbb.add(element: simulationSpace.rawValue, def: 0, at: VTOFFSET.simulationSpace.p) }
  internal static func add(scalingMode: Unity_PolySpatial_Internals_PolySpatialParticleScalingMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: scalingMode.rawValue, def: 0, at: VTOFFSET.scalingMode.p) }
  internal static func add(playOnAwake: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: playOnAwake, def: false,
   at: VTOFFSET.playOnAwake.p) }
  internal static func add(maxParticles: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: maxParticles, def: 0, at: VTOFFSET.maxParticles.p) }
  internal static func endPolySpatialParticleMain(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [10, 12, 14, 18, 20, 24]); return end }
  internal static func createPolySpatialParticleMain(
    _ fbb: inout FlatBufferBuilder,
    duration: Float32 = 0.0,
    looping: Bool = false,
    prewarm: Bool = false,
    startSpeedOffset startSpeed: Offset,
    startLifetimeOffset startLifetime: Offset,
    startSizeOffset startSize: Offset,
    isStartRotation3D: Bool = false,
    startRotationOffset startRotation: Offset,
    startColorOffset startColor: Offset,
    gravitySource: Unity_PolySpatial_Internals_PolySpatialParticleGravityMode = .physics3D,
    gravityModifierOffset gravityModifier: Offset,
    simulationSpace: Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace = .local,
    scalingMode: Unity_PolySpatial_Internals_PolySpatialParticleScalingMode = .hierarchy,
    playOnAwake: Bool = false,
    maxParticles: Int32 = 0
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleMain.startPolySpatialParticleMain(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMain.add(duration: duration, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMain.add(looping: looping, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMain.add(prewarm: prewarm, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMain.add(startSpeed: startSpeed, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMain.add(startLifetime: startLifetime, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMain.add(startSize: startSize, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMain.add(isStartRotation3D: isStartRotation3D, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMain.add(startRotation: startRotation, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMain.add(startColor: startColor, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMain.add(gravitySource: gravitySource, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMain.add(gravityModifier: gravityModifier, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMain.add(simulationSpace: simulationSpace, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMain.add(scalingMode: scalingMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMain.add(playOnAwake: playOnAwake, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleMain.add(maxParticles: maxParticles, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleMain.endPolySpatialParticleMain(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.duration.p, fieldName: "duration", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.looping.p, fieldName: "looping", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.prewarm.p, fieldName: "prewarm", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.startSpeed.p, fieldName: "startSpeed", required: true, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    try _v.visit(field: VTOFFSET.startLifetime.p, fieldName: "startLifetime", required: true, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    try _v.visit(field: VTOFFSET.startSize.p, fieldName: "startSize", required: true, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    try _v.visit(field: VTOFFSET.isStartRotation3D.p, fieldName: "isStartRotation3D", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.startRotation.p, fieldName: "startRotation", required: true, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3>.self)
    try _v.visit(field: VTOFFSET.startColor.p, fieldName: "startColor", required: true, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxGradient>.self)
    try _v.visit(field: VTOFFSET.gravitySource.p, fieldName: "gravitySource", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleGravityMode.self)
    try _v.visit(field: VTOFFSET.gravityModifier.p, fieldName: "gravityModifier", required: true, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    try _v.visit(field: VTOFFSET.simulationSpace.p, fieldName: "simulationSpace", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace.self)
    try _v.visit(field: VTOFFSET.scalingMode.p, fieldName: "scalingMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleScalingMode.self)
    try _v.visit(field: VTOFFSET.playOnAwake.p, fieldName: "playOnAwake", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.maxParticles.p, fieldName: "maxParticles", required: false, type: Int32.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleEmission: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case rateOverTime = 4
    case burst = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var rateOverTime: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve? { let o = _accessor.offset(VTOFFSET.rateOverTime.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var hasBurst: Bool { let o = _accessor.offset(VTOFFSET.burst.v); return o == 0 ? false : true }
  internal var burstCount: Int32 { let o = _accessor.offset(VTOFFSET.burst.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func burst(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialParticleBurst? { let o = _accessor.offset(VTOFFSET.burst.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialParticleBurst.self, offset: _accessor.vector(at: o) + index * 20) }
  internal var burstAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialParticleBurst>? { return _accessor.getBufferPointer(at: VTOFFSET.burst.v) }
  internal func mutableBurst(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialParticleBurst_Mutable? { let o = _accessor.offset(VTOFFSET.burst.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleBurst_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 20) }
  internal static func startPolySpatialParticleEmission(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  internal static func add(rateOverTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rateOverTime, at: VTOFFSET.rateOverTime.p) }
  internal static func addVectorOf(burst: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: burst, at: VTOFFSET.burst.p) }
  internal static func startVectorOfBurst(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialParticleBurst>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialParticleBurst>.alignment)
  }
  internal static func endPolySpatialParticleEmission(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialParticleEmission(
    _ fbb: inout FlatBufferBuilder,
    rateOverTimeOffset rateOverTime: Offset = Offset(),
    burstVectorOffset burst: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleEmission.startPolySpatialParticleEmission(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmission.add(rateOverTime: rateOverTime, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmission.addVectorOf(burst: burst, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleEmission.endPolySpatialParticleEmission(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.rateOverTime.p, fieldName: "rateOverTime", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    try _v.visit(field: VTOFFSET.burst.p, fieldName: "burst", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialParticleBurst, Unity_PolySpatial_Internals_PolySpatialParticleBurst>>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case shape = 4
    case shapeMeshId = 6
    case emitFrom = 8
    case radius = 10
    case radiusMode = 12
    case radiusSpeed = 14
    case radiusSpread = 16
    case radiusThickness = 18
    case donutRadius = 20
    case boxThickness = 22
    case angle = 24
    case arc = 26
    case arcMode = 28
    case arcSpeed = 30
    case arcSpread = 32
    case length = 34
    case shapePosition = 36
    case shapeRotation = 38
    case shapeScale = 40
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var shape: Unity_PolySpatial_Internals_PolySpatialParticleEmitterGeometry { let o = _accessor.offset(VTOFFSET.shape.v); return o == 0 ? .sphere : Unity_PolySpatial_Internals_PolySpatialParticleEmitterGeometry(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .sphere }
  internal var shapeMeshId: Unity_PolySpatial_Internals_PolySpatialAssetID? { let o = _accessor.offset(VTOFFSET.shapeMeshId.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialAssetID.self, at: o) }
  internal var mutableShapeMeshId: Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable? { let o = _accessor.offset(VTOFFSET.shapeMeshId.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAssetID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var emitFrom: Unity_PolySpatial_Internals_PolySpatialParticleBirthLocation { let o = _accessor.offset(VTOFFSET.emitFrom.v); return o == 0 ? .edge : Unity_PolySpatial_Internals_PolySpatialParticleBirthLocation(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .edge }
  internal var radius: Float32 { let o = _accessor.offset(VTOFFSET.radius.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var radiusMode: Unity_PolySpatial_Internals_PolySpatialParticleMultiMode { let o = _accessor.offset(VTOFFSET.radiusMode.v); return o == 0 ? .random : Unity_PolySpatial_Internals_PolySpatialParticleMultiMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .random }
  internal var radiusSpeed: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve? { let o = _accessor.offset(VTOFFSET.radiusSpeed.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var radiusSpread: Float32 { let o = _accessor.offset(VTOFFSET.radiusSpread.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var radiusThickness: Float32 { let o = _accessor.offset(VTOFFSET.radiusThickness.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var donutRadius: Float32 { let o = _accessor.offset(VTOFFSET.donutRadius.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var boxThickness: UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.boxThickness.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector3.self, at: o) }
  internal var mutableBoxThickness: UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.boxThickness.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var angle: Float32 { let o = _accessor.offset(VTOFFSET.angle.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var arc: Float32 { let o = _accessor.offset(VTOFFSET.arc.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var arcMode: Unity_PolySpatial_Internals_PolySpatialParticleMultiMode { let o = _accessor.offset(VTOFFSET.arcMode.v); return o == 0 ? .random : Unity_PolySpatial_Internals_PolySpatialParticleMultiMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .random }
  internal var arcSpeed: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve? { let o = _accessor.offset(VTOFFSET.arcSpeed.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var arcSpread: Float32 { let o = _accessor.offset(VTOFFSET.arcSpread.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var length: Float32 { let o = _accessor.offset(VTOFFSET.length.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var shapePosition: UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.shapePosition.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector3.self, at: o) }
  internal var mutableShapePosition: UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.shapePosition.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var shapeRotation: UnityEngine_Quaternion? { let o = _accessor.offset(VTOFFSET.shapeRotation.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Quaternion.self, at: o) }
  internal var mutableShapeRotation: UnityEngine_Quaternion_Mutable? { let o = _accessor.offset(VTOFFSET.shapeRotation.v); return o == 0 ? nil : UnityEngine_Quaternion_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var shapeScale: UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.shapeScale.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector3.self, at: o) }
  internal var mutableShapeScale: UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.shapeScale.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal static func startPolySpatialParticleEmitterShape(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 19) }
  internal static func add(shape: Unity_PolySpatial_Internals_PolySpatialParticleEmitterGeometry, _ fbb: inout FlatBufferBuilder) { fbb.add(element: shape.rawValue, def: 0, at: VTOFFSET.shape.p) }
  internal static func add(shapeMeshId: Unity_PolySpatial_Internals_PolySpatialAssetID?, _ fbb: inout FlatBufferBuilder) { guard let shapeMeshId = shapeMeshId else { return }; fbb.create(struct: shapeMeshId, position: VTOFFSET.shapeMeshId.p) }
  internal static func add(emitFrom: Unity_PolySpatial_Internals_PolySpatialParticleBirthLocation, _ fbb: inout FlatBufferBuilder) { fbb.add(element: emitFrom.rawValue, def: 0, at: VTOFFSET.emitFrom.p) }
  internal static func add(radius: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: radius, def: 0.0, at: VTOFFSET.radius.p) }
  internal static func add(radiusMode: Unity_PolySpatial_Internals_PolySpatialParticleMultiMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: radiusMode.rawValue, def: 0, at: VTOFFSET.radiusMode.p) }
  internal static func add(radiusSpeed: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: radiusSpeed, at: VTOFFSET.radiusSpeed.p) }
  internal static func add(radiusSpread: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: radiusSpread, def: 0.0, at: VTOFFSET.radiusSpread.p) }
  internal static func add(radiusThickness: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: radiusThickness, def: 0.0, at: VTOFFSET.radiusThickness.p) }
  internal static func add(donutRadius: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: donutRadius, def: 0.0, at: VTOFFSET.donutRadius.p) }
  internal static func add(boxThickness: UnityEngine_Vector3?, _ fbb: inout FlatBufferBuilder) { guard let boxThickness = boxThickness else { return }; fbb.create(struct: boxThickness, position: VTOFFSET.boxThickness.p) }
  internal static func add(angle: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: angle, def: 0.0, at: VTOFFSET.angle.p) }
  internal static func add(arc: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: arc, def: 0.0, at: VTOFFSET.arc.p) }
  internal static func add(arcMode: Unity_PolySpatial_Internals_PolySpatialParticleMultiMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: arcMode.rawValue, def: 0, at: VTOFFSET.arcMode.p) }
  internal static func add(arcSpeed: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: arcSpeed, at: VTOFFSET.arcSpeed.p) }
  internal static func add(arcSpread: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: arcSpread, def: 0.0, at: VTOFFSET.arcSpread.p) }
  internal static func add(length: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: length, def: 0.0, at: VTOFFSET.length.p) }
  internal static func add(shapePosition: UnityEngine_Vector3?, _ fbb: inout FlatBufferBuilder) { guard let shapePosition = shapePosition else { return }; fbb.create(struct: shapePosition, position: VTOFFSET.shapePosition.p) }
  internal static func add(shapeRotation: UnityEngine_Quaternion?, _ fbb: inout FlatBufferBuilder) { guard let shapeRotation = shapeRotation else { return }; fbb.create(struct: shapeRotation, position: VTOFFSET.shapeRotation.p) }
  internal static func add(shapeScale: UnityEngine_Vector3?, _ fbb: inout FlatBufferBuilder) { guard let shapeScale = shapeScale else { return }; fbb.create(struct: shapeScale, position: VTOFFSET.shapeScale.p) }
  internal static func endPolySpatialParticleEmitterShape(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialParticleEmitterShape(
    _ fbb: inout FlatBufferBuilder,
    shape: Unity_PolySpatial_Internals_PolySpatialParticleEmitterGeometry = .sphere,
    shapeMeshId: Unity_PolySpatial_Internals_PolySpatialAssetID? = nil,
    emitFrom: Unity_PolySpatial_Internals_PolySpatialParticleBirthLocation = .edge,
    radius: Float32 = 0.0,
    radiusMode: Unity_PolySpatial_Internals_PolySpatialParticleMultiMode = .random,
    radiusSpeedOffset radiusSpeed: Offset = Offset(),
    radiusSpread: Float32 = 0.0,
    radiusThickness: Float32 = 0.0,
    donutRadius: Float32 = 0.0,
    boxThickness: UnityEngine_Vector3? = nil,
    angle: Float32 = 0.0,
    arc: Float32 = 0.0,
    arcMode: Unity_PolySpatial_Internals_PolySpatialParticleMultiMode = .random,
    arcSpeedOffset arcSpeed: Offset = Offset(),
    arcSpread: Float32 = 0.0,
    length: Float32 = 0.0,
    shapePosition: UnityEngine_Vector3? = nil,
    shapeRotation: UnityEngine_Quaternion? = nil,
    shapeScale: UnityEngine_Vector3? = nil
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.startPolySpatialParticleEmitterShape(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(shape: shape, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(shapeMeshId: shapeMeshId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(emitFrom: emitFrom, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(radius: radius, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(radiusMode: radiusMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(radiusSpeed: radiusSpeed, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(radiusSpread: radiusSpread, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(radiusThickness: radiusThickness, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(donutRadius: donutRadius, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(boxThickness: boxThickness, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(angle: angle, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(arc: arc, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(arcMode: arcMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(arcSpeed: arcSpeed, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(arcSpread: arcSpread, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(length: length, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(shapePosition: shapePosition, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(shapeRotation: shapeRotation, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.add(shapeScale: shapeScale, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape.endPolySpatialParticleEmitterShape(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.shape.p, fieldName: "shape", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleEmitterGeometry.self)
    try _v.visit(field: VTOFFSET.shapeMeshId.p, fieldName: "shapeMeshId", required: false, type: Unity_PolySpatial_Internals_PolySpatialAssetID.self)
    try _v.visit(field: VTOFFSET.emitFrom.p, fieldName: "emitFrom", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleBirthLocation.self)
    try _v.visit(field: VTOFFSET.radius.p, fieldName: "radius", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.radiusMode.p, fieldName: "radiusMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleMultiMode.self)
    try _v.visit(field: VTOFFSET.radiusSpeed.p, fieldName: "radiusSpeed", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    try _v.visit(field: VTOFFSET.radiusSpread.p, fieldName: "radiusSpread", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.radiusThickness.p, fieldName: "radiusThickness", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.donutRadius.p, fieldName: "donutRadius", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.boxThickness.p, fieldName: "boxThickness", required: false, type: UnityEngine_Vector3.self)
    try _v.visit(field: VTOFFSET.angle.p, fieldName: "angle", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.arc.p, fieldName: "arc", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.arcMode.p, fieldName: "arcMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleMultiMode.self)
    try _v.visit(field: VTOFFSET.arcSpeed.p, fieldName: "arcSpeed", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    try _v.visit(field: VTOFFSET.arcSpread.p, fieldName: "arcSpread", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.length.p, fieldName: "length", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.shapePosition.p, fieldName: "shapePosition", required: false, type: UnityEngine_Vector3.self)
    try _v.visit(field: VTOFFSET.shapeRotation.p, fieldName: "shapeRotation", required: false, type: UnityEngine_Quaternion.self)
    try _v.visit(field: VTOFFSET.shapeScale.p, fieldName: "shapeScale", required: false, type: UnityEngine_Vector3.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleVelocityOverLifetime: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case linearVelocity = 4
    case orbitalVelocity = 6
    case offsetVelocity = 8
    case radial = 10
    case space = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var linearVelocity: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3! { let o = _accessor.offset(VTOFFSET.linearVelocity.v); return Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var orbitalVelocity: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3! { let o = _accessor.offset(VTOFFSET.orbitalVelocity.v); return Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var offsetVelocity: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3! { let o = _accessor.offset(VTOFFSET.offsetVelocity.v); return Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var radial: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve? { let o = _accessor.offset(VTOFFSET.radial.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var space: Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace { let o = _accessor.offset(VTOFFSET.space.v); return o == 0 ? .local : Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .local }
  internal static func startPolySpatialParticleVelocityOverLifetime(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  internal static func add(linearVelocity: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: linearVelocity, at: VTOFFSET.linearVelocity.p) }
  internal static func add(orbitalVelocity: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: orbitalVelocity, at: VTOFFSET.orbitalVelocity.p) }
  internal static func add(offsetVelocity: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: offsetVelocity, at: VTOFFSET.offsetVelocity.p) }
  internal static func add(radial: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: radial, at: VTOFFSET.radial.p) }
  internal static func add(space: Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace, _ fbb: inout FlatBufferBuilder) { fbb.add(element: space.rawValue, def: 0, at: VTOFFSET.space.p) }
  internal static func endPolySpatialParticleVelocityOverLifetime(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6, 8]); return end }
  internal static func createPolySpatialParticleVelocityOverLifetime(
    _ fbb: inout FlatBufferBuilder,
    linearVelocityOffset linearVelocity: Offset,
    orbitalVelocityOffset orbitalVelocity: Offset,
    offsetVelocityOffset offsetVelocity: Offset,
    radialOffset radial: Offset = Offset(),
    space: Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace = .local
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleVelocityOverLifetime.startPolySpatialParticleVelocityOverLifetime(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleVelocityOverLifetime.add(linearVelocity: linearVelocity, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleVelocityOverLifetime.add(orbitalVelocity: orbitalVelocity, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleVelocityOverLifetime.add(offsetVelocity: offsetVelocity, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleVelocityOverLifetime.add(radial: radial, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleVelocityOverLifetime.add(space: space, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleVelocityOverLifetime.endPolySpatialParticleVelocityOverLifetime(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.linearVelocity.p, fieldName: "linearVelocity", required: true, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3>.self)
    try _v.visit(field: VTOFFSET.orbitalVelocity.p, fieldName: "orbitalVelocity", required: true, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3>.self)
    try _v.visit(field: VTOFFSET.offsetVelocity.p, fieldName: "offsetVelocity", required: true, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3>.self)
    try _v.visit(field: VTOFFSET.radial.p, fieldName: "radial", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    try _v.visit(field: VTOFFSET.space.p, fieldName: "space", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleLimitVelocityOverLifetime: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case separateAxes = 4
    case speed = 6
    case space = 8
    case dampen = 10
    case drag = 12
    case dragBasedOnVelocity = 14
    case dragBasedOnSize = 16
    case pad0 = 18
    case pad1 = 20
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var separateAxes: Bool { let o = _accessor.offset(VTOFFSET.separateAxes.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var speed: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3? { let o = _accessor.offset(VTOFFSET.speed.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var space: Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace { let o = _accessor.offset(VTOFFSET.space.v); return o == 0 ? .local : Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .local }
  internal var dampen: Float32 { let o = _accessor.offset(VTOFFSET.dampen.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var drag: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve? { let o = _accessor.offset(VTOFFSET.drag.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var dragBasedOnVelocity: Bool { let o = _accessor.offset(VTOFFSET.dragBasedOnVelocity.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var dragBasedOnSize: Bool { let o = _accessor.offset(VTOFFSET.dragBasedOnSize.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var pad0: Bool { let o = _accessor.offset(VTOFFSET.pad0.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var pad1: Bool { let o = _accessor.offset(VTOFFSET.pad1.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal static func startPolySpatialParticleLimitVelocityOverLifetime(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 9) }
  internal static func add(separateAxes: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: separateAxes, def: false,
   at: VTOFFSET.separateAxes.p) }
  internal static func add(speed: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: speed, at: VTOFFSET.speed.p) }
  internal static func add(space: Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace, _ fbb: inout FlatBufferBuilder) { fbb.add(element: space.rawValue, def: 0, at: VTOFFSET.space.p) }
  internal static func add(dampen: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dampen, def: 0.0, at: VTOFFSET.dampen.p) }
  internal static func add(drag: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: drag, at: VTOFFSET.drag.p) }
  internal static func add(dragBasedOnVelocity: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dragBasedOnVelocity, def: false,
   at: VTOFFSET.dragBasedOnVelocity.p) }
  internal static func add(dragBasedOnSize: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dragBasedOnSize, def: false,
   at: VTOFFSET.dragBasedOnSize.p) }
  internal static func add(pad0: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: pad0, def: false,
   at: VTOFFSET.pad0.p) }
  internal static func add(pad1: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: pad1, def: false,
   at: VTOFFSET.pad1.p) }
  internal static func endPolySpatialParticleLimitVelocityOverLifetime(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialParticleLimitVelocityOverLifetime(
    _ fbb: inout FlatBufferBuilder,
    separateAxes: Bool = false,
    speedOffset speed: Offset = Offset(),
    space: Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace = .local,
    dampen: Float32 = 0.0,
    dragOffset drag: Offset = Offset(),
    dragBasedOnVelocity: Bool = false,
    dragBasedOnSize: Bool = false,
    pad0: Bool = false,
    pad1: Bool = false
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleLimitVelocityOverLifetime.startPolySpatialParticleLimitVelocityOverLifetime(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleLimitVelocityOverLifetime.add(separateAxes: separateAxes, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleLimitVelocityOverLifetime.add(speed: speed, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleLimitVelocityOverLifetime.add(space: space, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleLimitVelocityOverLifetime.add(dampen: dampen, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleLimitVelocityOverLifetime.add(drag: drag, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleLimitVelocityOverLifetime.add(dragBasedOnVelocity: dragBasedOnVelocity, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleLimitVelocityOverLifetime.add(dragBasedOnSize: dragBasedOnSize, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleLimitVelocityOverLifetime.add(pad0: pad0, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleLimitVelocityOverLifetime.add(pad1: pad1, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleLimitVelocityOverLifetime.endPolySpatialParticleLimitVelocityOverLifetime(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.separateAxes.p, fieldName: "separateAxes", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.speed.p, fieldName: "speed", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3>.self)
    try _v.visit(field: VTOFFSET.space.p, fieldName: "space", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleSimulationSpace.self)
    try _v.visit(field: VTOFFSET.dampen.p, fieldName: "dampen", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.drag.p, fieldName: "drag", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    try _v.visit(field: VTOFFSET.dragBasedOnVelocity.p, fieldName: "dragBasedOnVelocity", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.dragBasedOnSize.p, fieldName: "dragBasedOnSize", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.pad0.p, fieldName: "pad0", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.pad1.p, fieldName: "pad1", required: false, type: Bool.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleInheritVelocity: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case curve = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var curve: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve! { let o = _accessor.offset(VTOFFSET.curve.v); return Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal static func startPolySpatialParticleInheritVelocity(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  internal static func add(curve: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: curve, at: VTOFFSET.curve.p) }
  internal static func endPolySpatialParticleInheritVelocity(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  internal static func createPolySpatialParticleInheritVelocity(
    _ fbb: inout FlatBufferBuilder,
    curveOffset curve: Offset
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleInheritVelocity.startPolySpatialParticleInheritVelocity(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleInheritVelocity.add(curve: curve, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleInheritVelocity.endPolySpatialParticleInheritVelocity(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.curve.p, fieldName: "curve", required: true, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleForceOverLifetime: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case force = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var force: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3! { let o = _accessor.offset(VTOFFSET.force.v); return Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal static func startPolySpatialParticleForceOverLifetime(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  internal static func add(force: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: force, at: VTOFFSET.force.p) }
  internal static func endPolySpatialParticleForceOverLifetime(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  internal static func createPolySpatialParticleForceOverLifetime(
    _ fbb: inout FlatBufferBuilder,
    forceOffset force: Offset
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleForceOverLifetime.startPolySpatialParticleForceOverLifetime(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleForceOverLifetime.add(force: force, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleForceOverLifetime.endPolySpatialParticleForceOverLifetime(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.force.p, fieldName: "force", required: true, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleColorOverLifetime: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case color = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var color: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxGradient? { let o = _accessor.offset(VTOFFSET.color.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMinMaxGradient(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal static func startPolySpatialParticleColorOverLifetime(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  internal static func add(color: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: color, at: VTOFFSET.color.p) }
  internal static func endPolySpatialParticleColorOverLifetime(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialParticleColorOverLifetime(
    _ fbb: inout FlatBufferBuilder,
    colorOffset color: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleColorOverLifetime.startPolySpatialParticleColorOverLifetime(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleColorOverLifetime.add(color: color, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleColorOverLifetime.endPolySpatialParticleColorOverLifetime(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.color.p, fieldName: "color", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxGradient>.self)
    _v.finish()
  }
}

///  SizeOverLifetime can have MinMaxCurves for each axes or can be a singular MinMaxCurve. If it is a singular MinMaxCurve, it will be stored in
///  the X field of the MinMaxCurveVector3.
internal struct Unity_PolySpatial_Internals_PolySpatialParticleSizeOverLifetime: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case separateAxes = 4
    case size = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var separateAxes: Bool { let o = _accessor.offset(VTOFFSET.separateAxes.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var size: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3! { let o = _accessor.offset(VTOFFSET.size.v); return Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal static func startPolySpatialParticleSizeOverLifetime(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  internal static func add(separateAxes: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: separateAxes, def: false,
   at: VTOFFSET.separateAxes.p) }
  internal static func add(size: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: size, at: VTOFFSET.size.p) }
  internal static func endPolySpatialParticleSizeOverLifetime(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [6]); return end }
  internal static func createPolySpatialParticleSizeOverLifetime(
    _ fbb: inout FlatBufferBuilder,
    separateAxes: Bool = false,
    sizeOffset size: Offset
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleSizeOverLifetime.startPolySpatialParticleSizeOverLifetime(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSizeOverLifetime.add(separateAxes: separateAxes, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSizeOverLifetime.add(size: size, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleSizeOverLifetime.endPolySpatialParticleSizeOverLifetime(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.separateAxes.p, fieldName: "separateAxes", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.size.p, fieldName: "size", required: true, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleRotationOverLifetime: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case separateAxes = 4
    case angularVelocity = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var separateAxes: Bool { let o = _accessor.offset(VTOFFSET.separateAxes.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var angularVelocity: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3! { let o = _accessor.offset(VTOFFSET.angularVelocity.v); return Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal static func startPolySpatialParticleRotationOverLifetime(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  internal static func add(separateAxes: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: separateAxes, def: false,
   at: VTOFFSET.separateAxes.p) }
  internal static func add(angularVelocity: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: angularVelocity, at: VTOFFSET.angularVelocity.p) }
  internal static func endPolySpatialParticleRotationOverLifetime(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [6]); return end }
  internal static func createPolySpatialParticleRotationOverLifetime(
    _ fbb: inout FlatBufferBuilder,
    separateAxes: Bool = false,
    angularVelocityOffset angularVelocity: Offset
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleRotationOverLifetime.startPolySpatialParticleRotationOverLifetime(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleRotationOverLifetime.add(separateAxes: separateAxes, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleRotationOverLifetime.add(angularVelocity: angularVelocity, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleRotationOverLifetime.endPolySpatialParticleRotationOverLifetime(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.separateAxes.p, fieldName: "separateAxes", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.angularVelocity.p, fieldName: "angularVelocity", required: true, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurveVector3>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleNoise: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case strength = 4
    case positionAmount = 6
    case scrollSpeed = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var strength: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve? { let o = _accessor.offset(VTOFFSET.strength.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var positionAmount: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve? { let o = _accessor.offset(VTOFFSET.positionAmount.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var scrollSpeed: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve? { let o = _accessor.offset(VTOFFSET.scrollSpeed.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal static func startPolySpatialParticleNoise(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  internal static func add(strength: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: strength, at: VTOFFSET.strength.p) }
  internal static func add(positionAmount: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: positionAmount, at: VTOFFSET.positionAmount.p) }
  internal static func add(scrollSpeed: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: scrollSpeed, at: VTOFFSET.scrollSpeed.p) }
  internal static func endPolySpatialParticleNoise(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialParticleNoise(
    _ fbb: inout FlatBufferBuilder,
    strengthOffset strength: Offset = Offset(),
    positionAmountOffset positionAmount: Offset = Offset(),
    scrollSpeedOffset scrollSpeed: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleNoise.startPolySpatialParticleNoise(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleNoise.add(strength: strength, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleNoise.add(positionAmount: positionAmount, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleNoise.add(scrollSpeed: scrollSpeed, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleNoise.endPolySpatialParticleNoise(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.strength.p, fieldName: "strength", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    try _v.visit(field: VTOFFSET.positionAmount.p, fieldName: "positionAmount", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    try _v.visit(field: VTOFFSET.scrollSpeed.p, fieldName: "scrollSpeed", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleCollision: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case type = 4
    case bounce = 6
    case dampen = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var type: Unity_PolySpatial_Internals_PolySpatialParticleCollisionType { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? .planes : Unity_PolySpatial_Internals_PolySpatialParticleCollisionType(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .planes }
  internal var bounce: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve? { let o = _accessor.offset(VTOFFSET.bounce.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var dampen: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve? { let o = _accessor.offset(VTOFFSET.dampen.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal static func startPolySpatialParticleCollision(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  internal static func add(type: Unity_PolySpatial_Internals_PolySpatialParticleCollisionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: type.rawValue, def: 0, at: VTOFFSET.type.p) }
  internal static func add(bounce: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: bounce, at: VTOFFSET.bounce.p) }
  internal static func add(dampen: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: dampen, at: VTOFFSET.dampen.p) }
  internal static func endPolySpatialParticleCollision(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialParticleCollision(
    _ fbb: inout FlatBufferBuilder,
    type: Unity_PolySpatial_Internals_PolySpatialParticleCollisionType = .planes,
    bounceOffset bounce: Offset = Offset(),
    dampenOffset dampen: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleCollision.startPolySpatialParticleCollision(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleCollision.add(type: type, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleCollision.add(bounce: bounce, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleCollision.add(dampen: dampen, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleCollision.endPolySpatialParticleCollision(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleCollisionType.self)
    try _v.visit(field: VTOFFSET.bounce.p, fieldName: "bounce", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    try _v.visit(field: VTOFFSET.dampen.p, fieldName: "dampen", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleTextureSheetAnimation: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case tilesX = 4
    case tilesY = 6
    case animation = 8
    case startFrame = 10
    case timeMode = 12
    case frameOverTime = 14
    case speedRangeMin = 16
    case speedRangeMax = 18
    case fps = 20
    case cycles = 22
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var tilesX: Int32 { let o = _accessor.offset(VTOFFSET.tilesX.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var tilesY: Int32 { let o = _accessor.offset(VTOFFSET.tilesY.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var animation: Unity_PolySpatial_Internals_PolySpatialParticleAnimationType { let o = _accessor.offset(VTOFFSET.animation.v); return o == 0 ? .wholeSheet : Unity_PolySpatial_Internals_PolySpatialParticleAnimationType(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .wholeSheet }
  internal var startFrame: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve? { let o = _accessor.offset(VTOFFSET.startFrame.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var timeMode: Unity_PolySpatial_Internals_PolySpatialParticleTimeMode { let o = _accessor.offset(VTOFFSET.timeMode.v); return o == 0 ? .lifetime : Unity_PolySpatial_Internals_PolySpatialParticleTimeMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .lifetime }
  internal var frameOverTime: Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve? { let o = _accessor.offset(VTOFFSET.frameOverTime.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var speedRangeMin: Float32 { let o = _accessor.offset(VTOFFSET.speedRangeMin.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var speedRangeMax: Float32 { let o = _accessor.offset(VTOFFSET.speedRangeMax.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var fps: Float32 { let o = _accessor.offset(VTOFFSET.fps.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var cycles: Float32 { let o = _accessor.offset(VTOFFSET.cycles.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal static func startPolySpatialParticleTextureSheetAnimation(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 10) }
  internal static func add(tilesX: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tilesX, def: 0, at: VTOFFSET.tilesX.p) }
  internal static func add(tilesY: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tilesY, def: 0, at: VTOFFSET.tilesY.p) }
  internal static func add(animation: Unity_PolySpatial_Internals_PolySpatialParticleAnimationType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: animation.rawValue, def: 0, at: VTOFFSET.animation.p) }
  internal static func add(startFrame: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: startFrame, at: VTOFFSET.startFrame.p) }
  internal static func add(timeMode: Unity_PolySpatial_Internals_PolySpatialParticleTimeMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: timeMode.rawValue, def: 0, at: VTOFFSET.timeMode.p) }
  internal static func add(frameOverTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: frameOverTime, at: VTOFFSET.frameOverTime.p) }
  internal static func add(speedRangeMin: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: speedRangeMin, def: 0.0, at: VTOFFSET.speedRangeMin.p) }
  internal static func add(speedRangeMax: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: speedRangeMax, def: 0.0, at: VTOFFSET.speedRangeMax.p) }
  internal static func add(fps: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fps, def: 0.0, at: VTOFFSET.fps.p) }
  internal static func add(cycles: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: cycles, def: 0.0, at: VTOFFSET.cycles.p) }
  internal static func endPolySpatialParticleTextureSheetAnimation(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialParticleTextureSheetAnimation(
    _ fbb: inout FlatBufferBuilder,
    tilesX: Int32 = 0,
    tilesY: Int32 = 0,
    animation: Unity_PolySpatial_Internals_PolySpatialParticleAnimationType = .wholeSheet,
    startFrameOffset startFrame: Offset = Offset(),
    timeMode: Unity_PolySpatial_Internals_PolySpatialParticleTimeMode = .lifetime,
    frameOverTimeOffset frameOverTime: Offset = Offset(),
    speedRangeMin: Float32 = 0.0,
    speedRangeMax: Float32 = 0.0,
    fps: Float32 = 0.0,
    cycles: Float32 = 0.0
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleTextureSheetAnimation.startPolySpatialParticleTextureSheetAnimation(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleTextureSheetAnimation.add(tilesX: tilesX, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleTextureSheetAnimation.add(tilesY: tilesY, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleTextureSheetAnimation.add(animation: animation, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleTextureSheetAnimation.add(startFrame: startFrame, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleTextureSheetAnimation.add(timeMode: timeMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleTextureSheetAnimation.add(frameOverTime: frameOverTime, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleTextureSheetAnimation.add(speedRangeMin: speedRangeMin, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleTextureSheetAnimation.add(speedRangeMax: speedRangeMax, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleTextureSheetAnimation.add(fps: fps, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleTextureSheetAnimation.add(cycles: cycles, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleTextureSheetAnimation.endPolySpatialParticleTextureSheetAnimation(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.tilesX.p, fieldName: "tilesX", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.tilesY.p, fieldName: "tilesY", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.animation.p, fieldName: "animation", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleAnimationType.self)
    try _v.visit(field: VTOFFSET.startFrame.p, fieldName: "startFrame", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    try _v.visit(field: VTOFFSET.timeMode.p, fieldName: "timeMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleTimeMode.self)
    try _v.visit(field: VTOFFSET.frameOverTime.p, fieldName: "frameOverTime", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMinMaxCurve>.self)
    try _v.visit(field: VTOFFSET.speedRangeMin.p, fieldName: "speedRangeMin", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.speedRangeMax.p, fieldName: "speedRangeMax", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.fps.p, fieldName: "fps", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.cycles.p, fieldName: "cycles", required: false, type: Float32.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleRendererProperties: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case sortMode = 4
    case renderMode = 6
    case lengthScale = 8
    case velocityScale = 10
    case renderingLayerMask = 12
    case shadowCastingMode = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var sortMode: Unity_PolySpatial_Internals_PolySpatialParticleSortMode { let o = _accessor.offset(VTOFFSET.sortMode.v); return o == 0 ? .none_ : Unity_PolySpatial_Internals_PolySpatialParticleSortMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .none_ }
  internal var renderMode: Unity_PolySpatial_Internals_PolySpatialParticleRenderMode { let o = _accessor.offset(VTOFFSET.renderMode.v); return o == 0 ? .billboard : Unity_PolySpatial_Internals_PolySpatialParticleRenderMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .billboard }
  internal var lengthScale: Float32 { let o = _accessor.offset(VTOFFSET.lengthScale.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var velocityScale: Float32 { let o = _accessor.offset(VTOFFSET.velocityScale.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var renderingLayerMask: UInt32 { let o = _accessor.offset(VTOFFSET.renderingLayerMask.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  ///  The manner in which the entity casts shadows (or doesn't, as the case may be).
  internal var shadowCastingMode: Unity_PolySpatial_Internals_PolySpatialShadowCastingMode { let o = _accessor.offset(VTOFFSET.shadowCastingMode.v); return o == 0 ? .off : Unity_PolySpatial_Internals_PolySpatialShadowCastingMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .off }
  internal static func startPolySpatialParticleRendererProperties(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  internal static func add(sortMode: Unity_PolySpatial_Internals_PolySpatialParticleSortMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sortMode.rawValue, def: 0, at: VTOFFSET.sortMode.p) }
  internal static func add(renderMode: Unity_PolySpatial_Internals_PolySpatialParticleRenderMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: renderMode.rawValue, def: 0, at: VTOFFSET.renderMode.p) }
  internal static func add(lengthScale: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lengthScale, def: 0.0, at: VTOFFSET.lengthScale.p) }
  internal static func add(velocityScale: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: velocityScale, def: 0.0, at: VTOFFSET.velocityScale.p) }
  internal static func add(renderingLayerMask: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: renderingLayerMask, def: 0, at: VTOFFSET.renderingLayerMask.p) }
  internal static func add(shadowCastingMode: Unity_PolySpatial_Internals_PolySpatialShadowCastingMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: shadowCastingMode.rawValue, def: 0, at: VTOFFSET.shadowCastingMode.p) }
  internal static func endPolySpatialParticleRendererProperties(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialParticleRendererProperties(
    _ fbb: inout FlatBufferBuilder,
    sortMode: Unity_PolySpatial_Internals_PolySpatialParticleSortMode = .none_,
    renderMode: Unity_PolySpatial_Internals_PolySpatialParticleRenderMode = .billboard,
    lengthScale: Float32 = 0.0,
    velocityScale: Float32 = 0.0,
    renderingLayerMask: UInt32 = 0,
    shadowCastingMode: Unity_PolySpatial_Internals_PolySpatialShadowCastingMode = .off
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleRendererProperties.startPolySpatialParticleRendererProperties(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleRendererProperties.add(sortMode: sortMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleRendererProperties.add(renderMode: renderMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleRendererProperties.add(lengthScale: lengthScale, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleRendererProperties.add(velocityScale: velocityScale, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleRendererProperties.add(renderingLayerMask: renderingLayerMask, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleRendererProperties.add(shadowCastingMode: shadowCastingMode, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleRendererProperties.endPolySpatialParticleRendererProperties(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.sortMode.p, fieldName: "sortMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleSortMode.self)
    try _v.visit(field: VTOFFSET.renderMode.p, fieldName: "renderMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticleRenderMode.self)
    try _v.visit(field: VTOFFSET.lengthScale.p, fieldName: "lengthScale", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.velocityScale.p, fieldName: "velocityScale", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.renderingLayerMask.p, fieldName: "renderingLayerMask", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.shadowCastingMode.p, fieldName: "shadowCastingMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialShadowCastingMode.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialParticleSystemData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case particleVertexCount = 4
    case approximateUpperBoundExtent = 6
    case trailVertexCount = 8
    case particleReplicationMode = 10
    case playState = 12
    case main = 14
    case renderData = 16
    case trailRenderData = 18
    case emission = 20
    case emitterShape = 22
    case velocityOverLifetime = 24
    case limitVelocityOverLifetime = 26
    case inheritVelocity = 28
    case forceOverLifetime = 30
    case colorOverLifetime = 32
    case sizeOverLifetime = 34
    case rotationOverLifetime = 36
    case noise = 38
    case collision = 40
    case subEmitters = 42
    case textureSheetAnimation = 44
    case lightsIsEnabled = 46
    case rendererProperties = 48
    case curveKeyBuffer = 50
    case gradientColorKeyBuffer = 52
    case gradientAlphaKeyBuffer = 54
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var particleVertexCount: Int32 { let o = _accessor.offset(VTOFFSET.particleVertexCount.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var approximateUpperBoundExtent: UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.approximateUpperBoundExtent.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector3.self, at: o) }
  internal var mutableApproximateUpperBoundExtent: UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.approximateUpperBoundExtent.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var trailVertexCount: Int32 { let o = _accessor.offset(VTOFFSET.trailVertexCount.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var particleReplicationMode: Unity_PolySpatial_Internals_ParticleReplicationMode { let o = _accessor.offset(VTOFFSET.particleReplicationMode.v); return o == 0 ? .replicateProperties : Unity_PolySpatial_Internals_ParticleReplicationMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .replicateProperties }
  internal var playState: Unity_PolySpatial_Internals_PolySpatialParticlePlayState { let o = _accessor.offset(VTOFFSET.playState.v); return o == 0 ? .playing : Unity_PolySpatial_Internals_PolySpatialParticlePlayState(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .playing }
  internal var main: Unity_PolySpatial_Internals_PolySpatialParticleMain? { let o = _accessor.offset(VTOFFSET.main.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleMain(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var renderData: Unity_PolySpatial_Internals_PolySpatialRenderData? { let o = _accessor.offset(VTOFFSET.renderData.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialRenderData(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var trailRenderData: Unity_PolySpatial_Internals_PolySpatialRenderData? { let o = _accessor.offset(VTOFFSET.trailRenderData.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialRenderData(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var emission: Unity_PolySpatial_Internals_PolySpatialParticleEmission? { let o = _accessor.offset(VTOFFSET.emission.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleEmission(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var emitterShape: Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape? { let o = _accessor.offset(VTOFFSET.emitterShape.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var velocityOverLifetime: Unity_PolySpatial_Internals_PolySpatialParticleVelocityOverLifetime? { let o = _accessor.offset(VTOFFSET.velocityOverLifetime.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleVelocityOverLifetime(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var limitVelocityOverLifetime: Unity_PolySpatial_Internals_PolySpatialParticleLimitVelocityOverLifetime? { let o = _accessor.offset(VTOFFSET.limitVelocityOverLifetime.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleLimitVelocityOverLifetime(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var inheritVelocity: Unity_PolySpatial_Internals_PolySpatialParticleInheritVelocity? { let o = _accessor.offset(VTOFFSET.inheritVelocity.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleInheritVelocity(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var forceOverLifetime: Unity_PolySpatial_Internals_PolySpatialParticleForceOverLifetime? { let o = _accessor.offset(VTOFFSET.forceOverLifetime.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleForceOverLifetime(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var colorOverLifetime: Unity_PolySpatial_Internals_PolySpatialParticleColorOverLifetime? { let o = _accessor.offset(VTOFFSET.colorOverLifetime.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleColorOverLifetime(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var sizeOverLifetime: Unity_PolySpatial_Internals_PolySpatialParticleSizeOverLifetime? { let o = _accessor.offset(VTOFFSET.sizeOverLifetime.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleSizeOverLifetime(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var rotationOverLifetime: Unity_PolySpatial_Internals_PolySpatialParticleRotationOverLifetime? { let o = _accessor.offset(VTOFFSET.rotationOverLifetime.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleRotationOverLifetime(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var noise: Unity_PolySpatial_Internals_PolySpatialParticleNoise? { let o = _accessor.offset(VTOFFSET.noise.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleNoise(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var collision: Unity_PolySpatial_Internals_PolySpatialParticleCollision? { let o = _accessor.offset(VTOFFSET.collision.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleCollision(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var hasSubEmitters: Bool { let o = _accessor.offset(VTOFFSET.subEmitters.v); return o == 0 ? false : true }
  internal var subEmittersCount: Int32 { let o = _accessor.offset(VTOFFSET.subEmitters.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func subEmitters(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialParticleSubEmitter? { let o = _accessor.offset(VTOFFSET.subEmitters.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialParticleSubEmitter.self, offset: _accessor.vector(at: o) + index * 24) }
  internal var subEmittersAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialParticleSubEmitter>? { return _accessor.getBufferPointer(at: VTOFFSET.subEmitters.v) }
  internal func mutableSubEmitters(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialParticleSubEmitter_Mutable? { let o = _accessor.offset(VTOFFSET.subEmitters.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleSubEmitter_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 24) }
  internal var textureSheetAnimation: Unity_PolySpatial_Internals_PolySpatialParticleTextureSheetAnimation? { let o = _accessor.offset(VTOFFSET.textureSheetAnimation.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleTextureSheetAnimation(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var lightsIsEnabled: Bool { let o = _accessor.offset(VTOFFSET.lightsIsEnabled.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var rendererProperties: Unity_PolySpatial_Internals_PolySpatialParticleRendererProperties? { let o = _accessor.offset(VTOFFSET.rendererProperties.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleRendererProperties(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal var hasCurveKeyBuffer: Bool { let o = _accessor.offset(VTOFFSET.curveKeyBuffer.v); return o == 0 ? false : true }
  internal var curveKeyBufferCount: Int32 { let o = _accessor.offset(VTOFFSET.curveKeyBuffer.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func curveKeyBuffer(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialParticleCurveKey? { let o = _accessor.offset(VTOFFSET.curveKeyBuffer.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialParticleCurveKey.self, offset: _accessor.vector(at: o) + index * 28) }
  internal var curveKeyBufferAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialParticleCurveKey>? { return _accessor.getBufferPointer(at: VTOFFSET.curveKeyBuffer.v) }
  internal func mutableCurveKeyBuffer(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialParticleCurveKey_Mutable? { let o = _accessor.offset(VTOFFSET.curveKeyBuffer.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleCurveKey_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 28) }
  internal var hasGradientColorKeyBuffer: Bool { let o = _accessor.offset(VTOFFSET.gradientColorKeyBuffer.v); return o == 0 ? false : true }
  internal var gradientColorKeyBufferCount: Int32 { let o = _accessor.offset(VTOFFSET.gradientColorKeyBuffer.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func gradientColorKeyBuffer(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey? { let o = _accessor.offset(VTOFFSET.gradientColorKeyBuffer.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey.self, offset: _accessor.vector(at: o) + index * 8) }
  internal var gradientColorKeyBufferAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey>? { return _accessor.getBufferPointer(at: VTOFFSET.gradientColorKeyBuffer.v) }
  internal func mutableGradientColorKeyBuffer(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey_Mutable? { let o = _accessor.offset(VTOFFSET.gradientColorKeyBuffer.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 8) }
  internal var hasGradientAlphaKeyBuffer: Bool { let o = _accessor.offset(VTOFFSET.gradientAlphaKeyBuffer.v); return o == 0 ? false : true }
  internal var gradientAlphaKeyBufferCount: Int32 { let o = _accessor.offset(VTOFFSET.gradientAlphaKeyBuffer.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func gradientAlphaKeyBuffer(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey? { let o = _accessor.offset(VTOFFSET.gradientAlphaKeyBuffer.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey.self, offset: _accessor.vector(at: o) + index * 8) }
  internal var gradientAlphaKeyBufferAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey>? { return _accessor.getBufferPointer(at: VTOFFSET.gradientAlphaKeyBuffer.v) }
  internal func mutableGradientAlphaKeyBuffer(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey_Mutable? { let o = _accessor.offset(VTOFFSET.gradientAlphaKeyBuffer.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 8) }
  internal static func startPolySpatialParticleSystemData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 26) }
  internal static func add(particleVertexCount: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: particleVertexCount, def: 0, at: VTOFFSET.particleVertexCount.p) }
  internal static func add(approximateUpperBoundExtent: UnityEngine_Vector3?, _ fbb: inout FlatBufferBuilder) { guard let approximateUpperBoundExtent = approximateUpperBoundExtent else { return }; fbb.create(struct: approximateUpperBoundExtent, position: VTOFFSET.approximateUpperBoundExtent.p) }
  internal static func add(trailVertexCount: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: trailVertexCount, def: 0, at: VTOFFSET.trailVertexCount.p) }
  internal static func add(particleReplicationMode: Unity_PolySpatial_Internals_ParticleReplicationMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: particleReplicationMode.rawValue, def: 0, at: VTOFFSET.particleReplicationMode.p) }
  internal static func add(playState: Unity_PolySpatial_Internals_PolySpatialParticlePlayState, _ fbb: inout FlatBufferBuilder) { fbb.add(element: playState.rawValue, def: 0, at: VTOFFSET.playState.p) }
  internal static func add(main: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: main, at: VTOFFSET.main.p) }
  internal static func add(renderData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: renderData, at: VTOFFSET.renderData.p) }
  internal static func add(trailRenderData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: trailRenderData, at: VTOFFSET.trailRenderData.p) }
  internal static func add(emission: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: emission, at: VTOFFSET.emission.p) }
  internal static func add(emitterShape: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: emitterShape, at: VTOFFSET.emitterShape.p) }
  internal static func add(velocityOverLifetime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: velocityOverLifetime, at: VTOFFSET.velocityOverLifetime.p) }
  internal static func add(limitVelocityOverLifetime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: limitVelocityOverLifetime, at: VTOFFSET.limitVelocityOverLifetime.p) }
  internal static func add(inheritVelocity: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: inheritVelocity, at: VTOFFSET.inheritVelocity.p) }
  internal static func add(forceOverLifetime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: forceOverLifetime, at: VTOFFSET.forceOverLifetime.p) }
  internal static func add(colorOverLifetime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: colorOverLifetime, at: VTOFFSET.colorOverLifetime.p) }
  internal static func add(sizeOverLifetime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sizeOverLifetime, at: VTOFFSET.sizeOverLifetime.p) }
  internal static func add(rotationOverLifetime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rotationOverLifetime, at: VTOFFSET.rotationOverLifetime.p) }
  internal static func add(noise: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: noise, at: VTOFFSET.noise.p) }
  internal static func add(collision: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: collision, at: VTOFFSET.collision.p) }
  internal static func addVectorOf(subEmitters: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: subEmitters, at: VTOFFSET.subEmitters.p) }
  internal static func startVectorOfSubEmitters(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialParticleSubEmitter>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialParticleSubEmitter>.alignment)
  }
  internal static func add(textureSheetAnimation: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: textureSheetAnimation, at: VTOFFSET.textureSheetAnimation.p) }
  internal static func add(lightsIsEnabled: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lightsIsEnabled, def: false,
   at: VTOFFSET.lightsIsEnabled.p) }
  internal static func add(rendererProperties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rendererProperties, at: VTOFFSET.rendererProperties.p) }
  internal static func addVectorOf(curveKeyBuffer: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: curveKeyBuffer, at: VTOFFSET.curveKeyBuffer.p) }
  internal static func startVectorOfCurveKeyBuffer(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialParticleCurveKey>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialParticleCurveKey>.alignment)
  }
  internal static func addVectorOf(gradientColorKeyBuffer: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: gradientColorKeyBuffer, at: VTOFFSET.gradientColorKeyBuffer.p) }
  internal static func startVectorOfGradientColorKeyBuffer(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey>.alignment)
  }
  internal static func addVectorOf(gradientAlphaKeyBuffer: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: gradientAlphaKeyBuffer, at: VTOFFSET.gradientAlphaKeyBuffer.p) }
  internal static func startVectorOfGradientAlphaKeyBuffer(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey>.alignment)
  }
  internal static func endPolySpatialParticleSystemData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialParticleSystemData(
    _ fbb: inout FlatBufferBuilder,
    particleVertexCount: Int32 = 0,
    approximateUpperBoundExtent: UnityEngine_Vector3? = nil,
    trailVertexCount: Int32 = 0,
    particleReplicationMode: Unity_PolySpatial_Internals_ParticleReplicationMode = .replicateProperties,
    playState: Unity_PolySpatial_Internals_PolySpatialParticlePlayState = .playing,
    mainOffset main: Offset = Offset(),
    renderDataOffset renderData: Offset = Offset(),
    trailRenderDataOffset trailRenderData: Offset = Offset(),
    emissionOffset emission: Offset = Offset(),
    emitterShapeOffset emitterShape: Offset = Offset(),
    velocityOverLifetimeOffset velocityOverLifetime: Offset = Offset(),
    limitVelocityOverLifetimeOffset limitVelocityOverLifetime: Offset = Offset(),
    inheritVelocityOffset inheritVelocity: Offset = Offset(),
    forceOverLifetimeOffset forceOverLifetime: Offset = Offset(),
    colorOverLifetimeOffset colorOverLifetime: Offset = Offset(),
    sizeOverLifetimeOffset sizeOverLifetime: Offset = Offset(),
    rotationOverLifetimeOffset rotationOverLifetime: Offset = Offset(),
    noiseOffset noise: Offset = Offset(),
    collisionOffset collision: Offset = Offset(),
    subEmittersVectorOffset subEmitters: Offset = Offset(),
    textureSheetAnimationOffset textureSheetAnimation: Offset = Offset(),
    lightsIsEnabled: Bool = false,
    rendererPropertiesOffset rendererProperties: Offset = Offset(),
    curveKeyBufferVectorOffset curveKeyBuffer: Offset = Offset(),
    gradientColorKeyBufferVectorOffset gradientColorKeyBuffer: Offset = Offset(),
    gradientAlphaKeyBufferVectorOffset gradientAlphaKeyBuffer: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialParticleSystemData.startPolySpatialParticleSystemData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(particleVertexCount: particleVertexCount, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(approximateUpperBoundExtent: approximateUpperBoundExtent, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(trailVertexCount: trailVertexCount, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(particleReplicationMode: particleReplicationMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(playState: playState, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(main: main, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(renderData: renderData, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(trailRenderData: trailRenderData, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(emission: emission, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(emitterShape: emitterShape, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(velocityOverLifetime: velocityOverLifetime, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(limitVelocityOverLifetime: limitVelocityOverLifetime, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(inheritVelocity: inheritVelocity, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(forceOverLifetime: forceOverLifetime, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(colorOverLifetime: colorOverLifetime, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(sizeOverLifetime: sizeOverLifetime, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(rotationOverLifetime: rotationOverLifetime, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(noise: noise, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(collision: collision, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.addVectorOf(subEmitters: subEmitters, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(textureSheetAnimation: textureSheetAnimation, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(lightsIsEnabled: lightsIsEnabled, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.add(rendererProperties: rendererProperties, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.addVectorOf(curveKeyBuffer: curveKeyBuffer, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.addVectorOf(gradientColorKeyBuffer: gradientColorKeyBuffer, &fbb)
    Unity_PolySpatial_Internals_PolySpatialParticleSystemData.addVectorOf(gradientAlphaKeyBuffer: gradientAlphaKeyBuffer, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialParticleSystemData.endPolySpatialParticleSystemData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.particleVertexCount.p, fieldName: "particleVertexCount", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.approximateUpperBoundExtent.p, fieldName: "approximateUpperBoundExtent", required: false, type: UnityEngine_Vector3.self)
    try _v.visit(field: VTOFFSET.trailVertexCount.p, fieldName: "trailVertexCount", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.particleReplicationMode.p, fieldName: "particleReplicationMode", required: false, type: Unity_PolySpatial_Internals_ParticleReplicationMode.self)
    try _v.visit(field: VTOFFSET.playState.p, fieldName: "playState", required: false, type: Unity_PolySpatial_Internals_PolySpatialParticlePlayState.self)
    try _v.visit(field: VTOFFSET.main.p, fieldName: "main", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleMain>.self)
    try _v.visit(field: VTOFFSET.renderData.p, fieldName: "renderData", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialRenderData>.self)
    try _v.visit(field: VTOFFSET.trailRenderData.p, fieldName: "trailRenderData", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialRenderData>.self)
    try _v.visit(field: VTOFFSET.emission.p, fieldName: "emission", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleEmission>.self)
    try _v.visit(field: VTOFFSET.emitterShape.p, fieldName: "emitterShape", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleEmitterShape>.self)
    try _v.visit(field: VTOFFSET.velocityOverLifetime.p, fieldName: "velocityOverLifetime", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleVelocityOverLifetime>.self)
    try _v.visit(field: VTOFFSET.limitVelocityOverLifetime.p, fieldName: "limitVelocityOverLifetime", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleLimitVelocityOverLifetime>.self)
    try _v.visit(field: VTOFFSET.inheritVelocity.p, fieldName: "inheritVelocity", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleInheritVelocity>.self)
    try _v.visit(field: VTOFFSET.forceOverLifetime.p, fieldName: "forceOverLifetime", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleForceOverLifetime>.self)
    try _v.visit(field: VTOFFSET.colorOverLifetime.p, fieldName: "colorOverLifetime", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleColorOverLifetime>.self)
    try _v.visit(field: VTOFFSET.sizeOverLifetime.p, fieldName: "sizeOverLifetime", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleSizeOverLifetime>.self)
    try _v.visit(field: VTOFFSET.rotationOverLifetime.p, fieldName: "rotationOverLifetime", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleRotationOverLifetime>.self)
    try _v.visit(field: VTOFFSET.noise.p, fieldName: "noise", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleNoise>.self)
    try _v.visit(field: VTOFFSET.collision.p, fieldName: "collision", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleCollision>.self)
    try _v.visit(field: VTOFFSET.subEmitters.p, fieldName: "subEmitters", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialParticleSubEmitter, Unity_PolySpatial_Internals_PolySpatialParticleSubEmitter>>.self)
    try _v.visit(field: VTOFFSET.textureSheetAnimation.p, fieldName: "textureSheetAnimation", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleTextureSheetAnimation>.self)
    try _v.visit(field: VTOFFSET.lightsIsEnabled.p, fieldName: "lightsIsEnabled", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.rendererProperties.p, fieldName: "rendererProperties", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialParticleRendererProperties>.self)
    try _v.visit(field: VTOFFSET.curveKeyBuffer.p, fieldName: "curveKeyBuffer", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialParticleCurveKey, Unity_PolySpatial_Internals_PolySpatialParticleCurveKey>>.self)
    try _v.visit(field: VTOFFSET.gradientColorKeyBuffer.p, fieldName: "gradientColorKeyBuffer", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey, Unity_PolySpatial_Internals_PolySpatialParticleGradientColorKey>>.self)
    try _v.visit(field: VTOFFSET.gradientAlphaKeyBuffer.p, fieldName: "gradientAlphaKeyBuffer", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey, Unity_PolySpatial_Internals_PolySpatialParticleGradientAlphaKey>>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialVideoPlayerData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case playState = 4
    case source = 6
    case isLooping = 8
    case playOnAwake = 10
    case preroll = 12
    case isMuted = 14
    case volume = 16
    case meshRendererEntityId = 18
    case pathToVideo = 20
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var playState: Unity_PolySpatial_Internals_PolySpatialVideoPlayerState { let o = _accessor.offset(VTOFFSET.playState.v); return o == 0 ? .isPlaying : Unity_PolySpatial_Internals_PolySpatialVideoPlayerState(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .isPlaying }
  internal var source: Unity_PolySpatial_Internals_PolySpatialVideoSource { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? .videoClip : Unity_PolySpatial_Internals_PolySpatialVideoSource(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .videoClip }
  internal var isLooping: Bool { let o = _accessor.offset(VTOFFSET.isLooping.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var playOnAwake: Bool { let o = _accessor.offset(VTOFFSET.playOnAwake.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var preroll: Bool { let o = _accessor.offset(VTOFFSET.preroll.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var isMuted: Bool { let o = _accessor.offset(VTOFFSET.isMuted.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var volume: Float32 { let o = _accessor.offset(VTOFFSET.volume.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal var meshRendererEntityId: Unity_PolySpatial_Internals_PolySpatialInstanceID? { let o = _accessor.offset(VTOFFSET.meshRendererEntityId.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialInstanceID.self, at: o) }
  internal var mutableMeshRendererEntityId: Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable? { let o = _accessor.offset(VTOFFSET.meshRendererEntityId.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialInstanceID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var pathToVideo: String! { let o = _accessor.offset(VTOFFSET.pathToVideo.v); return _accessor.string(at: o) }
  internal var pathToVideoSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.pathToVideo.v) }
  internal static func startPolySpatialVideoPlayerData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 9) }
  internal static func add(playState: Unity_PolySpatial_Internals_PolySpatialVideoPlayerState, _ fbb: inout FlatBufferBuilder) { fbb.add(element: playState.rawValue, def: 0, at: VTOFFSET.playState.p) }
  internal static func add(source: Unity_PolySpatial_Internals_PolySpatialVideoSource, _ fbb: inout FlatBufferBuilder) { fbb.add(element: source.rawValue, def: 0, at: VTOFFSET.source.p) }
  internal static func add(isLooping: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isLooping, def: false,
   at: VTOFFSET.isLooping.p) }
  internal static func add(playOnAwake: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: playOnAwake, def: false,
   at: VTOFFSET.playOnAwake.p) }
  internal static func add(preroll: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: preroll, def: false,
   at: VTOFFSET.preroll.p) }
  internal static func add(isMuted: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isMuted, def: false,
   at: VTOFFSET.isMuted.p) }
  internal static func add(volume: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: volume, def: 0.0, at: VTOFFSET.volume.p) }
  internal static func add(meshRendererEntityId: Unity_PolySpatial_Internals_PolySpatialInstanceID?, _ fbb: inout FlatBufferBuilder) { guard let meshRendererEntityId = meshRendererEntityId else { return }; fbb.create(struct: meshRendererEntityId, position: VTOFFSET.meshRendererEntityId.p) }
  internal static func add(pathToVideo: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: pathToVideo, at: VTOFFSET.pathToVideo.p) }
  internal static func endPolySpatialVideoPlayerData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [20]); return end }
  internal static func createPolySpatialVideoPlayerData(
    _ fbb: inout FlatBufferBuilder,
    playState: Unity_PolySpatial_Internals_PolySpatialVideoPlayerState = .isPlaying,
    source: Unity_PolySpatial_Internals_PolySpatialVideoSource = .videoClip,
    isLooping: Bool = false,
    playOnAwake: Bool = false,
    preroll: Bool = false,
    isMuted: Bool = false,
    volume: Float32 = 0.0,
    meshRendererEntityId: Unity_PolySpatial_Internals_PolySpatialInstanceID? = nil,
    pathToVideoOffset pathToVideo: Offset
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialVideoPlayerData.startPolySpatialVideoPlayerData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialVideoPlayerData.add(playState: playState, &fbb)
    Unity_PolySpatial_Internals_PolySpatialVideoPlayerData.add(source: source, &fbb)
    Unity_PolySpatial_Internals_PolySpatialVideoPlayerData.add(isLooping: isLooping, &fbb)
    Unity_PolySpatial_Internals_PolySpatialVideoPlayerData.add(playOnAwake: playOnAwake, &fbb)
    Unity_PolySpatial_Internals_PolySpatialVideoPlayerData.add(preroll: preroll, &fbb)
    Unity_PolySpatial_Internals_PolySpatialVideoPlayerData.add(isMuted: isMuted, &fbb)
    Unity_PolySpatial_Internals_PolySpatialVideoPlayerData.add(volume: volume, &fbb)
    Unity_PolySpatial_Internals_PolySpatialVideoPlayerData.add(meshRendererEntityId: meshRendererEntityId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialVideoPlayerData.add(pathToVideo: pathToVideo, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialVideoPlayerData.endPolySpatialVideoPlayerData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.playState.p, fieldName: "playState", required: false, type: Unity_PolySpatial_Internals_PolySpatialVideoPlayerState.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: Unity_PolySpatial_Internals_PolySpatialVideoSource.self)
    try _v.visit(field: VTOFFSET.isLooping.p, fieldName: "isLooping", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.playOnAwake.p, fieldName: "playOnAwake", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.preroll.p, fieldName: "preroll", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.isMuted.p, fieldName: "isMuted", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.volume.p, fieldName: "volume", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.meshRendererEntityId.p, fieldName: "meshRendererEntityId", required: false, type: Unity_PolySpatial_Internals_PolySpatialInstanceID.self)
    try _v.visit(field: VTOFFSET.pathToVideo.p, fieldName: "pathToVideo", required: true, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  For storing ARPlane data
internal struct Unity_PolySpatial_Internals_PolySpatialARPlane: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case operation = 4
    case trackingId = 6
    case subsumming = 8
    case subsumedBy = 10
    case alignment = 12
    case arTrackingState = 14
    case arClassification = 16
    case center = 18
    case position = 20
    case rotation = 22
    case size = 24
    case vertices = 26
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Adding, updating, or removing an ARPlane
  internal var operation: Unity_PolySpatial_Internals_ARPlaneOperation { let o = _accessor.offset(VTOFFSET.operation.v); return o == 0 ? .created : Unity_PolySpatial_Internals_ARPlaneOperation(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .created }
  ///  Current TrackableID assigned to this plane.
  internal var trackingId: Unity_PolySpatial_Internals_TrackableID? { let o = _accessor.offset(VTOFFSET.trackingId.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_TrackableID.self, at: o) }
  internal var mutableTrackingId: Unity_PolySpatial_Internals_TrackableID_Mutable? { let o = _accessor.offset(VTOFFSET.trackingId.v); return o == 0 ? nil : Unity_PolySpatial_Internals_TrackableID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Will subsumedBy eat trackingId?
  internal var subsumming: Bool { let o = _accessor.offset(VTOFFSET.subsumming.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  ///  If two planes merge, this will be the ARTrackableID of the plane that this plane "ate".
  internal var subsumedBy: Unity_PolySpatial_Internals_TrackableID? { let o = _accessor.offset(VTOFFSET.subsumedBy.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_TrackableID.self, at: o) }
  internal var mutableSubsumedBy: Unity_PolySpatial_Internals_TrackableID_Mutable? { let o = _accessor.offset(VTOFFSET.subsumedBy.v); return o == 0 ? nil : Unity_PolySpatial_Internals_TrackableID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Horizontal, vertical, etc..
  internal var alignment: Unity_PolySpatial_Internals_PlaneAlignment { let o = _accessor.offset(VTOFFSET.alignment.v); return o == 0 ? .none_ : Unity_PolySpatial_Internals_PlaneAlignment(rawValue: _accessor.readBuffer(of: UInt16.self, at: o)) ?? .none_ }
  ///  If the plane is not tracked, tracked, or limited (poor) tracking.
  internal var arTrackingState: Unity_PolySpatial_Internals_ARTrackingState { let o = _accessor.offset(VTOFFSET.arTrackingState.v); return o == 0 ? .none_ : Unity_PolySpatial_Internals_ARTrackingState(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  ///  Some platforms can supply context info about a plane, if it is a wall, floor, table, door, etc...
  internal var arClassification: UInt32 { let o = _accessor.offset(VTOFFSET.arClassification.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  ///  The center of the plane in plane space relative to it's Pose.
  internal var center: UnityEngine_Vector2? { let o = _accessor.offset(VTOFFSET.center.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector2.self, at: o) }
  internal var mutableCenter: UnityEngine_Vector2_Mutable? { let o = _accessor.offset(VTOFFSET.center.v); return o == 0 ? nil : UnityEngine_Vector2_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Position of its Pose.
  internal var position: UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.position.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector3.self, at: o) }
  internal var mutablePosition: UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.position.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Rotation of its Pose.
  internal var rotation: UnityEngine_Quaternion? { let o = _accessor.offset(VTOFFSET.rotation.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Quaternion.self, at: o) }
  internal var mutableRotation: UnityEngine_Quaternion_Mutable? { let o = _accessor.offset(VTOFFSET.rotation.v); return o == 0 ? nil : UnityEngine_Quaternion_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The size of the plane in meters.
  internal var size: UnityEngine_Vector2? { let o = _accessor.offset(VTOFFSET.size.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector2.self, at: o) }
  internal var mutableSize: UnityEngine_Vector2_Mutable? { let o = _accessor.offset(VTOFFSET.size.v); return o == 0 ? nil : UnityEngine_Vector2_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The boundary associated with the plane.
  internal var hasVertices: Bool { let o = _accessor.offset(VTOFFSET.vertices.v); return o == 0 ? false : true }
  internal var verticesCount: Int32 { let o = _accessor.offset(VTOFFSET.vertices.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func vertices(at index: Int32) -> UnityEngine_Vector2? { let o = _accessor.offset(VTOFFSET.vertices.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector2.self, offset: _accessor.vector(at: o) + index * 8) }
  internal var verticesAsBuffer: UnsafeBufferPointer<UnityEngine_Vector2>? { return _accessor.getBufferPointer(at: VTOFFSET.vertices.v) }
  internal func mutableVertices(at index: Int32) -> UnityEngine_Vector2_Mutable? { let o = _accessor.offset(VTOFFSET.vertices.v); return o == 0 ? nil : UnityEngine_Vector2_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 8) }
  internal static func startPolySpatialARPlane(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 12) }
  internal static func add(operation: Unity_PolySpatial_Internals_ARPlaneOperation, _ fbb: inout FlatBufferBuilder) { fbb.add(element: operation.rawValue, def: 0, at: VTOFFSET.operation.p) }
  internal static func add(trackingId: Unity_PolySpatial_Internals_TrackableID?, _ fbb: inout FlatBufferBuilder) { guard let trackingId = trackingId else { return }; fbb.create(struct: trackingId, position: VTOFFSET.trackingId.p) }
  internal static func add(subsumming: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: subsumming, def: false,
   at: VTOFFSET.subsumming.p) }
  internal static func add(subsumedBy: Unity_PolySpatial_Internals_TrackableID?, _ fbb: inout FlatBufferBuilder) { guard let subsumedBy = subsumedBy else { return }; fbb.create(struct: subsumedBy, position: VTOFFSET.subsumedBy.p) }
  internal static func add(alignment: Unity_PolySpatial_Internals_PlaneAlignment, _ fbb: inout FlatBufferBuilder) { fbb.add(element: alignment.rawValue, def: 0, at: VTOFFSET.alignment.p) }
  internal static func add(arTrackingState: Unity_PolySpatial_Internals_ARTrackingState, _ fbb: inout FlatBufferBuilder) { fbb.add(element: arTrackingState.rawValue, def: 0, at: VTOFFSET.arTrackingState.p) }
  internal static func add(arClassification: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: arClassification, def: 0, at: VTOFFSET.arClassification.p) }
  internal static func add(center: UnityEngine_Vector2?, _ fbb: inout FlatBufferBuilder) { guard let center = center else { return }; fbb.create(struct: center, position: VTOFFSET.center.p) }
  internal static func add(position: UnityEngine_Vector3?, _ fbb: inout FlatBufferBuilder) { guard let position = position else { return }; fbb.create(struct: position, position: VTOFFSET.position.p) }
  internal static func add(rotation: UnityEngine_Quaternion?, _ fbb: inout FlatBufferBuilder) { guard let rotation = rotation else { return }; fbb.create(struct: rotation, position: VTOFFSET.rotation.p) }
  internal static func add(size: UnityEngine_Vector2?, _ fbb: inout FlatBufferBuilder) { guard let size = size else { return }; fbb.create(struct: size, position: VTOFFSET.size.p) }
  internal static func addVectorOf(vertices: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vertices, at: VTOFFSET.vertices.p) }
  internal static func startVectorOfVertices(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector2>.size, elementSize: MemoryLayout<UnityEngine_Vector2>.alignment)
  }
  internal static func endPolySpatialARPlane(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialARPlane(
    _ fbb: inout FlatBufferBuilder,
    operation: Unity_PolySpatial_Internals_ARPlaneOperation = .created,
    trackingId: Unity_PolySpatial_Internals_TrackableID? = nil,
    subsumming: Bool = false,
    subsumedBy: Unity_PolySpatial_Internals_TrackableID? = nil,
    alignment: Unity_PolySpatial_Internals_PlaneAlignment = .none_,
    arTrackingState: Unity_PolySpatial_Internals_ARTrackingState = .none_,
    arClassification: UInt32 = 0,
    center: UnityEngine_Vector2? = nil,
    position: UnityEngine_Vector3? = nil,
    rotation: UnityEngine_Quaternion? = nil,
    size: UnityEngine_Vector2? = nil,
    verticesVectorOffset vertices: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialARPlane.startPolySpatialARPlane(&fbb)
    Unity_PolySpatial_Internals_PolySpatialARPlane.add(operation: operation, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARPlane.add(trackingId: trackingId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARPlane.add(subsumming: subsumming, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARPlane.add(subsumedBy: subsumedBy, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARPlane.add(alignment: alignment, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARPlane.add(arTrackingState: arTrackingState, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARPlane.add(arClassification: arClassification, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARPlane.add(center: center, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARPlane.add(position: position, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARPlane.add(rotation: rotation, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARPlane.add(size: size, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARPlane.addVectorOf(vertices: vertices, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialARPlane.endPolySpatialARPlane(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.operation.p, fieldName: "operation", required: false, type: Unity_PolySpatial_Internals_ARPlaneOperation.self)
    try _v.visit(field: VTOFFSET.trackingId.p, fieldName: "trackingId", required: false, type: Unity_PolySpatial_Internals_TrackableID.self)
    try _v.visit(field: VTOFFSET.subsumming.p, fieldName: "subsumming", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.subsumedBy.p, fieldName: "subsumedBy", required: false, type: Unity_PolySpatial_Internals_TrackableID.self)
    try _v.visit(field: VTOFFSET.alignment.p, fieldName: "alignment", required: false, type: Unity_PolySpatial_Internals_PlaneAlignment.self)
    try _v.visit(field: VTOFFSET.arTrackingState.p, fieldName: "arTrackingState", required: false, type: Unity_PolySpatial_Internals_ARTrackingState.self)
    try _v.visit(field: VTOFFSET.arClassification.p, fieldName: "arClassification", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.center.p, fieldName: "center", required: false, type: UnityEngine_Vector2.self)
    try _v.visit(field: VTOFFSET.position.p, fieldName: "position", required: false, type: UnityEngine_Vector3.self)
    try _v.visit(field: VTOFFSET.rotation.p, fieldName: "rotation", required: false, type: UnityEngine_Quaternion.self)
    try _v.visit(field: VTOFFSET.size.p, fieldName: "size", required: false, type: UnityEngine_Vector2.self)
    try _v.visit(field: VTOFFSET.vertices.p, fieldName: "vertices", required: false, type: ForwardOffset<Vector<UnityEngine_Vector2, UnityEngine_Vector2>>.self)
    _v.finish()
  }
}

///  To simplify transmission of PolySpatialARPlane's
internal struct Unity_PolySpatial_Internals_PolySpatialARPlaneArray: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case planes = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Collection of ARPlanes.
  internal var hasPlanes: Bool { let o = _accessor.offset(VTOFFSET.planes.v); return o == 0 ? false : true }
  internal var planesCount: Int32 { let o = _accessor.offset(VTOFFSET.planes.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func planes(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialARPlane? { let o = _accessor.offset(VTOFFSET.planes.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialARPlane(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  internal static func startPolySpatialARPlaneArray(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  internal static func addVectorOf(planes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: planes, at: VTOFFSET.planes.p) }
  internal static func endPolySpatialARPlaneArray(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialARPlaneArray(
    _ fbb: inout FlatBufferBuilder,
    planesVectorOffset planes: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialARPlaneArray.startPolySpatialARPlaneArray(&fbb)
    Unity_PolySpatial_Internals_PolySpatialARPlaneArray.addVectorOf(planes: planes, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialARPlaneArray.endPolySpatialARPlaneArray(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.planes.p, fieldName: "planes", required: false, type: ForwardOffset<Vector<ForwardOffset<Unity_PolySpatial_Internals_PolySpatialARPlane>, Unity_PolySpatial_Internals_PolySpatialARPlane>>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialJointData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case jointId = 4
    case pose = 6
    case radius = 8
    case linearVelocity = 10
    case angularVelocity = 12
    case trackingState = 14
    case visionOsrotation = 16
    case visionOstrackingState = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  <summary>
  ///  See UnityEngine.XR.Hands.XRHandJointID for supported values
  ///  </summary>
  internal var jointId: Int32 { let o = _accessor.offset(VTOFFSET.jointId.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  <summary>
  ///  Joint's position and rotation
  ///  </summary>
  internal var pose: UnityEngine_Pose? { let o = _accessor.offset(VTOFFSET.pose.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Pose.self, at: o) }
  internal var mutablePose: UnityEngine_Pose_Mutable? { let o = _accessor.offset(VTOFFSET.pose.v); return o == 0 ? nil : UnityEngine_Pose_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  <summary>
  ///  Joint's radius
  ///  </summary>
  internal var radius: Float32 { let o = _accessor.offset(VTOFFSET.radius.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  ///  <summary>
  ///  Joint's linear velocity
  ///  </summary>
  internal var linearVelocity: UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.linearVelocity.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector3.self, at: o) }
  internal var mutableLinearVelocity: UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.linearVelocity.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  <summary>
  ///  Joint's angular velocity
  ///  </summary>
  internal var angularVelocity: UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.angularVelocity.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector3.self, at: o) }
  internal var mutableAngularVelocity: UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.angularVelocity.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  <summary>
  ///  Joint's tracking state
  ///  </summary>
  internal var trackingState: Unity_PolySpatial_Internals_PolySpatialJointTrackingState { let o = _accessor.offset(VTOFFSET.trackingState.v); return o == 0 ? .none_ : Unity_PolySpatial_Internals_PolySpatialJointTrackingState(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  ///  <summary>
  ///  The rotation of the joint, if available, but without the Unity-defined change to the rotation to make the reported rotation cross-platform.
  ///  </summary>
  internal var visionOsrotation: UnityEngine_Quaternion? { let o = _accessor.offset(VTOFFSET.visionOsrotation.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Quaternion.self, at: o) }
  internal var mutableVisionOsrotation: UnityEngine_Quaternion_Mutable? { let o = _accessor.offset(VTOFFSET.visionOsrotation.v); return o == 0 ? nil : UnityEngine_Quaternion_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  <summary>
  ///  The tracking state of the joint, if available, reporting whether or not the joint is visible (distinct from
  ///  regular trackingState, which indicates that it has a valid pose).
  ///  </summary>
  internal var visionOstrackingState: Bool { let o = _accessor.offset(VTOFFSET.visionOstrackingState.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal static func startPolySpatialJointData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  internal static func add(jointId: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: jointId, def: 0, at: VTOFFSET.jointId.p) }
  internal static func add(pose: UnityEngine_Pose?, _ fbb: inout FlatBufferBuilder) { guard let pose = pose else { return }; fbb.create(struct: pose, position: VTOFFSET.pose.p) }
  internal static func add(radius: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: radius, def: 0.0, at: VTOFFSET.radius.p) }
  internal static func add(linearVelocity: UnityEngine_Vector3?, _ fbb: inout FlatBufferBuilder) { guard let linearVelocity = linearVelocity else { return }; fbb.create(struct: linearVelocity, position: VTOFFSET.linearVelocity.p) }
  internal static func add(angularVelocity: UnityEngine_Vector3?, _ fbb: inout FlatBufferBuilder) { guard let angularVelocity = angularVelocity else { return }; fbb.create(struct: angularVelocity, position: VTOFFSET.angularVelocity.p) }
  internal static func add(trackingState: Unity_PolySpatial_Internals_PolySpatialJointTrackingState, _ fbb: inout FlatBufferBuilder) { fbb.add(element: trackingState.rawValue, def: 0, at: VTOFFSET.trackingState.p) }
  internal static func add(visionOsrotation: UnityEngine_Quaternion?, _ fbb: inout FlatBufferBuilder) { guard let visionOsrotation = visionOsrotation else { return }; fbb.create(struct: visionOsrotation, position: VTOFFSET.visionOsrotation.p) }
  internal static func add(visionOstrackingState: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: visionOstrackingState, def: false,
   at: VTOFFSET.visionOstrackingState.p) }
  internal static func endPolySpatialJointData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialJointData(
    _ fbb: inout FlatBufferBuilder,
    jointId: Int32 = 0,
    pose: UnityEngine_Pose? = nil,
    radius: Float32 = 0.0,
    linearVelocity: UnityEngine_Vector3? = nil,
    angularVelocity: UnityEngine_Vector3? = nil,
    trackingState: Unity_PolySpatial_Internals_PolySpatialJointTrackingState = .none_,
    visionOsrotation: UnityEngine_Quaternion? = nil,
    visionOstrackingState: Bool = false
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialJointData.startPolySpatialJointData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialJointData.add(jointId: jointId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialJointData.add(pose: pose, &fbb)
    Unity_PolySpatial_Internals_PolySpatialJointData.add(radius: radius, &fbb)
    Unity_PolySpatial_Internals_PolySpatialJointData.add(linearVelocity: linearVelocity, &fbb)
    Unity_PolySpatial_Internals_PolySpatialJointData.add(angularVelocity: angularVelocity, &fbb)
    Unity_PolySpatial_Internals_PolySpatialJointData.add(trackingState: trackingState, &fbb)
    Unity_PolySpatial_Internals_PolySpatialJointData.add(visionOsrotation: visionOsrotation, &fbb)
    Unity_PolySpatial_Internals_PolySpatialJointData.add(visionOstrackingState: visionOstrackingState, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialJointData.endPolySpatialJointData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.jointId.p, fieldName: "jointId", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.pose.p, fieldName: "pose", required: false, type: UnityEngine_Pose.self)
    try _v.visit(field: VTOFFSET.radius.p, fieldName: "radius", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.linearVelocity.p, fieldName: "linearVelocity", required: false, type: UnityEngine_Vector3.self)
    try _v.visit(field: VTOFFSET.angularVelocity.p, fieldName: "angularVelocity", required: false, type: UnityEngine_Vector3.self)
    try _v.visit(field: VTOFFSET.trackingState.p, fieldName: "trackingState", required: false, type: Unity_PolySpatial_Internals_PolySpatialJointTrackingState.self)
    try _v.visit(field: VTOFFSET.visionOsrotation.p, fieldName: "visionOsrotation", required: false, type: UnityEngine_Quaternion.self)
    try _v.visit(field: VTOFFSET.visionOstrackingState.p, fieldName: "visionOstrackingState", required: false, type: Bool.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialXRHandData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case handId = 4
    case rootPose = 6
    case updatedPoses = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  <summary>
  ///  Left or Right hand
  ///  </summary>
  internal var handId: Unity_PolySpatial_Internals_PolySpatialHandID { let o = _accessor.offset(VTOFFSET.handId.v); return o == 0 ? .left_ : Unity_PolySpatial_Internals_PolySpatialHandID(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .left_ }
  ///  <summary>
  ///  Root position and rotation
  ///  </summary>
  internal var rootPose: UnityEngine_Pose! { let o = _accessor.offset(VTOFFSET.rootPose.v); return _accessor.readBuffer(of: UnityEngine_Pose.self, at: o) }
  internal var mutableRootPose: UnityEngine_Pose_Mutable! { let o = _accessor.offset(VTOFFSET.rootPose.v); return UnityEngine_Pose_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  <summary>
  ///  Updated joint poses
  ///  </summary>
  internal var hasUpdatedPoses: Bool { let o = _accessor.offset(VTOFFSET.updatedPoses.v); return o == 0 ? false : true }
  internal var updatedPosesCount: Int32 { let o = _accessor.offset(VTOFFSET.updatedPoses.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func updatedPoses(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialJointData? { let o = _accessor.offset(VTOFFSET.updatedPoses.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialJointData(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  internal static func startPolySpatialXRHandData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  internal static func add(handId: Unity_PolySpatial_Internals_PolySpatialHandID, _ fbb: inout FlatBufferBuilder) { fbb.add(element: handId.rawValue, def: 0, at: VTOFFSET.handId.p) }
  internal static func add(rootPose: UnityEngine_Pose?, _ fbb: inout FlatBufferBuilder) { guard let rootPose = rootPose else { return }; fbb.create(struct: rootPose, position: VTOFFSET.rootPose.p) }
  internal static func addVectorOf(updatedPoses: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedPoses, at: VTOFFSET.updatedPoses.p) }
  internal static func endPolySpatialXRHandData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [6]); return end }
  internal static func createPolySpatialXRHandData(
    _ fbb: inout FlatBufferBuilder,
    handId: Unity_PolySpatial_Internals_PolySpatialHandID = .left_,
    rootPose: UnityEngine_Pose,
    updatedPosesVectorOffset updatedPoses: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialXRHandData.startPolySpatialXRHandData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialXRHandData.add(handId: handId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRHandData.add(rootPose: rootPose, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRHandData.addVectorOf(updatedPoses: updatedPoses, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialXRHandData.endPolySpatialXRHandData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.handId.p, fieldName: "handId", required: false, type: Unity_PolySpatial_Internals_PolySpatialHandID.self)
    try _v.visit(field: VTOFFSET.rootPose.p, fieldName: "rootPose", required: true, type: UnityEngine_Pose.self)
    try _v.visit(field: VTOFFSET.updatedPoses.p, fieldName: "updatedPoses", required: false, type: ForwardOffset<Vector<ForwardOffset<Unity_PolySpatial_Internals_PolySpatialJointData>, Unity_PolySpatial_Internals_PolySpatialJointData>>.self)
    _v.finish()
  }
}

///  For storing ARMesh data
internal struct Unity_PolySpatial_Internals_PolySpatialXRMesh: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case changeState = 4
    case meshId = 6
    case position = 8
    case rotation = 10
    case scale = 12
    case numVertices = 14
    case vertices = 16
    case normals = 18
    case numTriangles = 20
    case shortIndices = 22
    case indices16 = 24
    case indices32 = 26
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Adding, updating, or removing an ARMesh
  internal var changeState: Unity_PolySpatial_Internals_PolySpatialMeshChangeState { let o = _accessor.offset(VTOFFSET.changeState.v); return o == 0 ? .added : Unity_PolySpatial_Internals_PolySpatialMeshChangeState(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .added }
  ///  trackable ID for a mesh
  internal var meshId: Unity_PolySpatial_Internals_TrackableID? { let o = _accessor.offset(VTOFFSET.meshId.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_TrackableID.self, at: o) }
  internal var mutableMeshId: Unity_PolySpatial_Internals_TrackableID_Mutable? { let o = _accessor.offset(VTOFFSET.meshId.v); return o == 0 ? nil : Unity_PolySpatial_Internals_TrackableID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Position of its Pose.
  internal var position: UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.position.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector3.self, at: o) }
  internal var mutablePosition: UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.position.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Rotation of its Pose.
  internal var rotation: UnityEngine_Quaternion? { let o = _accessor.offset(VTOFFSET.rotation.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Quaternion.self, at: o) }
  internal var mutableRotation: UnityEngine_Quaternion_Mutable? { let o = _accessor.offset(VTOFFSET.rotation.v); return o == 0 ? nil : UnityEngine_Quaternion_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The size of the mesh in meters.
  internal var scale: UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.scale.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector3.self, at: o) }
  internal var mutableScale: UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.scale.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: o + _accessor.postion) }
  internal var numVertices: Int32 { let o = _accessor.offset(VTOFFSET.numVertices.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Array of Vector3 values, one for each vertex in this mesh.
  internal var hasVertices: Bool { let o = _accessor.offset(VTOFFSET.vertices.v); return o == 0 ? false : true }
  internal var verticesCount: Int32 { let o = _accessor.offset(VTOFFSET.vertices.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func vertices(at index: Int32) -> UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.vertices.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector3.self, offset: _accessor.vector(at: o) + index * 12) }
  internal var verticesAsBuffer: UnsafeBufferPointer<UnityEngine_Vector3>? { return _accessor.getBufferPointer(at: VTOFFSET.vertices.v) }
  internal func mutableVertices(at index: Int32) -> UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.vertices.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 12) }
  ///  Array of Vector3 values, one for each vertex normal in this mesh.
  ///  If available, assumed to be the same length as vertices.
  internal var hasNormals: Bool { let o = _accessor.offset(VTOFFSET.normals.v); return o == 0 ? false : true }
  internal var normalsCount: Int32 { let o = _accessor.offset(VTOFFSET.normals.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func normals(at index: Int32) -> UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.normals.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector3.self, offset: _accessor.vector(at: o) + index * 12) }
  internal var normalsAsBuffer: UnsafeBufferPointer<UnityEngine_Vector3>? { return _accessor.getBufferPointer(at: VTOFFSET.normals.v) }
  internal func mutableNormals(at index: Int32) -> UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.normals.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 12) }
  internal var numTriangles: Int32 { let o = _accessor.offset(VTOFFSET.numTriangles.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  internal var shortIndices: Bool { let o = _accessor.offset(VTOFFSET.shortIndices.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  ///  The index buffer (with 16-bit indices)
  internal var hasIndices16: Bool { let o = _accessor.offset(VTOFFSET.indices16.v); return o == 0 ? false : true }
  internal var indices16Count: Int32 { let o = _accessor.offset(VTOFFSET.indices16.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func indices16(at index: Int32) -> UInt16 { let o = _accessor.offset(VTOFFSET.indices16.v); return o == 0 ? 0 : _accessor.directRead(of: UInt16.self, offset: _accessor.vector(at: o) + index * 2) }
  internal var indices16: [UInt16] { return _accessor.getVector(at: VTOFFSET.indices16.v) ?? [] }
  internal var indices16AsBuffer: UnsafeBufferPointer<UInt16>? { return _accessor.getBufferPointer(at: VTOFFSET.indices16.v) }
  ///  The index buffer (with 32-bit indices)
  internal var hasIndices32: Bool { let o = _accessor.offset(VTOFFSET.indices32.v); return o == 0 ? false : true }
  internal var indices32Count: Int32 { let o = _accessor.offset(VTOFFSET.indices32.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func indices32(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.indices32.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  internal var indices32: [Int32] { return _accessor.getVector(at: VTOFFSET.indices32.v) ?? [] }
  internal var indices32AsBuffer: UnsafeBufferPointer<Int32>? { return _accessor.getBufferPointer(at: VTOFFSET.indices32.v) }
  internal static func startPolySpatialXRMesh(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 12) }
  internal static func add(changeState: Unity_PolySpatial_Internals_PolySpatialMeshChangeState, _ fbb: inout FlatBufferBuilder) { fbb.add(element: changeState.rawValue, def: 0, at: VTOFFSET.changeState.p) }
  internal static func add(meshId: Unity_PolySpatial_Internals_TrackableID?, _ fbb: inout FlatBufferBuilder) { guard let meshId = meshId else { return }; fbb.create(struct: meshId, position: VTOFFSET.meshId.p) }
  internal static func add(position: UnityEngine_Vector3?, _ fbb: inout FlatBufferBuilder) { guard let position = position else { return }; fbb.create(struct: position, position: VTOFFSET.position.p) }
  internal static func add(rotation: UnityEngine_Quaternion?, _ fbb: inout FlatBufferBuilder) { guard let rotation = rotation else { return }; fbb.create(struct: rotation, position: VTOFFSET.rotation.p) }
  internal static func add(scale: UnityEngine_Vector3?, _ fbb: inout FlatBufferBuilder) { guard let scale = scale else { return }; fbb.create(struct: scale, position: VTOFFSET.scale.p) }
  internal static func add(numVertices: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numVertices, def: 0, at: VTOFFSET.numVertices.p) }
  internal static func addVectorOf(vertices: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vertices, at: VTOFFSET.vertices.p) }
  internal static func startVectorOfVertices(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector3>.size, elementSize: MemoryLayout<UnityEngine_Vector3>.alignment)
  }
  internal static func addVectorOf(normals: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: normals, at: VTOFFSET.normals.p) }
  internal static func startVectorOfNormals(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector3>.size, elementSize: MemoryLayout<UnityEngine_Vector3>.alignment)
  }
  internal static func add(numTriangles: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numTriangles, def: 0, at: VTOFFSET.numTriangles.p) }
  internal static func add(shortIndices: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: shortIndices, def: false,
   at: VTOFFSET.shortIndices.p) }
  internal static func addVectorOf(indices16: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: indices16, at: VTOFFSET.indices16.p) }
  internal static func addVectorOf(indices32: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: indices32, at: VTOFFSET.indices32.p) }
  internal static func endPolySpatialXRMesh(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialXRMesh(
    _ fbb: inout FlatBufferBuilder,
    changeState: Unity_PolySpatial_Internals_PolySpatialMeshChangeState = .added,
    meshId: Unity_PolySpatial_Internals_TrackableID? = nil,
    position: UnityEngine_Vector3? = nil,
    rotation: UnityEngine_Quaternion? = nil,
    scale: UnityEngine_Vector3? = nil,
    numVertices: Int32 = 0,
    verticesVectorOffset vertices: Offset = Offset(),
    normalsVectorOffset normals: Offset = Offset(),
    numTriangles: Int32 = 0,
    shortIndices: Bool = false,
    indices16VectorOffset indices16: Offset = Offset(),
    indices32VectorOffset indices32: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialXRMesh.startPolySpatialXRMesh(&fbb)
    Unity_PolySpatial_Internals_PolySpatialXRMesh.add(changeState: changeState, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRMesh.add(meshId: meshId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRMesh.add(position: position, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRMesh.add(rotation: rotation, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRMesh.add(scale: scale, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRMesh.add(numVertices: numVertices, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRMesh.addVectorOf(vertices: vertices, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRMesh.addVectorOf(normals: normals, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRMesh.add(numTriangles: numTriangles, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRMesh.add(shortIndices: shortIndices, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRMesh.addVectorOf(indices16: indices16, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRMesh.addVectorOf(indices32: indices32, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialXRMesh.endPolySpatialXRMesh(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.changeState.p, fieldName: "changeState", required: false, type: Unity_PolySpatial_Internals_PolySpatialMeshChangeState.self)
    try _v.visit(field: VTOFFSET.meshId.p, fieldName: "meshId", required: false, type: Unity_PolySpatial_Internals_TrackableID.self)
    try _v.visit(field: VTOFFSET.position.p, fieldName: "position", required: false, type: UnityEngine_Vector3.self)
    try _v.visit(field: VTOFFSET.rotation.p, fieldName: "rotation", required: false, type: UnityEngine_Quaternion.self)
    try _v.visit(field: VTOFFSET.scale.p, fieldName: "scale", required: false, type: UnityEngine_Vector3.self)
    try _v.visit(field: VTOFFSET.numVertices.p, fieldName: "numVertices", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.vertices.p, fieldName: "vertices", required: false, type: ForwardOffset<Vector<UnityEngine_Vector3, UnityEngine_Vector3>>.self)
    try _v.visit(field: VTOFFSET.normals.p, fieldName: "normals", required: false, type: ForwardOffset<Vector<UnityEngine_Vector3, UnityEngine_Vector3>>.self)
    try _v.visit(field: VTOFFSET.numTriangles.p, fieldName: "numTriangles", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.shortIndices.p, fieldName: "shortIndices", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.indices16.p, fieldName: "indices16", required: false, type: ForwardOffset<Vector<UInt16, UInt16>>.self)
    try _v.visit(field: VTOFFSET.indices32.p, fieldName: "indices32", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialXRMeshesChanged: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case addOrUpdatedArray = 4
    case removedArray = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Only contains PolySpatialXRMesh's to add or update.
  internal var hasAddOrUpdatedArray: Bool { let o = _accessor.offset(VTOFFSET.addOrUpdatedArray.v); return o == 0 ? false : true }
  internal var addOrUpdatedArrayCount: Int32 { let o = _accessor.offset(VTOFFSET.addOrUpdatedArray.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func addOrUpdatedArray(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialXRMesh? { let o = _accessor.offset(VTOFFSET.addOrUpdatedArray.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialXRMesh(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  internal var hasRemovedArray: Bool { let o = _accessor.offset(VTOFFSET.removedArray.v); return o == 0 ? false : true }
  internal var removedArrayCount: Int32 { let o = _accessor.offset(VTOFFSET.removedArray.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func removedArray(at index: Int32) -> Unity_PolySpatial_Internals_TrackableID? { let o = _accessor.offset(VTOFFSET.removedArray.v); return o == 0 ? nil : _accessor.directRead(of: Unity_PolySpatial_Internals_TrackableID.self, offset: _accessor.vector(at: o) + index * 16) }
  internal var removedArrayAsBuffer: UnsafeBufferPointer<Unity_PolySpatial_Internals_TrackableID>? { return _accessor.getBufferPointer(at: VTOFFSET.removedArray.v) }
  internal func mutableRemovedArray(at index: Int32) -> Unity_PolySpatial_Internals_TrackableID_Mutable? { let o = _accessor.offset(VTOFFSET.removedArray.v); return o == 0 ? nil : Unity_PolySpatial_Internals_TrackableID_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 16) }
  internal static func startPolySpatialXRMeshesChanged(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  internal static func addVectorOf(addOrUpdatedArray: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: addOrUpdatedArray, at: VTOFFSET.addOrUpdatedArray.p) }
  internal static func addVectorOf(removedArray: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: removedArray, at: VTOFFSET.removedArray.p) }
  internal static func startVectorOfRemovedArray(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Unity_PolySpatial_Internals_TrackableID>.size, elementSize: MemoryLayout<Unity_PolySpatial_Internals_TrackableID>.alignment)
  }
  internal static func endPolySpatialXRMeshesChanged(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialXRMeshesChanged(
    _ fbb: inout FlatBufferBuilder,
    addOrUpdatedArrayVectorOffset addOrUpdatedArray: Offset = Offset(),
    removedArrayVectorOffset removedArray: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialXRMeshesChanged.startPolySpatialXRMeshesChanged(&fbb)
    Unity_PolySpatial_Internals_PolySpatialXRMeshesChanged.addVectorOf(addOrUpdatedArray: addOrUpdatedArray, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRMeshesChanged.addVectorOf(removedArray: removedArray, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialXRMeshesChanged.endPolySpatialXRMeshesChanged(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.addOrUpdatedArray.p, fieldName: "addOrUpdatedArray", required: false, type: ForwardOffset<Vector<ForwardOffset<Unity_PolySpatial_Internals_PolySpatialXRMesh>, Unity_PolySpatial_Internals_PolySpatialXRMesh>>.self)
    try _v.visit(field: VTOFFSET.removedArray.p, fieldName: "removedArray", required: false, type: ForwardOffset<Vector<Unity_PolySpatial_Internals_TrackableID, Unity_PolySpatial_Internals_TrackableID>>.self)
    _v.finish()
  }
}

///  For storing ARTrackedImage data
internal struct Unity_PolySpatial_Internals_PolySpatialARTrackedImage: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case operation = 4
    case trackingId = 6
    case arImageTrackingState = 8
    case position = 10
    case rotation = 12
    case size = 14
    case referenceImageGuidlow = 16
    case referenceImageGuidhigh = 18
    case referenceImageTextureGuidlow = 20
    case referenceImageTextureGuidhigh = 22
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Adding, updating, or removing an ARTrackedImage
  internal var operation: Unity_PolySpatial_Internals_ARTrackedImageOperation { let o = _accessor.offset(VTOFFSET.operation.v); return o == 0 ? .created : Unity_PolySpatial_Internals_ARTrackedImageOperation(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .created }
  ///  Current TrackableID assigned to this ARTrackedImage.
  internal var trackingId: Unity_PolySpatial_Internals_TrackableID? { let o = _accessor.offset(VTOFFSET.trackingId.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_TrackableID.self, at: o) }
  internal var mutableTrackingId: Unity_PolySpatial_Internals_TrackableID_Mutable? { let o = _accessor.offset(VTOFFSET.trackingId.v); return o == 0 ? nil : Unity_PolySpatial_Internals_TrackableID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  If the ARTrackedImage is not tracked, tracked, or limited (poor) tracking.
  internal var arImageTrackingState: Unity_PolySpatial_Internals_ARImageTrackingState { let o = _accessor.offset(VTOFFSET.arImageTrackingState.v); return o == 0 ? .none_ : Unity_PolySpatial_Internals_ARImageTrackingState(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  ///  Position of its Pose.
  internal var position: UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.position.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector3.self, at: o) }
  internal var mutablePosition: UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.position.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Rotation of its Pose.
  internal var rotation: UnityEngine_Quaternion? { let o = _accessor.offset(VTOFFSET.rotation.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Quaternion.self, at: o) }
  internal var mutableRotation: UnityEngine_Quaternion_Mutable? { let o = _accessor.offset(VTOFFSET.rotation.v); return o == 0 ? nil : UnityEngine_Quaternion_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The size of the ARTrackedImage in meters.
  internal var size: UnityEngine_Vector2? { let o = _accessor.offset(VTOFFSET.size.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector2.self, at: o) }
  internal var mutableSize: UnityEngine_Vector2_Mutable? { let o = _accessor.offset(VTOFFSET.size.v); return o == 0 ? nil : UnityEngine_Vector2_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  First half of Guid associated with the reference image
  internal var referenceImageGuidlow: UInt64 { let o = _accessor.offset(VTOFFSET.referenceImageGuidlow.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  ///  Second half of Guid associated with the reference image
  internal var referenceImageGuidhigh: UInt64 { let o = _accessor.offset(VTOFFSET.referenceImageGuidhigh.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  ///  First half of Guid associated with the reference image texture
  internal var referenceImageTextureGuidlow: UInt64 { let o = _accessor.offset(VTOFFSET.referenceImageTextureGuidlow.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  ///  Second half of Guid associated with the reference image texture
  internal var referenceImageTextureGuidhigh: UInt64 { let o = _accessor.offset(VTOFFSET.referenceImageTextureGuidhigh.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  internal static func startPolySpatialARTrackedImage(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 10) }
  internal static func add(operation: Unity_PolySpatial_Internals_ARTrackedImageOperation, _ fbb: inout FlatBufferBuilder) { fbb.add(element: operation.rawValue, def: 0, at: VTOFFSET.operation.p) }
  internal static func add(trackingId: Unity_PolySpatial_Internals_TrackableID?, _ fbb: inout FlatBufferBuilder) { guard let trackingId = trackingId else { return }; fbb.create(struct: trackingId, position: VTOFFSET.trackingId.p) }
  internal static func add(arImageTrackingState: Unity_PolySpatial_Internals_ARImageTrackingState, _ fbb: inout FlatBufferBuilder) { fbb.add(element: arImageTrackingState.rawValue, def: 0, at: VTOFFSET.arImageTrackingState.p) }
  internal static func add(position: UnityEngine_Vector3?, _ fbb: inout FlatBufferBuilder) { guard let position = position else { return }; fbb.create(struct: position, position: VTOFFSET.position.p) }
  internal static func add(rotation: UnityEngine_Quaternion?, _ fbb: inout FlatBufferBuilder) { guard let rotation = rotation else { return }; fbb.create(struct: rotation, position: VTOFFSET.rotation.p) }
  internal static func add(size: UnityEngine_Vector2?, _ fbb: inout FlatBufferBuilder) { guard let size = size else { return }; fbb.create(struct: size, position: VTOFFSET.size.p) }
  internal static func add(referenceImageGuidlow: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: referenceImageGuidlow, def: 0, at: VTOFFSET.referenceImageGuidlow.p) }
  internal static func add(referenceImageGuidhigh: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: referenceImageGuidhigh, def: 0, at: VTOFFSET.referenceImageGuidhigh.p) }
  internal static func add(referenceImageTextureGuidlow: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: referenceImageTextureGuidlow, def: 0, at: VTOFFSET.referenceImageTextureGuidlow.p) }
  internal static func add(referenceImageTextureGuidhigh: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: referenceImageTextureGuidhigh, def: 0, at: VTOFFSET.referenceImageTextureGuidhigh.p) }
  internal static func endPolySpatialARTrackedImage(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialARTrackedImage(
    _ fbb: inout FlatBufferBuilder,
    operation: Unity_PolySpatial_Internals_ARTrackedImageOperation = .created,
    trackingId: Unity_PolySpatial_Internals_TrackableID? = nil,
    arImageTrackingState: Unity_PolySpatial_Internals_ARImageTrackingState = .none_,
    position: UnityEngine_Vector3? = nil,
    rotation: UnityEngine_Quaternion? = nil,
    size: UnityEngine_Vector2? = nil,
    referenceImageGuidlow: UInt64 = 0,
    referenceImageGuidhigh: UInt64 = 0,
    referenceImageTextureGuidlow: UInt64 = 0,
    referenceImageTextureGuidhigh: UInt64 = 0
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialARTrackedImage.startPolySpatialARTrackedImage(&fbb)
    Unity_PolySpatial_Internals_PolySpatialARTrackedImage.add(operation: operation, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARTrackedImage.add(trackingId: trackingId, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARTrackedImage.add(arImageTrackingState: arImageTrackingState, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARTrackedImage.add(position: position, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARTrackedImage.add(rotation: rotation, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARTrackedImage.add(size: size, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARTrackedImage.add(referenceImageGuidlow: referenceImageGuidlow, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARTrackedImage.add(referenceImageGuidhigh: referenceImageGuidhigh, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARTrackedImage.add(referenceImageTextureGuidlow: referenceImageTextureGuidlow, &fbb)
    Unity_PolySpatial_Internals_PolySpatialARTrackedImage.add(referenceImageTextureGuidhigh: referenceImageTextureGuidhigh, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialARTrackedImage.endPolySpatialARTrackedImage(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.operation.p, fieldName: "operation", required: false, type: Unity_PolySpatial_Internals_ARTrackedImageOperation.self)
    try _v.visit(field: VTOFFSET.trackingId.p, fieldName: "trackingId", required: false, type: Unity_PolySpatial_Internals_TrackableID.self)
    try _v.visit(field: VTOFFSET.arImageTrackingState.p, fieldName: "arImageTrackingState", required: false, type: Unity_PolySpatial_Internals_ARImageTrackingState.self)
    try _v.visit(field: VTOFFSET.position.p, fieldName: "position", required: false, type: UnityEngine_Vector3.self)
    try _v.visit(field: VTOFFSET.rotation.p, fieldName: "rotation", required: false, type: UnityEngine_Quaternion.self)
    try _v.visit(field: VTOFFSET.size.p, fieldName: "size", required: false, type: UnityEngine_Vector2.self)
    try _v.visit(field: VTOFFSET.referenceImageGuidlow.p, fieldName: "referenceImageGuidlow", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.referenceImageGuidhigh.p, fieldName: "referenceImageGuidhigh", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.referenceImageTextureGuidlow.p, fieldName: "referenceImageTextureGuidlow", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.referenceImageTextureGuidhigh.p, fieldName: "referenceImageTextureGuidhigh", required: false, type: UInt64.self)
    _v.finish()
  }
}

///  To simplify transmission of PolySpatialARTrackedImage's
internal struct Unity_PolySpatial_Internals_PolySpatialARTrackedImageArray: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case images = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Collection of ARTrackedImage's.
  internal var hasImages: Bool { let o = _accessor.offset(VTOFFSET.images.v); return o == 0 ? false : true }
  internal var imagesCount: Int32 { let o = _accessor.offset(VTOFFSET.images.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func images(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialARTrackedImage? { let o = _accessor.offset(VTOFFSET.images.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialARTrackedImage(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  internal static func startPolySpatialARTrackedImageArray(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  internal static func addVectorOf(images: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: images, at: VTOFFSET.images.p) }
  internal static func endPolySpatialARTrackedImageArray(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialARTrackedImageArray(
    _ fbb: inout FlatBufferBuilder,
    imagesVectorOffset images: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialARTrackedImageArray.startPolySpatialARTrackedImageArray(&fbb)
    Unity_PolySpatial_Internals_PolySpatialARTrackedImageArray.addVectorOf(images: images, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialARTrackedImageArray.endPolySpatialARTrackedImageArray(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.images.p, fieldName: "images", required: false, type: ForwardOffset<Vector<ForwardOffset<Unity_PolySpatial_Internals_PolySpatialARTrackedImage>, Unity_PolySpatial_Internals_PolySpatialARTrackedImage>>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialXRReferenceImage: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case guidLow = 4
    case guidHigh = 6
    case textureGuidLow = 8
    case textureGuidHigh = 10
    case specifySize = 12
    case size = 14
    case name = 16
    case textureDesc = 18
    case textureData = 20
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  First half of Guid associated with the image
  internal var guidLow: UInt64 { let o = _accessor.offset(VTOFFSET.guidLow.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  ///  Second half of Guid associated with the image
  internal var guidHigh: UInt64 { let o = _accessor.offset(VTOFFSET.guidHigh.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  ///  First half of Guid associated with the texture
  internal var textureGuidLow: UInt64 { let o = _accessor.offset(VTOFFSET.textureGuidLow.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  ///  Second half of Guid associated with the texture
  internal var textureGuidHigh: UInt64 { let o = _accessor.offset(VTOFFSET.textureGuidHigh.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  ///  Does the XRReferenceImage support specifying a size?
  internal var specifySize: Bool { let o = _accessor.offset(VTOFFSET.specifySize.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  ///  Size of the image in meters
  internal var size: UnityEngine_Vector2? { let o = _accessor.offset(VTOFFSET.size.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector2.self, at: o) }
  internal var mutableSize: UnityEngine_Vector2_Mutable? { let o = _accessor.offset(VTOFFSET.size.v); return o == 0 ? nil : UnityEngine_Vector2_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  A name associated with this reference image.
  internal var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  ///  Description of attributes for a Texture2D
  internal var textureDesc: Unity_PolySpatial_Internals_PolySpatialTextureData? { let o = _accessor.offset(VTOFFSET.textureDesc.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialTextureData(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Binary payload for the above Texture2D
  internal var hasTextureData: Bool { let o = _accessor.offset(VTOFFSET.textureData.v); return o == 0 ? false : true }
  internal var textureDataCount: Int32 { let o = _accessor.offset(VTOFFSET.textureData.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func textureData(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.textureData.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  internal var textureData: [UInt8] { return _accessor.getVector(at: VTOFFSET.textureData.v) ?? [] }
  internal var textureDataAsBuffer: UnsafeBufferPointer<UInt8>? { return _accessor.getBufferPointer(at: VTOFFSET.textureData.v) }
  internal static func startPolySpatialXRReferenceImage(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 9) }
  internal static func add(guidLow: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: guidLow, def: 0, at: VTOFFSET.guidLow.p) }
  internal static func add(guidHigh: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: guidHigh, def: 0, at: VTOFFSET.guidHigh.p) }
  internal static func add(textureGuidLow: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: textureGuidLow, def: 0, at: VTOFFSET.textureGuidLow.p) }
  internal static func add(textureGuidHigh: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: textureGuidHigh, def: 0, at: VTOFFSET.textureGuidHigh.p) }
  internal static func add(specifySize: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: specifySize, def: false,
   at: VTOFFSET.specifySize.p) }
  internal static func add(size: UnityEngine_Vector2?, _ fbb: inout FlatBufferBuilder) { guard let size = size else { return }; fbb.create(struct: size, position: VTOFFSET.size.p) }
  internal static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  internal static func add(textureDesc: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: textureDesc, at: VTOFFSET.textureDesc.p) }
  internal static func addVectorOf(textureData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: textureData, at: VTOFFSET.textureData.p) }
  internal static func endPolySpatialXRReferenceImage(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialXRReferenceImage(
    _ fbb: inout FlatBufferBuilder,
    guidLow: UInt64 = 0,
    guidHigh: UInt64 = 0,
    textureGuidLow: UInt64 = 0,
    textureGuidHigh: UInt64 = 0,
    specifySize: Bool = false,
    size: UnityEngine_Vector2? = nil,
    nameOffset name: Offset = Offset(),
    textureDescOffset textureDesc: Offset = Offset(),
    textureDataVectorOffset textureData: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialXRReferenceImage.startPolySpatialXRReferenceImage(&fbb)
    Unity_PolySpatial_Internals_PolySpatialXRReferenceImage.add(guidLow: guidLow, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRReferenceImage.add(guidHigh: guidHigh, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRReferenceImage.add(textureGuidLow: textureGuidLow, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRReferenceImage.add(textureGuidHigh: textureGuidHigh, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRReferenceImage.add(specifySize: specifySize, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRReferenceImage.add(size: size, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRReferenceImage.add(name: name, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRReferenceImage.add(textureDesc: textureDesc, &fbb)
    Unity_PolySpatial_Internals_PolySpatialXRReferenceImage.addVectorOf(textureData: textureData, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialXRReferenceImage.endPolySpatialXRReferenceImage(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.guidLow.p, fieldName: "guidLow", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.guidHigh.p, fieldName: "guidHigh", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.textureGuidLow.p, fieldName: "textureGuidLow", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.textureGuidHigh.p, fieldName: "textureGuidHigh", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.specifySize.p, fieldName: "specifySize", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.size.p, fieldName: "size", required: false, type: UnityEngine_Vector2.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.textureDesc.p, fieldName: "textureDesc", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialTextureData>.self)
    try _v.visit(field: VTOFFSET.textureData.p, fieldName: "textureData", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

///  To simplify transmission of PolySpatialXRReferenceImage's
internal struct Unity_PolySpatial_Internals_PolySpatialReferenceImageLibrary: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case referenceImages = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Collection of XRReferenceImage's.
  internal var hasReferenceImages: Bool { let o = _accessor.offset(VTOFFSET.referenceImages.v); return o == 0 ? false : true }
  internal var referenceImagesCount: Int32 { let o = _accessor.offset(VTOFFSET.referenceImages.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func referenceImages(at index: Int32) -> Unity_PolySpatial_Internals_PolySpatialXRReferenceImage? { let o = _accessor.offset(VTOFFSET.referenceImages.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialXRReferenceImage(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  internal static func startPolySpatialReferenceImageLibrary(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  internal static func addVectorOf(referenceImages: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: referenceImages, at: VTOFFSET.referenceImages.p) }
  internal static func endPolySpatialReferenceImageLibrary(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialReferenceImageLibrary(
    _ fbb: inout FlatBufferBuilder,
    referenceImagesVectorOffset referenceImages: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialReferenceImageLibrary.startPolySpatialReferenceImageLibrary(&fbb)
    Unity_PolySpatial_Internals_PolySpatialReferenceImageLibrary.addVectorOf(referenceImages: referenceImages, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialReferenceImageLibrary.endPolySpatialReferenceImageLibrary(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.referenceImages.p, fieldName: "referenceImages", required: false, type: ForwardOffset<Vector<ForwardOffset<Unity_PolySpatial_Internals_PolySpatialXRReferenceImage>, Unity_PolySpatial_Internals_PolySpatialXRReferenceImage>>.self)
    _v.finish()
  }
}

///  Table to describe the data of a line renderer for both baked mesh and replicate properties.
internal struct Unity_PolySpatial_Internals_PolySpatialLineRendererData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case isReplicatedPropertyDataAvailable = 4
    case isBakeToMeshDataAvailable = 6
    case renderData = 8
    case isWorldSpace = 10
    case propertyData = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Whether this data contains the property data required to replicate the line renderer.
  internal var isReplicatedPropertyDataAvailable: Bool { let o = _accessor.offset(VTOFFSET.isReplicatedPropertyDataAvailable.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var isBakeToMeshDataAvailable: Bool { let o = _accessor.offset(VTOFFSET.isBakeToMeshDataAvailable.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  ///  The render data of the baked mesh.
  internal var renderData: Unity_PolySpatial_Internals_PolySpatialRenderData? { let o = _accessor.offset(VTOFFSET.renderData.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialRenderData(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Whether the baked mesh is in world space. Used by both BakeToMesh and Replicate Properties.
  internal var isWorldSpace: Bool { let o = _accessor.offset(VTOFFSET.isWorldSpace.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  internal var propertyData: Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData? { let o = _accessor.offset(VTOFFSET.propertyData.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  internal static func startPolySpatialLineRendererData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  internal static func add(isReplicatedPropertyDataAvailable: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isReplicatedPropertyDataAvailable, def: false,
   at: VTOFFSET.isReplicatedPropertyDataAvailable.p) }
  internal static func add(isBakeToMeshDataAvailable: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isBakeToMeshDataAvailable, def: false,
   at: VTOFFSET.isBakeToMeshDataAvailable.p) }
  internal static func add(renderData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: renderData, at: VTOFFSET.renderData.p) }
  internal static func add(isWorldSpace: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isWorldSpace, def: false,
   at: VTOFFSET.isWorldSpace.p) }
  internal static func add(propertyData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: propertyData, at: VTOFFSET.propertyData.p) }
  internal static func endPolySpatialLineRendererData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialLineRendererData(
    _ fbb: inout FlatBufferBuilder,
    isReplicatedPropertyDataAvailable: Bool = false,
    isBakeToMeshDataAvailable: Bool = false,
    renderDataOffset renderData: Offset = Offset(),
    isWorldSpace: Bool = false,
    propertyDataOffset propertyData: Offset = Offset()
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialLineRendererData.startPolySpatialLineRendererData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererData.add(isReplicatedPropertyDataAvailable: isReplicatedPropertyDataAvailable, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererData.add(isBakeToMeshDataAvailable: isBakeToMeshDataAvailable, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererData.add(renderData: renderData, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererData.add(isWorldSpace: isWorldSpace, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererData.add(propertyData: propertyData, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialLineRendererData.endPolySpatialLineRendererData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.isReplicatedPropertyDataAvailable.p, fieldName: "isReplicatedPropertyDataAvailable", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.isBakeToMeshDataAvailable.p, fieldName: "isBakeToMeshDataAvailable", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.renderData.p, fieldName: "renderData", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialRenderData>.self)
    try _v.visit(field: VTOFFSET.isWorldSpace.p, fieldName: "isWorldSpace", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.propertyData.p, fieldName: "propertyData", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData>.self)
    _v.finish()
  }
}

internal struct Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case unityRendererData = 4
    case loop = 6
    case positionBuffer = 8
    case colorGradient = 10
    case lineAlignment = 12
    case widthCurve = 14
    case shadowBias = 16
    case numCornerVertices = 18
    case numCapVertices = 20
    case lineTextureMode = 22
    case textureScale = 24
    case generateLightingData = 26
    case spriteMaskInteraction = 28
    case widthMultiplier = 30
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The unity renderer data associated with the line renderer that isn't captured by PolySpatialRenderData.
  internal var unityRendererData: Unity_PolySpatial_Internals_PolySpatialUnityRendererData? { let o = _accessor.offset(VTOFFSET.unityRendererData.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialUnityRendererData(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Whether or not to loop the line renderer.
  internal var loop: Bool { let o = _accessor.offset(VTOFFSET.loop.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  ///  Buffer for the positions that make up the line renderer.
  internal var hasPositionBuffer: Bool { let o = _accessor.offset(VTOFFSET.positionBuffer.v); return o == 0 ? false : true }
  internal var positionBufferCount: Int32 { let o = _accessor.offset(VTOFFSET.positionBuffer.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func positionBuffer(at index: Int32) -> UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.positionBuffer.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector3.self, offset: _accessor.vector(at: o) + index * 12) }
  internal var positionBufferAsBuffer: UnsafeBufferPointer<UnityEngine_Vector3>? { return _accessor.getBufferPointer(at: VTOFFSET.positionBuffer.v) }
  internal func mutablePositionBuffer(at index: Int32) -> UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.positionBuffer.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 12) }
  ///  Color gradient for the line renderer.
  internal var colorGradient: Unity_PolySpatial_Internals_PolySpatialGradient? { let o = _accessor.offset(VTOFFSET.colorGradient.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialGradient(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  The line alignment mode of the line renderer.
  internal var lineAlignment: Unity_PolySpatial_Internals_PolySpatialLineRendererAlignment { let o = _accessor.offset(VTOFFSET.lineAlignment.v); return o == 0 ? .view : Unity_PolySpatial_Internals_PolySpatialLineRendererAlignment(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .view }
  ///  The width curve of the line renderer.
  internal var widthCurve: Unity_PolySpatial_Internals_PolySpatialAnimationCurve? { let o = _accessor.offset(VTOFFSET.widthCurve.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAnimationCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  The shadow bias of the line renderer.
  internal var shadowBias: Float32 { let o = _accessor.offset(VTOFFSET.shadowBias.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  ///  The number of corner vertices of the line renderer.
  internal var numCornerVertices: Int32 { let o = _accessor.offset(VTOFFSET.numCornerVertices.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The number of cap vertices of the line renderer.
  internal var numCapVertices: Int32 { let o = _accessor.offset(VTOFFSET.numCapVertices.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The line texture mode of the line renderer.
  internal var lineTextureMode: Unity_PolySpatial_Internals_PolySpatialLineRendererTextureMode { let o = _accessor.offset(VTOFFSET.lineTextureMode.v); return o == 0 ? .stretch : Unity_PolySpatial_Internals_PolySpatialLineRendererTextureMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .stretch }
  ///  The texture scale of the line renderer.
  internal var textureScale: UnityEngine_Vector2? { let o = _accessor.offset(VTOFFSET.textureScale.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector2.self, at: o) }
  internal var mutableTextureScale: UnityEngine_Vector2_Mutable? { let o = _accessor.offset(VTOFFSET.textureScale.v); return o == 0 ? nil : UnityEngine_Vector2_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Whether or not to generate lighting data for the line renderer.
  internal var generateLightingData: Bool { let o = _accessor.offset(VTOFFSET.generateLightingData.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  ///  The sprite masking operation for the line renderer.
  internal var spriteMaskInteraction: Unity_PolySpatial_Internals_PolySpatialMaskingOperation { let o = _accessor.offset(VTOFFSET.spriteMaskInteraction.v); return o == 0 ? .none_ : Unity_PolySpatial_Internals_PolySpatialMaskingOperation(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .none_ }
  ///  The width multiplier for the width curve.
  internal var widthMultiplier: Float32 { let o = _accessor.offset(VTOFFSET.widthMultiplier.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal static func startPolySpatialLineRendererPropertyData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 14) }
  internal static func add(unityRendererData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: unityRendererData, at: VTOFFSET.unityRendererData.p) }
  internal static func add(loop: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: loop, def: false,
   at: VTOFFSET.loop.p) }
  internal static func addVectorOf(positionBuffer: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: positionBuffer, at: VTOFFSET.positionBuffer.p) }
  internal static func startVectorOfPositionBuffer(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector3>.size, elementSize: MemoryLayout<UnityEngine_Vector3>.alignment)
  }
  internal static func add(colorGradient: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: colorGradient, at: VTOFFSET.colorGradient.p) }
  internal static func add(lineAlignment: Unity_PolySpatial_Internals_PolySpatialLineRendererAlignment, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lineAlignment.rawValue, def: 0, at: VTOFFSET.lineAlignment.p) }
  internal static func add(widthCurve: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: widthCurve, at: VTOFFSET.widthCurve.p) }
  internal static func add(shadowBias: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: shadowBias, def: 0.0, at: VTOFFSET.shadowBias.p) }
  internal static func add(numCornerVertices: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numCornerVertices, def: 0, at: VTOFFSET.numCornerVertices.p) }
  internal static func add(numCapVertices: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numCapVertices, def: 0, at: VTOFFSET.numCapVertices.p) }
  internal static func add(lineTextureMode: Unity_PolySpatial_Internals_PolySpatialLineRendererTextureMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lineTextureMode.rawValue, def: 0, at: VTOFFSET.lineTextureMode.p) }
  internal static func add(textureScale: UnityEngine_Vector2?, _ fbb: inout FlatBufferBuilder) { guard let textureScale = textureScale else { return }; fbb.create(struct: textureScale, position: VTOFFSET.textureScale.p) }
  internal static func add(generateLightingData: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: generateLightingData, def: false,
   at: VTOFFSET.generateLightingData.p) }
  internal static func add(spriteMaskInteraction: Unity_PolySpatial_Internals_PolySpatialMaskingOperation, _ fbb: inout FlatBufferBuilder) { fbb.add(element: spriteMaskInteraction.rawValue, def: 0, at: VTOFFSET.spriteMaskInteraction.p) }
  internal static func add(widthMultiplier: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: widthMultiplier, def: 0.0, at: VTOFFSET.widthMultiplier.p) }
  internal static func endPolySpatialLineRendererPropertyData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialLineRendererPropertyData(
    _ fbb: inout FlatBufferBuilder,
    unityRendererDataOffset unityRendererData: Offset = Offset(),
    loop: Bool = false,
    positionBufferVectorOffset positionBuffer: Offset = Offset(),
    colorGradientOffset colorGradient: Offset = Offset(),
    lineAlignment: Unity_PolySpatial_Internals_PolySpatialLineRendererAlignment = .view,
    widthCurveOffset widthCurve: Offset = Offset(),
    shadowBias: Float32 = 0.0,
    numCornerVertices: Int32 = 0,
    numCapVertices: Int32 = 0,
    lineTextureMode: Unity_PolySpatial_Internals_PolySpatialLineRendererTextureMode = .stretch,
    textureScale: UnityEngine_Vector2? = nil,
    generateLightingData: Bool = false,
    spriteMaskInteraction: Unity_PolySpatial_Internals_PolySpatialMaskingOperation = .none_,
    widthMultiplier: Float32 = 0.0
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData.startPolySpatialLineRendererPropertyData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData.add(unityRendererData: unityRendererData, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData.add(loop: loop, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData.addVectorOf(positionBuffer: positionBuffer, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData.add(colorGradient: colorGradient, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData.add(lineAlignment: lineAlignment, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData.add(widthCurve: widthCurve, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData.add(shadowBias: shadowBias, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData.add(numCornerVertices: numCornerVertices, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData.add(numCapVertices: numCapVertices, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData.add(lineTextureMode: lineTextureMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData.add(textureScale: textureScale, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData.add(generateLightingData: generateLightingData, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData.add(spriteMaskInteraction: spriteMaskInteraction, &fbb)
    Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData.add(widthMultiplier: widthMultiplier, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialLineRendererPropertyData.endPolySpatialLineRendererPropertyData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.unityRendererData.p, fieldName: "unityRendererData", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialUnityRendererData>.self)
    try _v.visit(field: VTOFFSET.loop.p, fieldName: "loop", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.positionBuffer.p, fieldName: "positionBuffer", required: false, type: ForwardOffset<Vector<UnityEngine_Vector3, UnityEngine_Vector3>>.self)
    try _v.visit(field: VTOFFSET.colorGradient.p, fieldName: "colorGradient", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialGradient>.self)
    try _v.visit(field: VTOFFSET.lineAlignment.p, fieldName: "lineAlignment", required: false, type: Unity_PolySpatial_Internals_PolySpatialLineRendererAlignment.self)
    try _v.visit(field: VTOFFSET.widthCurve.p, fieldName: "widthCurve", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialAnimationCurve>.self)
    try _v.visit(field: VTOFFSET.shadowBias.p, fieldName: "shadowBias", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.numCornerVertices.p, fieldName: "numCornerVertices", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.numCapVertices.p, fieldName: "numCapVertices", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.lineTextureMode.p, fieldName: "lineTextureMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialLineRendererTextureMode.self)
    try _v.visit(field: VTOFFSET.textureScale.p, fieldName: "textureScale", required: false, type: UnityEngine_Vector2.self)
    try _v.visit(field: VTOFFSET.generateLightingData.p, fieldName: "generateLightingData", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.spriteMaskInteraction.p, fieldName: "spriteMaskInteraction", required: false, type: Unity_PolySpatial_Internals_PolySpatialMaskingOperation.self)
    try _v.visit(field: VTOFFSET.widthMultiplier.p, fieldName: "widthMultiplier", required: false, type: Float32.self)
    _v.finish()
  }
}

///  Describes the data of a trail renderer for handcrafted serialized properties protocol messages.
internal struct Unity_PolySpatial_Internals_PolySpatialTrailRendererData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case renderData = 4
    case emitting = 6
    case time = 8
    case autodestruct = 10
    case minVertexDistance = 12
    case loop = 14
    case positionBuffer = 16
    case colorGradient = 18
    case lineAlignment = 20
    case widthCurve = 22
    case shadowBias = 24
    case numCornerVertices = 26
    case numCapVertices = 28
    case lineTextureMode = 30
    case textureScale = 32
    case generateLightingData = 34
    case spriteMaskInteraction = 36
    case widthMultiplier = 38
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The material IDs and other render data.
  internal var renderData: Unity_PolySpatial_Internals_PolySpatialRenderData? { let o = _accessor.offset(VTOFFSET.renderData.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialRenderData(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Pause / unpause trail generation.
  internal var emitting: Bool { let o = _accessor.offset(VTOFFSET.emitting.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  ///  How long the tail should be in seconds.
  internal var time: Float32 { let o = _accessor.offset(VTOFFSET.time.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  ///  Whether to destroy the GameObject when there is no trail.
  internal var autodestruct: Bool { let o = _accessor.offset(VTOFFSET.autodestruct.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  ///  The minimum distance to spawn a new point on the trail
  internal var minVertexDistance: Float32 { let o = _accessor.offset(VTOFFSET.minVertexDistance.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  ///  Whether or not to loop the line renderer.
  internal var loop: Bool { let o = _accessor.offset(VTOFFSET.loop.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  ///  Buffer for the positions that make up the line renderer.
  internal var hasPositionBuffer: Bool { let o = _accessor.offset(VTOFFSET.positionBuffer.v); return o == 0 ? false : true }
  internal var positionBufferCount: Int32 { let o = _accessor.offset(VTOFFSET.positionBuffer.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func positionBuffer(at index: Int32) -> UnityEngine_Vector3? { let o = _accessor.offset(VTOFFSET.positionBuffer.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Vector3.self, offset: _accessor.vector(at: o) + index * 12) }
  internal var positionBufferAsBuffer: UnsafeBufferPointer<UnityEngine_Vector3>? { return _accessor.getBufferPointer(at: VTOFFSET.positionBuffer.v) }
  internal func mutablePositionBuffer(at index: Int32) -> UnityEngine_Vector3_Mutable? { let o = _accessor.offset(VTOFFSET.positionBuffer.v); return o == 0 ? nil : UnityEngine_Vector3_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 12) }
  ///  Color gradient for the line renderer.
  internal var colorGradient: Unity_PolySpatial_Internals_PolySpatialGradient? { let o = _accessor.offset(VTOFFSET.colorGradient.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialGradient(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  The line alignment mode of the line renderer.
  internal var lineAlignment: Unity_PolySpatial_Internals_PolySpatialLineRendererAlignment { let o = _accessor.offset(VTOFFSET.lineAlignment.v); return o == 0 ? .view : Unity_PolySpatial_Internals_PolySpatialLineRendererAlignment(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .view }
  ///  The width curve of the line renderer.
  internal var widthCurve: Unity_PolySpatial_Internals_PolySpatialAnimationCurve? { let o = _accessor.offset(VTOFFSET.widthCurve.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialAnimationCurve(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  The shadow bias of the line renderer.
  internal var shadowBias: Float32 { let o = _accessor.offset(VTOFFSET.shadowBias.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  ///  The number of corner vertices of the line renderer.
  internal var numCornerVertices: Int32 { let o = _accessor.offset(VTOFFSET.numCornerVertices.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The number of cap vertices of the line renderer.
  internal var numCapVertices: Int32 { let o = _accessor.offset(VTOFFSET.numCapVertices.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The line texture mode of the line renderer.
  internal var lineTextureMode: Unity_PolySpatial_Internals_PolySpatialLineRendererTextureMode { let o = _accessor.offset(VTOFFSET.lineTextureMode.v); return o == 0 ? .stretch : Unity_PolySpatial_Internals_PolySpatialLineRendererTextureMode(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .stretch }
  ///  The texture scale of the line renderer.
  internal var textureScale: UnityEngine_Vector2? { let o = _accessor.offset(VTOFFSET.textureScale.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Vector2.self, at: o) }
  internal var mutableTextureScale: UnityEngine_Vector2_Mutable? { let o = _accessor.offset(VTOFFSET.textureScale.v); return o == 0 ? nil : UnityEngine_Vector2_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  Whether or not to generate lighting data for the line renderer.
  internal var generateLightingData: Bool { let o = _accessor.offset(VTOFFSET.generateLightingData.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  ///  The sprite masking operation for the line renderer.
  internal var spriteMaskInteraction: Unity_PolySpatial_Internals_PolySpatialMaskingOperation { let o = _accessor.offset(VTOFFSET.spriteMaskInteraction.v); return o == 0 ? .none_ : Unity_PolySpatial_Internals_PolySpatialMaskingOperation(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .none_ }
  ///  The width multiplier for the width curve.
  internal var widthMultiplier: Float32 { let o = _accessor.offset(VTOFFSET.widthMultiplier.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  internal static func startPolySpatialTrailRendererData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 18) }
  internal static func add(renderData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: renderData, at: VTOFFSET.renderData.p) }
  internal static func add(emitting: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: emitting, def: false,
   at: VTOFFSET.emitting.p) }
  internal static func add(time: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: time, def: 0.0, at: VTOFFSET.time.p) }
  internal static func add(autodestruct: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: autodestruct, def: false,
   at: VTOFFSET.autodestruct.p) }
  internal static func add(minVertexDistance: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: minVertexDistance, def: 0.0, at: VTOFFSET.minVertexDistance.p) }
  internal static func add(loop: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: loop, def: false,
   at: VTOFFSET.loop.p) }
  internal static func addVectorOf(positionBuffer: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: positionBuffer, at: VTOFFSET.positionBuffer.p) }
  internal static func startVectorOfPositionBuffer(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Vector3>.size, elementSize: MemoryLayout<UnityEngine_Vector3>.alignment)
  }
  internal static func add(colorGradient: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: colorGradient, at: VTOFFSET.colorGradient.p) }
  internal static func add(lineAlignment: Unity_PolySpatial_Internals_PolySpatialLineRendererAlignment, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lineAlignment.rawValue, def: 0, at: VTOFFSET.lineAlignment.p) }
  internal static func add(widthCurve: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: widthCurve, at: VTOFFSET.widthCurve.p) }
  internal static func add(shadowBias: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: shadowBias, def: 0.0, at: VTOFFSET.shadowBias.p) }
  internal static func add(numCornerVertices: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numCornerVertices, def: 0, at: VTOFFSET.numCornerVertices.p) }
  internal static func add(numCapVertices: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numCapVertices, def: 0, at: VTOFFSET.numCapVertices.p) }
  internal static func add(lineTextureMode: Unity_PolySpatial_Internals_PolySpatialLineRendererTextureMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lineTextureMode.rawValue, def: 0, at: VTOFFSET.lineTextureMode.p) }
  internal static func add(textureScale: UnityEngine_Vector2?, _ fbb: inout FlatBufferBuilder) { guard let textureScale = textureScale else { return }; fbb.create(struct: textureScale, position: VTOFFSET.textureScale.p) }
  internal static func add(generateLightingData: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: generateLightingData, def: false,
   at: VTOFFSET.generateLightingData.p) }
  internal static func add(spriteMaskInteraction: Unity_PolySpatial_Internals_PolySpatialMaskingOperation, _ fbb: inout FlatBufferBuilder) { fbb.add(element: spriteMaskInteraction.rawValue, def: 0, at: VTOFFSET.spriteMaskInteraction.p) }
  internal static func add(widthMultiplier: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: widthMultiplier, def: 0.0, at: VTOFFSET.widthMultiplier.p) }
  internal static func endPolySpatialTrailRendererData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialTrailRendererData(
    _ fbb: inout FlatBufferBuilder,
    renderDataOffset renderData: Offset = Offset(),
    emitting: Bool = false,
    time: Float32 = 0.0,
    autodestruct: Bool = false,
    minVertexDistance: Float32 = 0.0,
    loop: Bool = false,
    positionBufferVectorOffset positionBuffer: Offset = Offset(),
    colorGradientOffset colorGradient: Offset = Offset(),
    lineAlignment: Unity_PolySpatial_Internals_PolySpatialLineRendererAlignment = .view,
    widthCurveOffset widthCurve: Offset = Offset(),
    shadowBias: Float32 = 0.0,
    numCornerVertices: Int32 = 0,
    numCapVertices: Int32 = 0,
    lineTextureMode: Unity_PolySpatial_Internals_PolySpatialLineRendererTextureMode = .stretch,
    textureScale: UnityEngine_Vector2? = nil,
    generateLightingData: Bool = false,
    spriteMaskInteraction: Unity_PolySpatial_Internals_PolySpatialMaskingOperation = .none_,
    widthMultiplier: Float32 = 0.0
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialTrailRendererData.startPolySpatialTrailRendererData(&fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.add(renderData: renderData, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.add(emitting: emitting, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.add(time: time, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.add(autodestruct: autodestruct, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.add(minVertexDistance: minVertexDistance, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.add(loop: loop, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.addVectorOf(positionBuffer: positionBuffer, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.add(colorGradient: colorGradient, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.add(lineAlignment: lineAlignment, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.add(widthCurve: widthCurve, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.add(shadowBias: shadowBias, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.add(numCornerVertices: numCornerVertices, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.add(numCapVertices: numCapVertices, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.add(lineTextureMode: lineTextureMode, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.add(textureScale: textureScale, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.add(generateLightingData: generateLightingData, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.add(spriteMaskInteraction: spriteMaskInteraction, &fbb)
    Unity_PolySpatial_Internals_PolySpatialTrailRendererData.add(widthMultiplier: widthMultiplier, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialTrailRendererData.endPolySpatialTrailRendererData(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.renderData.p, fieldName: "renderData", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialRenderData>.self)
    try _v.visit(field: VTOFFSET.emitting.p, fieldName: "emitting", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.time.p, fieldName: "time", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.autodestruct.p, fieldName: "autodestruct", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.minVertexDistance.p, fieldName: "minVertexDistance", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.loop.p, fieldName: "loop", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.positionBuffer.p, fieldName: "positionBuffer", required: false, type: ForwardOffset<Vector<UnityEngine_Vector3, UnityEngine_Vector3>>.self)
    try _v.visit(field: VTOFFSET.colorGradient.p, fieldName: "colorGradient", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialGradient>.self)
    try _v.visit(field: VTOFFSET.lineAlignment.p, fieldName: "lineAlignment", required: false, type: Unity_PolySpatial_Internals_PolySpatialLineRendererAlignment.self)
    try _v.visit(field: VTOFFSET.widthCurve.p, fieldName: "widthCurve", required: false, type: ForwardOffset<Unity_PolySpatial_Internals_PolySpatialAnimationCurve>.self)
    try _v.visit(field: VTOFFSET.shadowBias.p, fieldName: "shadowBias", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.numCornerVertices.p, fieldName: "numCornerVertices", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.numCapVertices.p, fieldName: "numCapVertices", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.lineTextureMode.p, fieldName: "lineTextureMode", required: false, type: Unity_PolySpatial_Internals_PolySpatialLineRendererTextureMode.self)
    try _v.visit(field: VTOFFSET.textureScale.p, fieldName: "textureScale", required: false, type: UnityEngine_Vector2.self)
    try _v.visit(field: VTOFFSET.generateLightingData.p, fieldName: "generateLightingData", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.spriteMaskInteraction.p, fieldName: "spriteMaskInteraction", required: false, type: Unity_PolySpatial_Internals_PolySpatialMaskingOperation.self)
    try _v.visit(field: VTOFFSET.widthMultiplier.p, fieldName: "widthMultiplier", required: false, type: Float32.self)
    _v.finish()
  }
}

///  Screen information for a host. Note that orientation or
///  resolution changes will require updates of most of the
///  same information, so we will just report screen info
///  each time that something changes.
/// 
///  This represents a slimmed down version of the [Screen](https://docs.unity3d.com/ScriptReference/Screen.html) class.
///  We will expand it to reflect all fields if and when needed.
internal struct Unity_PolySpatial_Internals_PolySpatialHostDisplayInfo: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case hostName = 4
    case currentResolution = 6
    case dpi = 8
    case safeArea = 10
    case cutouts = 12
    case orientation = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var hostName: String? { let o = _accessor.offset(VTOFFSET.hostName.v); return o == 0 ? nil : _accessor.string(at: o) }
  internal var hostNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.hostName.v) }
  ///  The current resolution of the screen
  internal var currentResolution: Unity_PolySpatial_Internals_PolySpatialHostDisplayResolution? { let o = _accessor.offset(VTOFFSET.currentResolution.v); return o == 0 ? nil : _accessor.readBuffer(of: Unity_PolySpatial_Internals_PolySpatialHostDisplayResolution.self, at: o) }
  internal var mutableCurrentResolution: Unity_PolySpatial_Internals_PolySpatialHostDisplayResolution_Mutable? { let o = _accessor.offset(VTOFFSET.currentResolution.v); return o == 0 ? nil : Unity_PolySpatial_Internals_PolySpatialHostDisplayResolution_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The DPI of the screen.
  internal var dpi: Float32 { let o = _accessor.offset(VTOFFSET.dpi.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  ///  The actuall rect area of the screen that the user can interact with.
  internal var safeArea: UnityEngine_Rect? { let o = _accessor.offset(VTOFFSET.safeArea.v); return o == 0 ? nil : _accessor.readBuffer(of: UnityEngine_Rect.self, at: o) }
  internal var mutableSafeArea: UnityEngine_Rect_Mutable? { let o = _accessor.offset(VTOFFSET.safeArea.v); return o == 0 ? nil : UnityEngine_Rect_Mutable(_accessor.bb, o: o + _accessor.postion) }
  ///  The areas of the screen that are cut out and not functional.
  internal var hasCutouts: Bool { let o = _accessor.offset(VTOFFSET.cutouts.v); return o == 0 ? false : true }
  internal var cutoutsCount: Int32 { let o = _accessor.offset(VTOFFSET.cutouts.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  internal func cutouts(at index: Int32) -> UnityEngine_Rect? { let o = _accessor.offset(VTOFFSET.cutouts.v); return o == 0 ? nil : _accessor.directRead(of: UnityEngine_Rect.self, offset: _accessor.vector(at: o) + index * 16) }
  internal var cutoutsAsBuffer: UnsafeBufferPointer<UnityEngine_Rect>? { return _accessor.getBufferPointer(at: VTOFFSET.cutouts.v) }
  internal func mutableCutouts(at index: Int32) -> UnityEngine_Rect_Mutable? { let o = _accessor.offset(VTOFFSET.cutouts.v); return o == 0 ? nil : UnityEngine_Rect_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 16) }
  ///  The orientation of the screen.
  internal var orientation: Unity_PolySpatial_Internals_PolySpatialHostDisplayOrientation { let o = _accessor.offset(VTOFFSET.orientation.v); return o == 0 ? .invalid : Unity_PolySpatial_Internals_PolySpatialHostDisplayOrientation(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .invalid }
  internal static func startPolySpatialHostDisplayInfo(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  internal static func add(hostName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: hostName, at: VTOFFSET.hostName.p) }
  internal static func add(currentResolution: Unity_PolySpatial_Internals_PolySpatialHostDisplayResolution?, _ fbb: inout FlatBufferBuilder) { guard let currentResolution = currentResolution else { return }; fbb.create(struct: currentResolution, position: VTOFFSET.currentResolution.p) }
  internal static func add(dpi: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dpi, def: 0.0, at: VTOFFSET.dpi.p) }
  internal static func add(safeArea: UnityEngine_Rect?, _ fbb: inout FlatBufferBuilder) { guard let safeArea = safeArea else { return }; fbb.create(struct: safeArea, position: VTOFFSET.safeArea.p) }
  internal static func addVectorOf(cutouts: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: cutouts, at: VTOFFSET.cutouts.p) }
  internal static func startVectorOfCutouts(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<UnityEngine_Rect>.size, elementSize: MemoryLayout<UnityEngine_Rect>.alignment)
  }
  internal static func add(orientation: Unity_PolySpatial_Internals_PolySpatialHostDisplayOrientation, _ fbb: inout FlatBufferBuilder) { fbb.add(element: orientation.rawValue, def: 0, at: VTOFFSET.orientation.p) }
  internal static func endPolySpatialHostDisplayInfo(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createPolySpatialHostDisplayInfo(
    _ fbb: inout FlatBufferBuilder,
    hostNameOffset hostName: Offset = Offset(),
    currentResolution: Unity_PolySpatial_Internals_PolySpatialHostDisplayResolution? = nil,
    dpi: Float32 = 0.0,
    safeArea: UnityEngine_Rect? = nil,
    cutoutsVectorOffset cutouts: Offset = Offset(),
    orientation: Unity_PolySpatial_Internals_PolySpatialHostDisplayOrientation = .invalid
  ) -> Offset {
    let __start = Unity_PolySpatial_Internals_PolySpatialHostDisplayInfo.startPolySpatialHostDisplayInfo(&fbb)
    Unity_PolySpatial_Internals_PolySpatialHostDisplayInfo.add(hostName: hostName, &fbb)
    Unity_PolySpatial_Internals_PolySpatialHostDisplayInfo.add(currentResolution: currentResolution, &fbb)
    Unity_PolySpatial_Internals_PolySpatialHostDisplayInfo.add(dpi: dpi, &fbb)
    Unity_PolySpatial_Internals_PolySpatialHostDisplayInfo.add(safeArea: safeArea, &fbb)
    Unity_PolySpatial_Internals_PolySpatialHostDisplayInfo.addVectorOf(cutouts: cutouts, &fbb)
    Unity_PolySpatial_Internals_PolySpatialHostDisplayInfo.add(orientation: orientation, &fbb)
    return Unity_PolySpatial_Internals_PolySpatialHostDisplayInfo.endPolySpatialHostDisplayInfo(&fbb, start: __start)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.hostName.p, fieldName: "hostName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.currentResolution.p, fieldName: "currentResolution", required: false, type: Unity_PolySpatial_Internals_PolySpatialHostDisplayResolution.self)
    try _v.visit(field: VTOFFSET.dpi.p, fieldName: "dpi", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.safeArea.p, fieldName: "safeArea", required: false, type: UnityEngine_Rect.self)
    try _v.visit(field: VTOFFSET.cutouts.p, fieldName: "cutouts", required: false, type: ForwardOffset<Vector<UnityEngine_Rect, UnityEngine_Rect>>.self)
    try _v.visit(field: VTOFFSET.orientation.p, fieldName: "orientation", required: false, type: Unity_PolySpatial_Internals_PolySpatialHostDisplayOrientation.self)
    _v.finish()
  }
}

